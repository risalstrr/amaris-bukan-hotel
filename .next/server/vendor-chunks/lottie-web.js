"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lottie-web";
exports.ids = ["vendor-chunks/lottie-web"];
exports.modules = {

/***/ "(ssr)/./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\ntypeof navigator !== \"undefined\" && function(global, factory) {\n     true ? module.exports = factory() : 0;\n}(void 0, function() {\n    \"use strict\";\n    var svgNS = \"http://www.w3.org/2000/svg\";\n    var locationHref = \"\";\n    var _useWebWorker = false;\n    var initialDefaultFrame = -999999;\n    var setWebWorker = function setWebWorker(flag) {\n        _useWebWorker = !!flag;\n    };\n    var getWebWorker = function getWebWorker() {\n        return _useWebWorker;\n    };\n    var setLocationHref = function setLocationHref(value) {\n        locationHref = value;\n    };\n    var getLocationHref = function getLocationHref() {\n        return locationHref;\n    };\n    function createTag(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElement(type);\n    }\n    function extendPrototype(sources, destination) {\n        var i;\n        var len = sources.length;\n        var sourcePrototype;\n        for(i = 0; i < len; i += 1){\n            sourcePrototype = sources[i].prototype;\n            for(var attr in sourcePrototype){\n                if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];\n            }\n        }\n    }\n    function getDescriptor(object, prop) {\n        return Object.getOwnPropertyDescriptor(object, prop);\n    }\n    function createProxyFunction(prototype) {\n        function ProxyFunction() {}\n        ProxyFunction.prototype = prototype;\n        return ProxyFunction;\n    }\n    // import Howl from '../../3rd_party/howler';\n    var audioControllerFactory = function() {\n        function AudioController(audioFactory) {\n            this.audios = [];\n            this.audioFactory = audioFactory;\n            this._volume = 1;\n            this._isMuted = false;\n        }\n        AudioController.prototype = {\n            addAudio: function addAudio(audio) {\n                this.audios.push(audio);\n            },\n            pause: function pause() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].pause();\n                }\n            },\n            resume: function resume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].resume();\n                }\n            },\n            setRate: function setRate(rateValue) {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].setRate(rateValue);\n                }\n            },\n            createAudio: function createAudio(assetPath) {\n                if (this.audioFactory) {\n                    return this.audioFactory(assetPath);\n                }\n                if (window.Howl) {\n                    return new window.Howl({\n                        src: [\n                            assetPath\n                        ]\n                    });\n                }\n                return {\n                    isPlaying: false,\n                    play: function play() {\n                        this.isPlaying = true;\n                    },\n                    seek: function seek() {\n                        this.isPlaying = false;\n                    },\n                    playing: function playing() {},\n                    rate: function rate() {},\n                    setVolume: function setVolume() {}\n                };\n            },\n            setAudioFactory: function setAudioFactory(audioFactory) {\n                this.audioFactory = audioFactory;\n            },\n            setVolume: function setVolume(value) {\n                this._volume = value;\n                this._updateVolume();\n            },\n            mute: function mute() {\n                this._isMuted = true;\n                this._updateVolume();\n            },\n            unmute: function unmute() {\n                this._isMuted = false;\n                this._updateVolume();\n            },\n            getVolume: function getVolume() {\n                return this._volume;\n            },\n            _updateVolume: function _updateVolume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));\n                }\n            }\n        };\n        return function() {\n            return new AudioController();\n        };\n    }();\n    var createTypedArray = function() {\n        function createRegularArray(type, len) {\n            var i = 0;\n            var arr = [];\n            var value;\n            switch(type){\n                case \"int16\":\n                case \"uint8c\":\n                    value = 1;\n                    break;\n                default:\n                    value = 1.1;\n                    break;\n            }\n            for(i = 0; i < len; i += 1){\n                arr.push(value);\n            }\n            return arr;\n        }\n        function createTypedArrayFactory(type, len) {\n            if (type === \"float32\") {\n                return new Float32Array(len);\n            }\n            if (type === \"int16\") {\n                return new Int16Array(len);\n            }\n            if (type === \"uint8c\") {\n                return new Uint8ClampedArray(len);\n            }\n            return createRegularArray(type, len);\n        }\n        if (typeof Uint8ClampedArray === \"function\" && typeof Float32Array === \"function\") {\n            return createTypedArrayFactory;\n        }\n        return createRegularArray;\n    }();\n    function createSizedArray(len) {\n        return Array.apply(null, {\n            length: len\n        });\n    }\n    function _typeof$6(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$6 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$6 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$6(obj);\n    }\n    var subframeEnabled = true;\n    var expressionsPlugin = null;\n    var expressionsInterfaces = null;\n    var idPrefix$1 = \"\";\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    var _shouldRoundValues = false;\n    var bmPow = Math.pow;\n    var bmSqrt = Math.sqrt;\n    var bmFloor = Math.floor;\n    var bmMax = Math.max;\n    var bmMin = Math.min;\n    var BMMath = {};\n    (function() {\n        var propertyNames = [\n            \"abs\",\n            \"acos\",\n            \"acosh\",\n            \"asin\",\n            \"asinh\",\n            \"atan\",\n            \"atanh\",\n            \"atan2\",\n            \"ceil\",\n            \"cbrt\",\n            \"expm1\",\n            \"clz32\",\n            \"cos\",\n            \"cosh\",\n            \"exp\",\n            \"floor\",\n            \"fround\",\n            \"hypot\",\n            \"imul\",\n            \"log\",\n            \"log1p\",\n            \"log2\",\n            \"log10\",\n            \"max\",\n            \"min\",\n            \"pow\",\n            \"random\",\n            \"round\",\n            \"sign\",\n            \"sin\",\n            \"sinh\",\n            \"sqrt\",\n            \"tan\",\n            \"tanh\",\n            \"trunc\",\n            \"E\",\n            \"LN10\",\n            \"LN2\",\n            \"LOG10E\",\n            \"LOG2E\",\n            \"PI\",\n            \"SQRT1_2\",\n            \"SQRT2\"\n        ];\n        var i;\n        var len = propertyNames.length;\n        for(i = 0; i < len; i += 1){\n            BMMath[propertyNames[i]] = Math[propertyNames[i]];\n        }\n    })();\n    function ProjectInterface$1() {\n        return {};\n    }\n    BMMath.random = Math.random;\n    BMMath.abs = function(val) {\n        var tOfVal = _typeof$6(val);\n        if (tOfVal === \"object\" && val.length) {\n            var absArr = createSizedArray(val.length);\n            var i;\n            var len = val.length;\n            for(i = 0; i < len; i += 1){\n                absArr[i] = Math.abs(val[i]);\n            }\n            return absArr;\n        }\n        return Math.abs(val);\n    };\n    var defaultCurveSegments = 150;\n    var degToRads = Math.PI / 180;\n    var roundCorner = 0.5519;\n    function roundValues(flag) {\n        _shouldRoundValues = !!flag;\n    }\n    function bmRnd(value) {\n        if (_shouldRoundValues) {\n            return Math.round(value);\n        }\n        return value;\n    }\n    function styleDiv(element) {\n        element.style.position = \"absolute\";\n        element.style.top = 0;\n        element.style.left = 0;\n        element.style.display = \"block\";\n        element.style.transformOrigin = \"0 0\";\n        element.style.webkitTransformOrigin = \"0 0\";\n        element.style.backfaceVisibility = \"visible\";\n        element.style.webkitBackfaceVisibility = \"visible\";\n        element.style.transformStyle = \"preserve-3d\";\n        element.style.webkitTransformStyle = \"preserve-3d\";\n        element.style.mozTransformStyle = \"preserve-3d\";\n    }\n    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n        this.type = type;\n        this.currentTime = currentTime;\n        this.totalTime = totalTime;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteEvent(type, frameMultiplier) {\n        this.type = type;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n        this.type = type;\n        this.currentLoop = currentLoop;\n        this.totalLoops = totalLoops;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n        this.type = type;\n        this.firstFrame = firstFrame;\n        this.totalFrames = totalFrames;\n    }\n    function BMDestroyEvent(type, target) {\n        this.type = type;\n        this.target = target;\n    }\n    function BMRenderFrameErrorEvent(nativeError, currentTime) {\n        this.type = \"renderFrameError\";\n        this.nativeError = nativeError;\n        this.currentTime = currentTime;\n    }\n    function BMConfigErrorEvent(nativeError) {\n        this.type = \"configError\";\n        this.nativeError = nativeError;\n    }\n    function BMAnimationConfigErrorEvent(type, nativeError) {\n        this.type = type;\n        this.nativeError = nativeError;\n    }\n    var createElementID = function() {\n        var _count = 0;\n        return function createID() {\n            _count += 1;\n            return idPrefix$1 + \"__lottie_element_\" + _count;\n        };\n    }();\n    function HSVtoRGB(h, s, v) {\n        var r;\n        var g;\n        var b;\n        var i;\n        var f;\n        var p;\n        var q;\n        var t;\n        i = Math.floor(h * 6);\n        f = h * 6 - i;\n        p = v * (1 - s);\n        q = v * (1 - f * s);\n        t = v * (1 - (1 - f) * s);\n        switch(i % 6){\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            case 5:\n                r = v;\n                g = p;\n                b = q;\n                break;\n            default:\n                break;\n        }\n        return [\n            r,\n            g,\n            b\n        ];\n    }\n    function RGBtoHSV(r, g, b) {\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var d = max - min;\n        var h;\n        var s = max === 0 ? 0 : d / max;\n        var v = max / 255;\n        switch(max){\n            case min:\n                h = 0;\n                break;\n            case r:\n                h = g - b + d * (g < b ? 6 : 0);\n                h /= 6 * d;\n                break;\n            case g:\n                h = b - r + d * 2;\n                h /= 6 * d;\n                break;\n            case b:\n                h = r - g + d * 4;\n                h /= 6 * d;\n                break;\n            default:\n                break;\n        }\n        return [\n            h,\n            s,\n            v\n        ];\n    }\n    function addSaturationToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[1] += offset;\n        if (hsv[1] > 1) {\n            hsv[1] = 1;\n        } else if (hsv[1] <= 0) {\n            hsv[1] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addBrightnessToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[2] += offset;\n        if (hsv[2] > 1) {\n            hsv[2] = 1;\n        } else if (hsv[2] < 0) {\n            hsv[2] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addHueToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[0] += offset / 360;\n        if (hsv[0] > 1) {\n            hsv[0] -= 1;\n        } else if (hsv[0] < 0) {\n            hsv[0] += 1;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    var rgbToHex = function() {\n        var colorMap = [];\n        var i;\n        var hex;\n        for(i = 0; i < 256; i += 1){\n            hex = i.toString(16);\n            colorMap[i] = hex.length === 1 ? \"0\" + hex : hex;\n        }\n        return function(r, g, b) {\n            if (r < 0) {\n                r = 0;\n            }\n            if (g < 0) {\n                g = 0;\n            }\n            if (b < 0) {\n                b = 0;\n            }\n            return \"#\" + colorMap[r] + colorMap[g] + colorMap[b];\n        };\n    }();\n    var setSubframeEnabled = function setSubframeEnabled(flag) {\n        subframeEnabled = !!flag;\n    };\n    var getSubframeEnabled = function getSubframeEnabled() {\n        return subframeEnabled;\n    };\n    var setExpressionsPlugin = function setExpressionsPlugin(value) {\n        expressionsPlugin = value;\n    };\n    var getExpressionsPlugin = function getExpressionsPlugin() {\n        return expressionsPlugin;\n    };\n    var setExpressionInterfaces = function setExpressionInterfaces(value) {\n        expressionsInterfaces = value;\n    };\n    var getExpressionInterfaces = function getExpressionInterfaces() {\n        return expressionsInterfaces;\n    };\n    var setDefaultCurveSegments = function setDefaultCurveSegments(value) {\n        defaultCurveSegments = value;\n    };\n    var getDefaultCurveSegments = function getDefaultCurveSegments() {\n        return defaultCurveSegments;\n    };\n    var setIdPrefix = function setIdPrefix(value) {\n        idPrefix$1 = value;\n    };\n    var getIdPrefix = function getIdPrefix() {\n        return idPrefix$1;\n    };\n    function createNS(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElementNS(svgNS, type);\n    }\n    function _typeof$5(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$5 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$5 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$5(obj);\n    }\n    var dataManager = function() {\n        var _counterId = 1;\n        var processes = [];\n        var workerFn;\n        var workerInstance;\n        var workerProxy = {\n            onmessage: function onmessage() {},\n            postMessage: function postMessage(path) {\n                workerFn({\n                    data: path\n                });\n            }\n        };\n        var _workerSelf = {\n            postMessage: function postMessage(data) {\n                workerProxy.onmessage({\n                    data: data\n                });\n            }\n        };\n        function createWorker(fn) {\n            if (window.Worker && window.Blob && getWebWorker()) {\n                var blob = new Blob([\n                    \"var _workerSelf = self; self.onmessage = \",\n                    fn.toString()\n                ], {\n                    type: \"text/javascript\"\n                }); // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                return new Worker(url);\n            }\n            workerFn = fn;\n            return workerProxy;\n        }\n        function setupWorker() {\n            if (!workerInstance) {\n                workerInstance = createWorker(function workerStart(e) {\n                    function dataFunctionManager() {\n                        function completeLayers(layers, comps) {\n                            var layerData;\n                            var i;\n                            var len = layers.length;\n                            var j;\n                            var jLen;\n                            var k;\n                            var kLen;\n                            for(i = 0; i < len; i += 1){\n                                layerData = layers[i];\n                                if (\"ks\" in layerData && !layerData.completed) {\n                                    layerData.completed = true;\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 0) {\n                                        layerData.layers = findCompLayers(layerData.refId, comps);\n                                        completeLayers(layerData.layers, comps);\n                                    } else if (layerData.ty === 4) {\n                                        completeShapes(layerData.shapes);\n                                    } else if (layerData.ty === 5) {\n                                        completeText(layerData);\n                                    }\n                                }\n                            }\n                        }\n                        function completeChars(chars, assets) {\n                            if (chars) {\n                                var i = 0;\n                                var len = chars.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (chars[i].t === 1) {\n                                        // var compData = findComp(chars[i].data.refId, assets);\n                                        chars[i].data.layers = findCompLayers(chars[i].data.refId, assets); // chars[i].data.ip = 0;\n                                        // chars[i].data.op = 99999;\n                                        // chars[i].data.st = 0;\n                                        // chars[i].data.sr = 1;\n                                        // chars[i].w = compData.w;\n                                        // chars[i].data.ks = {\n                                        //   a: { k: [0, 0, 0], a: 0 },\n                                        //   p: { k: [0, -compData.h, 0], a: 0 },\n                                        //   r: { k: 0, a: 0 },\n                                        //   s: { k: [100, 100], a: 0 },\n                                        //   o: { k: 100, a: 0 },\n                                        // };\n                                        completeLayers(chars[i].data.layers, assets);\n                                    }\n                                }\n                            }\n                        }\n                        function findComp(id, comps) {\n                            var i = 0;\n                            var len = comps.length;\n                            while(i < len){\n                                if (comps[i].id === id) {\n                                    return comps[i];\n                                }\n                                i += 1;\n                            }\n                            return null;\n                        }\n                        function findCompLayers(id, comps) {\n                            var comp = findComp(id, comps);\n                            if (comp) {\n                                if (!comp.layers.__used) {\n                                    comp.layers.__used = true;\n                                    return comp.layers;\n                                }\n                                return JSON.parse(JSON.stringify(comp.layers));\n                            }\n                            return null;\n                        }\n                        function completeShapes(arr) {\n                            var i;\n                            var len = arr.length;\n                            var j;\n                            var jLen;\n                            for(i = len - 1; i >= 0; i -= 1){\n                                if (arr[i].ty === \"sh\") {\n                                    if (arr[i].ks.k.i) {\n                                        convertPathsToAbsoluteValues(arr[i].ks.k);\n                                    } else {\n                                        jLen = arr[i].ks.k.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (arr[i].ks.k[j].s) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                                            }\n                                            if (arr[i].ks.k[j].e) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                                            }\n                                        }\n                                    }\n                                } else if (arr[i].ty === \"gr\") {\n                                    completeShapes(arr[i].it);\n                                }\n                            }\n                        }\n                        function convertPathsToAbsoluteValues(path) {\n                            var i;\n                            var len = path.i.length;\n                            for(i = 0; i < len; i += 1){\n                                path.i[i][0] += path.v[i][0];\n                                path.i[i][1] += path.v[i][1];\n                                path.o[i][0] += path.v[i][0];\n                                path.o[i][1] += path.v[i][1];\n                            }\n                        }\n                        function checkVersion(minimum, animVersionString) {\n                            var animVersion = animVersionString ? animVersionString.split(\".\") : [\n                                100,\n                                100,\n                                100\n                            ];\n                            if (minimum[0] > animVersion[0]) {\n                                return true;\n                            }\n                            if (animVersion[0] > minimum[0]) {\n                                return false;\n                            }\n                            if (minimum[1] > animVersion[1]) {\n                                return true;\n                            }\n                            if (animVersion[1] > minimum[1]) {\n                                return false;\n                            }\n                            if (minimum[2] > animVersion[2]) {\n                                return true;\n                            }\n                            if (animVersion[2] > minimum[2]) {\n                                return false;\n                            }\n                            return null;\n                        }\n                        var checkText = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                14\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var documentData = textLayer.t.d;\n                                textLayer.t.d = {\n                                    k: [\n                                        {\n                                            s: documentData,\n                                            t: 0\n                                        }\n                                    ]\n                                };\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkChars = function() {\n                            var minimumVersion = [\n                                4,\n                                7,\n                                99\n                            ];\n                            return function(animationData) {\n                                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                                    var i;\n                                    var len = animationData.chars.length;\n                                    for(i = 0; i < len; i += 1){\n                                        var charData = animationData.chars[i];\n                                        if (charData.data && charData.data.shapes) {\n                                            completeShapes(charData.data.shapes);\n                                            charData.data.ip = 0;\n                                            charData.data.op = 99999;\n                                            charData.data.st = 0;\n                                            charData.data.sr = 1;\n                                            charData.data.ks = {\n                                                p: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                s: {\n                                                    k: [\n                                                        100,\n                                                        100\n                                                    ],\n                                                    a: 0\n                                                },\n                                                a: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                r: {\n                                                    k: 0,\n                                                    a: 0\n                                                },\n                                                o: {\n                                                    k: 100,\n                                                    a: 0\n                                                }\n                                            };\n                                            if (!animationData.chars[i].t) {\n                                                charData.data.shapes.push({\n                                                    ty: \"no\"\n                                                });\n                                                charData.data.shapes[0].it.push({\n                                                    p: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    s: {\n                                                        k: [\n                                                            100,\n                                                            100\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    a: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    r: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    o: {\n                                                        k: 100,\n                                                        a: 0\n                                                    },\n                                                    sk: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    sa: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    ty: \"tr\"\n                                                });\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkPathProperties = function() {\n                            var minimumVersion = [\n                                5,\n                                7,\n                                15\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var pathData = textLayer.t.p;\n                                if (typeof pathData.a === \"number\") {\n                                    pathData.a = {\n                                        a: 0,\n                                        k: pathData.a\n                                    };\n                                }\n                                if (typeof pathData.p === \"number\") {\n                                    pathData.p = {\n                                        a: 0,\n                                        k: pathData.p\n                                    };\n                                }\n                                if (typeof pathData.r === \"number\") {\n                                    pathData.r = {\n                                        a: 0,\n                                        k: pathData.r\n                                    };\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkColors = function() {\n                            var minimumVersion = [\n                                4,\n                                1,\n                                9\n                            ];\n                            function iterateShapes(shapes) {\n                                var i;\n                                var len = shapes.length;\n                                var j;\n                                var jLen;\n                                for(i = 0; i < len; i += 1){\n                                    if (shapes[i].ty === \"gr\") {\n                                        iterateShapes(shapes[i].it);\n                                    } else if (shapes[i].ty === \"fl\" || shapes[i].ty === \"st\") {\n                                        if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                                            jLen = shapes[i].c.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (shapes[i].c.k[j].s) {\n                                                    shapes[i].c.k[j].s[0] /= 255;\n                                                    shapes[i].c.k[j].s[1] /= 255;\n                                                    shapes[i].c.k[j].s[2] /= 255;\n                                                    shapes[i].c.k[j].s[3] /= 255;\n                                                }\n                                                if (shapes[i].c.k[j].e) {\n                                                    shapes[i].c.k[j].e[0] /= 255;\n                                                    shapes[i].c.k[j].e[1] /= 255;\n                                                    shapes[i].c.k[j].e[2] /= 255;\n                                                    shapes[i].c.k[j].e[3] /= 255;\n                                                }\n                                            }\n                                        } else {\n                                            shapes[i].c.k[0] /= 255;\n                                            shapes[i].c.k[1] /= 255;\n                                            shapes[i].c.k[2] /= 255;\n                                            shapes[i].c.k[3] /= 255;\n                                        }\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 4) {\n                                        iterateShapes(layers[i].shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkShapes = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                18\n                            ];\n                            function completeClosingShapes(arr) {\n                                var i;\n                                var len = arr.length;\n                                var j;\n                                var jLen;\n                                for(i = len - 1; i >= 0; i -= 1){\n                                    if (arr[i].ty === \"sh\") {\n                                        if (arr[i].ks.k.i) {\n                                            arr[i].ks.k.c = arr[i].closed;\n                                        } else {\n                                            jLen = arr[i].ks.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (arr[i].ks.k[j].s) {\n                                                    arr[i].ks.k[j].s[0].c = arr[i].closed;\n                                                }\n                                                if (arr[i].ks.k[j].e) {\n                                                    arr[i].ks.k[j].e[0].c = arr[i].closed;\n                                                }\n                                            }\n                                        }\n                                    } else if (arr[i].ty === \"gr\") {\n                                        completeClosingShapes(arr[i].it);\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var layerData;\n                                var i;\n                                var len = layers.length;\n                                var j;\n                                var jLen;\n                                var k;\n                                var kLen;\n                                for(i = 0; i < len; i += 1){\n                                    layerData = layers[i];\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                maskProps[j].pt.k.c = maskProps[j].cl;\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 4) {\n                                        completeClosingShapes(layerData.shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        function completeData(animationData) {\n                            if (animationData.__complete) {\n                                return;\n                            }\n                            checkColors(animationData);\n                            checkText(animationData);\n                            checkChars(animationData);\n                            checkPathProperties(animationData);\n                            checkShapes(animationData);\n                            completeLayers(animationData.layers, animationData.assets);\n                            completeChars(animationData.chars, animationData.assets);\n                            animationData.__complete = true;\n                        }\n                        function completeText(data) {\n                            if (data.t.a.length === 0 && !(\"m\" in data.t.p)) {}\n                        }\n                        var moduleOb = {};\n                        moduleOb.completeData = completeData;\n                        moduleOb.checkColors = checkColors;\n                        moduleOb.checkChars = checkChars;\n                        moduleOb.checkPathProperties = checkPathProperties;\n                        moduleOb.checkShapes = checkShapes;\n                        moduleOb.completeLayers = completeLayers;\n                        return moduleOb;\n                    }\n                    if (!_workerSelf.dataManager) {\n                        _workerSelf.dataManager = dataFunctionManager();\n                    }\n                    if (!_workerSelf.assetLoader) {\n                        _workerSelf.assetLoader = function() {\n                            function formatResponse(xhr) {\n                                // using typeof doubles the time of execution of this method,\n                                // so if available, it's better to use the header to validate the type\n                                var contentTypeHeader = xhr.getResponseHeader(\"content-type\");\n                                if (contentTypeHeader && xhr.responseType === \"json\" && contentTypeHeader.indexOf(\"json\") !== -1) {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && _typeof$5(xhr.response) === \"object\") {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && typeof xhr.response === \"string\") {\n                                    return JSON.parse(xhr.response);\n                                }\n                                if (xhr.responseText) {\n                                    return JSON.parse(xhr.responseText);\n                                }\n                                return null;\n                            }\n                            function loadAsset(path, fullPath, callback, errorCallback) {\n                                var response;\n                                var xhr = new XMLHttpRequest(); // set responseType after calling open or IE will break.\n                                try {\n                                    // This crashes on Android WebView prior to KitKat\n                                    xhr.responseType = \"json\";\n                                } catch (err) {} // eslint-disable-line no-empty\n                                xhr.onreadystatechange = function() {\n                                    if (xhr.readyState === 4) {\n                                        if (xhr.status === 200) {\n                                            response = formatResponse(xhr);\n                                            callback(response);\n                                        } else {\n                                            try {\n                                                response = formatResponse(xhr);\n                                                callback(response);\n                                            } catch (err) {\n                                                if (errorCallback) {\n                                                    errorCallback(err);\n                                                }\n                                            }\n                                        }\n                                    }\n                                };\n                                try {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        \"G\",\n                                        \"E\",\n                                        \"T\"\n                                    ].join(\"\"), path, true);\n                                } catch (error) {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        \"G\",\n                                        \"E\",\n                                        \"T\"\n                                    ].join(\"\"), fullPath + \"/\" + path, true);\n                                }\n                                xhr.send();\n                            }\n                            return {\n                                load: loadAsset\n                            };\n                        }();\n                    }\n                    if (e.data.type === \"loadAnimation\") {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.dataManager.completeData(data);\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: \"success\"\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: \"error\"\n                            });\n                        });\n                    } else if (e.data.type === \"complete\") {\n                        var animation = e.data.animation;\n                        _workerSelf.dataManager.completeData(animation);\n                        _workerSelf.postMessage({\n                            id: e.data.id,\n                            payload: animation,\n                            status: \"success\"\n                        });\n                    } else if (e.data.type === \"loadData\") {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: \"success\"\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: \"error\"\n                            });\n                        });\n                    }\n                });\n                workerInstance.onmessage = function(event) {\n                    var data = event.data;\n                    var id = data.id;\n                    var process = processes[id];\n                    processes[id] = null;\n                    if (data.status === \"success\") {\n                        process.onComplete(data.payload);\n                    } else if (process.onError) {\n                        process.onError();\n                    }\n                };\n            }\n        }\n        function createProcess(onComplete, onError) {\n            _counterId += 1;\n            var id = \"processId_\" + _counterId;\n            processes[id] = {\n                onComplete: onComplete,\n                onError: onError\n            };\n            return id;\n        }\n        function loadAnimation(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"loadAnimation\",\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function loadData(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"loadData\",\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function completeAnimation(anim, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: \"complete\",\n                animation: anim,\n                id: processId\n            });\n        }\n        return {\n            loadAnimation: loadAnimation,\n            loadData: loadData,\n            completeAnimation: completeAnimation\n        };\n    }();\n    var ImagePreloader = function() {\n        var proxyImage = function() {\n            var canvas = createTag(\"canvas\");\n            canvas.width = 1;\n            canvas.height = 1;\n            var ctx = canvas.getContext(\"2d\");\n            ctx.fillStyle = \"rgba(0,0,0,0)\";\n            ctx.fillRect(0, 0, 1, 1);\n            return canvas;\n        }();\n        function imageLoaded() {\n            this.loadedAssets += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function footageLoaded() {\n            this.loadedFootagesCount += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function getAssetsPath(assetData, assetsPath, originalPath) {\n            var path = \"\";\n            if (assetData.e) {\n                path = assetData.p;\n            } else if (assetsPath) {\n                var imagePath = assetData.p;\n                if (imagePath.indexOf(\"images/\") !== -1) {\n                    imagePath = imagePath.split(\"/\")[1];\n                }\n                path = assetsPath + imagePath;\n            } else {\n                path = originalPath;\n                path += assetData.u ? assetData.u : \"\";\n                path += assetData.p;\n            }\n            return path;\n        }\n        function testImageLoaded(img) {\n            var _count = 0;\n            var intervalId = setInterval((function() {\n                var box = img.getBBox();\n                if (box.width || _count > 500) {\n                    this._imageLoaded();\n                    clearInterval(intervalId);\n                }\n                _count += 1;\n            }).bind(this), 50);\n        }\n        function createImageData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createNS(\"image\");\n            if (isSafari) {\n                this.testImageLoaded(img);\n            } else {\n                img.addEventListener(\"load\", this._imageLoaded, false);\n            }\n            img.addEventListener(\"error\", (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", path);\n            if (this._elementHelper.append) {\n                this._elementHelper.append(img);\n            } else {\n                this._elementHelper.appendChild(img);\n            }\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createImgData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createTag(\"img\");\n            img.crossOrigin = \"anonymous\";\n            img.addEventListener(\"load\", this._imageLoaded, false);\n            img.addEventListener(\"error\", (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.src = path;\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createFootageData(data) {\n            var ob = {\n                assetData: data\n            };\n            var path = getAssetsPath(data, this.assetsPath, this.path);\n            dataManager.loadData(path, (function(footageData) {\n                ob.img = footageData;\n                this._footageLoaded();\n            }).bind(this), (function() {\n                ob.img = {};\n                this._footageLoaded();\n            }).bind(this));\n            return ob;\n        }\n        function loadAssets(assets, cb) {\n            this.imagesLoadedCb = cb;\n            var i;\n            var len = assets.length;\n            for(i = 0; i < len; i += 1){\n                if (!assets[i].layers) {\n                    if (!assets[i].t || assets[i].t === \"seq\") {\n                        this.totalImages += 1;\n                        this.images.push(this._createImageData(assets[i]));\n                    } else if (assets[i].t === 3) {\n                        this.totalFootages += 1;\n                        this.images.push(this.createFootageData(assets[i]));\n                    }\n                }\n            }\n        }\n        function setPath(path) {\n            this.path = path || \"\";\n        }\n        function setAssetsPath(path) {\n            this.assetsPath = path || \"\";\n        }\n        function getAsset(assetData) {\n            var i = 0;\n            var len = this.images.length;\n            while(i < len){\n                if (this.images[i].assetData === assetData) {\n                    return this.images[i].img;\n                }\n                i += 1;\n            }\n            return null;\n        }\n        function destroy() {\n            this.imagesLoadedCb = null;\n            this.images.length = 0;\n        }\n        function loadedImages() {\n            return this.totalImages === this.loadedAssets;\n        }\n        function loadedFootages() {\n            return this.totalFootages === this.loadedFootagesCount;\n        }\n        function setCacheType(type, elementHelper) {\n            if (type === \"svg\") {\n                this._elementHelper = elementHelper;\n                this._createImageData = this.createImageData.bind(this);\n            } else {\n                this._createImageData = this.createImgData.bind(this);\n            }\n        }\n        function ImagePreloaderFactory() {\n            this._imageLoaded = imageLoaded.bind(this);\n            this._footageLoaded = footageLoaded.bind(this);\n            this.testImageLoaded = testImageLoaded.bind(this);\n            this.createFootageData = createFootageData.bind(this);\n            this.assetsPath = \"\";\n            this.path = \"\";\n            this.totalImages = 0;\n            this.totalFootages = 0;\n            this.loadedAssets = 0;\n            this.loadedFootagesCount = 0;\n            this.imagesLoadedCb = null;\n            this.images = [];\n        }\n        ImagePreloaderFactory.prototype = {\n            loadAssets: loadAssets,\n            setAssetsPath: setAssetsPath,\n            setPath: setPath,\n            loadedImages: loadedImages,\n            loadedFootages: loadedFootages,\n            destroy: destroy,\n            getAsset: getAsset,\n            createImgData: createImgData,\n            createImageData: createImageData,\n            imageLoaded: imageLoaded,\n            footageLoaded: footageLoaded,\n            setCacheType: setCacheType\n        };\n        return ImagePreloaderFactory;\n    }();\n    function BaseEvent() {}\n    BaseEvent.prototype = {\n        triggerEvent: function triggerEvent(eventName, args) {\n            if (this._cbs[eventName]) {\n                var callbacks = this._cbs[eventName];\n                for(var i = 0; i < callbacks.length; i += 1){\n                    callbacks[i](args);\n                }\n            }\n        },\n        addEventListener: function addEventListener(eventName, callback) {\n            if (!this._cbs[eventName]) {\n                this._cbs[eventName] = [];\n            }\n            this._cbs[eventName].push(callback);\n            return (function() {\n                this.removeEventListener(eventName, callback);\n            }).bind(this);\n        },\n        removeEventListener: function removeEventListener(eventName, callback) {\n            if (!callback) {\n                this._cbs[eventName] = null;\n            } else if (this._cbs[eventName]) {\n                var i = 0;\n                var len = this._cbs[eventName].length;\n                while(i < len){\n                    if (this._cbs[eventName][i] === callback) {\n                        this._cbs[eventName].splice(i, 1);\n                        i -= 1;\n                        len -= 1;\n                    }\n                    i += 1;\n                }\n                if (!this._cbs[eventName].length) {\n                    this._cbs[eventName] = null;\n                }\n            }\n        }\n    };\n    var markerParser = function() {\n        function parsePayloadLines(payload) {\n            var lines = payload.split(\"\\r\\n\");\n            var keys = {};\n            var line;\n            var keysCount = 0;\n            for(var i = 0; i < lines.length; i += 1){\n                line = lines[i].split(\":\");\n                if (line.length === 2) {\n                    keys[line[0]] = line[1].trim();\n                    keysCount += 1;\n                }\n            }\n            if (keysCount === 0) {\n                throw new Error();\n            }\n            return keys;\n        }\n        return function(_markers) {\n            var markers = [];\n            for(var i = 0; i < _markers.length; i += 1){\n                var _marker = _markers[i];\n                var markerData = {\n                    time: _marker.tm,\n                    duration: _marker.dr\n                };\n                try {\n                    markerData.payload = JSON.parse(_markers[i].cm);\n                } catch (_) {\n                    try {\n                        markerData.payload = parsePayloadLines(_markers[i].cm);\n                    } catch (__) {\n                        markerData.payload = {\n                            name: _markers[i].cm\n                        };\n                    }\n                }\n                markers.push(markerData);\n            }\n            return markers;\n        };\n    }();\n    var ProjectInterface = function() {\n        function registerComposition(comp) {\n            this.compositions.push(comp);\n        }\n        return function() {\n            function _thisProjectFunction(name) {\n                var i = 0;\n                var len = this.compositions.length;\n                while(i < len){\n                    if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n                        if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n                            this.compositions[i].prepareFrame(this.currentFrame);\n                        }\n                        return this.compositions[i].compInterface;\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            _thisProjectFunction.compositions = [];\n            _thisProjectFunction.currentFrame = 0;\n            _thisProjectFunction.registerComposition = registerComposition;\n            return _thisProjectFunction;\n        };\n    }();\n    var renderers = {};\n    var registerRenderer = function registerRenderer(key, value) {\n        renderers[key] = value;\n    };\n    function getRenderer(key) {\n        return renderers[key];\n    }\n    function getRegisteredRenderer() {\n        // Returns canvas by default for compatibility\n        if (renderers.canvas) {\n            return \"canvas\";\n        } // Returns any renderer that is registered\n        for(var key in renderers){\n            if (renderers[key]) {\n                return key;\n            }\n        }\n        return \"\";\n    }\n    function _typeof$4(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$4 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$4 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$4(obj);\n    }\n    var AnimationItem = function AnimationItem() {\n        this._cbs = [];\n        this.name = \"\";\n        this.path = \"\";\n        this.isLoaded = false;\n        this.currentFrame = 0;\n        this.currentRawFrame = 0;\n        this.firstFrame = 0;\n        this.totalFrames = 0;\n        this.frameRate = 0;\n        this.frameMult = 0;\n        this.playSpeed = 1;\n        this.playDirection = 1;\n        this.playCount = 0;\n        this.animationData = {};\n        this.assets = [];\n        this.isPaused = true;\n        this.autoplay = false;\n        this.loop = true;\n        this.renderer = null;\n        this.animationID = createElementID();\n        this.assetsPath = \"\";\n        this.timeCompleted = 0;\n        this.segmentPos = 0;\n        this.isSubframeEnabled = getSubframeEnabled();\n        this.segments = [];\n        this._idle = true;\n        this._completedLoop = false;\n        this.projectInterface = ProjectInterface();\n        this.imagePreloader = new ImagePreloader();\n        this.audioController = audioControllerFactory();\n        this.markers = [];\n        this.configAnimation = this.configAnimation.bind(this);\n        this.onSetupError = this.onSetupError.bind(this);\n        this.onSegmentComplete = this.onSegmentComplete.bind(this);\n        this.drawnFrameEvent = new BMEnterFrameEvent(\"drawnFrame\", 0, 0, 0);\n        this.expressionsPlugin = getExpressionsPlugin();\n    };\n    extendPrototype([\n        BaseEvent\n    ], AnimationItem);\n    AnimationItem.prototype.setParams = function(params) {\n        if (params.wrapper || params.container) {\n            this.wrapper = params.wrapper || params.container;\n        }\n        var animType = \"svg\";\n        if (params.animType) {\n            animType = params.animType;\n        } else if (params.renderer) {\n            animType = params.renderer;\n        }\n        var RendererClass = getRenderer(animType);\n        this.renderer = new RendererClass(this, params.rendererSettings);\n        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);\n        this.renderer.setProjectInterface(this.projectInterface);\n        this.animType = animType;\n        if (params.loop === \"\" || params.loop === null || params.loop === undefined || params.loop === true) {\n            this.loop = true;\n        } else if (params.loop === false) {\n            this.loop = false;\n        } else {\n            this.loop = parseInt(params.loop, 10);\n        }\n        this.autoplay = \"autoplay\" in params ? params.autoplay : true;\n        this.name = params.name ? params.name : \"\";\n        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, \"autoloadSegments\") ? params.autoloadSegments : true;\n        this.assetsPath = params.assetsPath;\n        this.initialSegment = params.initialSegment;\n        if (params.audioFactory) {\n            this.audioController.setAudioFactory(params.audioFactory);\n        }\n        if (params.animationData) {\n            this.setupAnimation(params.animationData);\n        } else if (params.path) {\n            if (params.path.lastIndexOf(\"\\\\\") !== -1) {\n                this.path = params.path.substr(0, params.path.lastIndexOf(\"\\\\\") + 1);\n            } else {\n                this.path = params.path.substr(0, params.path.lastIndexOf(\"/\") + 1);\n            }\n            this.fileName = params.path.substr(params.path.lastIndexOf(\"/\") + 1);\n            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(\".json\"));\n            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);\n        }\n    };\n    AnimationItem.prototype.onSetupError = function() {\n        this.trigger(\"data_failed\");\n    };\n    AnimationItem.prototype.setupAnimation = function(data) {\n        dataManager.completeAnimation(data, this.configAnimation);\n    };\n    AnimationItem.prototype.setData = function(wrapper, animationData) {\n        if (animationData) {\n            if (_typeof$4(animationData) !== \"object\") {\n                animationData = JSON.parse(animationData);\n            }\n        }\n        var params = {\n            wrapper: wrapper,\n            animationData: animationData\n        };\n        var wrapperAttributes = wrapper.attributes;\n        params.path = wrapperAttributes.getNamedItem(\"data-animation-path\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-animation-path\").value : wrapperAttributes.getNamedItem(\"data-bm-path\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-path\").value : wrapperAttributes.getNamedItem(\"bm-path\") ? wrapperAttributes.getNamedItem(\"bm-path\").value : \"\";\n        params.animType = wrapperAttributes.getNamedItem(\"data-anim-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-type\").value : wrapperAttributes.getNamedItem(\"data-bm-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-type\").value : wrapperAttributes.getNamedItem(\"bm-type\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"bm-type\").value : wrapperAttributes.getNamedItem(\"data-bm-renderer\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-renderer\").value : wrapperAttributes.getNamedItem(\"bm-renderer\") ? wrapperAttributes.getNamedItem(\"bm-renderer\").value : getRegisteredRenderer() || \"canvas\";\n        var loop = wrapperAttributes.getNamedItem(\"data-anim-loop\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-loop\").value : wrapperAttributes.getNamedItem(\"data-bm-loop\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-loop\").value : wrapperAttributes.getNamedItem(\"bm-loop\") ? wrapperAttributes.getNamedItem(\"bm-loop\").value : \"\";\n        if (loop === \"false\") {\n            params.loop = false;\n        } else if (loop === \"true\") {\n            params.loop = true;\n        } else if (loop !== \"\") {\n            params.loop = parseInt(loop, 10);\n        }\n        var autoplay = wrapperAttributes.getNamedItem(\"data-anim-autoplay\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-autoplay\").value : wrapperAttributes.getNamedItem(\"data-bm-autoplay\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-autoplay\").value : wrapperAttributes.getNamedItem(\"bm-autoplay\") ? wrapperAttributes.getNamedItem(\"bm-autoplay\").value : true;\n        params.autoplay = autoplay !== \"false\";\n        params.name = wrapperAttributes.getNamedItem(\"data-name\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-name\").value : wrapperAttributes.getNamedItem(\"data-bm-name\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-name\").value : wrapperAttributes.getNamedItem(\"bm-name\") ? wrapperAttributes.getNamedItem(\"bm-name\").value : \"\";\n        var prerender = wrapperAttributes.getNamedItem(\"data-anim-prerender\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-anim-prerender\").value : wrapperAttributes.getNamedItem(\"data-bm-prerender\") // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem(\"data-bm-prerender\").value : wrapperAttributes.getNamedItem(\"bm-prerender\") ? wrapperAttributes.getNamedItem(\"bm-prerender\").value : \"\";\n        if (prerender === \"false\") {\n            params.prerender = false;\n        }\n        if (!params.path) {\n            this.trigger(\"destroy\");\n        } else {\n            this.setParams(params);\n        }\n    };\n    AnimationItem.prototype.includeLayers = function(data) {\n        if (data.op > this.animationData.op) {\n            this.animationData.op = data.op;\n            this.totalFrames = Math.floor(data.op - this.animationData.ip);\n        }\n        var layers = this.animationData.layers;\n        var i;\n        var len = layers.length;\n        var newLayers = data.layers;\n        var j;\n        var jLen = newLayers.length;\n        for(j = 0; j < jLen; j += 1){\n            i = 0;\n            while(i < len){\n                if (layers[i].id === newLayers[j].id) {\n                    layers[i] = newLayers[j];\n                    break;\n                }\n                i += 1;\n            }\n        }\n        if (data.chars || data.fonts) {\n            this.renderer.globalData.fontManager.addChars(data.chars);\n            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\n        }\n        if (data.assets) {\n            len = data.assets.length;\n            for(i = 0; i < len; i += 1){\n                this.animationData.assets.push(data.assets[i]);\n            }\n        }\n        this.animationData.__complete = false;\n        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);\n    };\n    AnimationItem.prototype.onSegmentComplete = function(data) {\n        this.animationData = data;\n        var expressionsPlugin = getExpressionsPlugin();\n        if (expressionsPlugin) {\n            expressionsPlugin.initExpressions(this);\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.loadNextSegment = function() {\n        var segments = this.animationData.segments;\n        if (!segments || segments.length === 0 || !this.autoloadSegments) {\n            this.trigger(\"data_ready\");\n            this.timeCompleted = this.totalFrames;\n            return;\n        }\n        var segment = segments.shift();\n        this.timeCompleted = segment.time * this.frameRate;\n        var segmentPath = this.path + this.fileName + \"_\" + this.segmentPos + \".json\";\n        this.segmentPos += 1;\n        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {\n            this.trigger(\"data_failed\");\n        }).bind(this));\n    };\n    AnimationItem.prototype.loadSegments = function() {\n        var segments = this.animationData.segments;\n        if (!segments) {\n            this.timeCompleted = this.totalFrames;\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.imagesLoaded = function() {\n        this.trigger(\"loaded_images\");\n        this.checkLoaded();\n    };\n    AnimationItem.prototype.preloadImages = function() {\n        this.imagePreloader.setAssetsPath(this.assetsPath);\n        this.imagePreloader.setPath(this.path);\n        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\n    };\n    AnimationItem.prototype.configAnimation = function(animData) {\n        if (!this.renderer) {\n            return;\n        }\n        try {\n            this.animationData = animData;\n            if (this.initialSegment) {\n                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);\n                this.firstFrame = Math.round(this.initialSegment[0]);\n            } else {\n                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\n                this.firstFrame = Math.round(this.animationData.ip);\n            }\n            this.renderer.configAnimation(animData);\n            if (!animData.assets) {\n                animData.assets = [];\n            }\n            this.assets = this.animationData.assets;\n            this.frameRate = this.animationData.fr;\n            this.frameMult = this.animationData.fr / 1000;\n            this.renderer.searchExtraCompositions(animData.assets);\n            this.markers = markerParser(animData.markers || []);\n            this.trigger(\"config_ready\");\n            this.preloadImages();\n            this.loadSegments();\n            this.updaFrameModifier();\n            this.waitForFontsLoaded();\n            if (this.isPaused) {\n                this.audioController.pause();\n            }\n        } catch (error) {\n            this.triggerConfigError(error);\n        }\n    };\n    AnimationItem.prototype.waitForFontsLoaded = function() {\n        if (!this.renderer) {\n            return;\n        }\n        if (this.renderer.globalData.fontManager.isLoaded) {\n            this.checkLoaded();\n        } else {\n            setTimeout(this.waitForFontsLoaded.bind(this), 20);\n        }\n    };\n    AnimationItem.prototype.checkLoaded = function() {\n        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== \"canvas\") && this.imagePreloader.loadedFootages()) {\n            this.isLoaded = true;\n            var expressionsPlugin = getExpressionsPlugin();\n            if (expressionsPlugin) {\n                expressionsPlugin.initExpressions(this);\n            }\n            this.renderer.initItems();\n            setTimeout((function() {\n                this.trigger(\"DOMLoaded\");\n            }).bind(this), 0);\n            this.gotoFrame();\n            if (this.autoplay) {\n                this.play();\n            }\n        }\n    };\n    AnimationItem.prototype.resize = function(width, height) {\n        // Adding this validation for backwards compatibility in case an event object was being passed down\n        var _width = typeof width === \"number\" ? width : undefined;\n        var _height = typeof height === \"number\" ? height : undefined;\n        this.renderer.updateContainerSize(_width, _height);\n    };\n    AnimationItem.prototype.setSubframe = function(flag) {\n        this.isSubframeEnabled = !!flag;\n    };\n    AnimationItem.prototype.gotoFrame = function() {\n        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise\n        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n            this.currentFrame = this.timeCompleted;\n        }\n        this.trigger(\"enterFrame\");\n        this.renderFrame();\n        this.trigger(\"drawnFrame\");\n    };\n    AnimationItem.prototype.renderFrame = function() {\n        if (this.isLoaded === false || !this.renderer) {\n            return;\n        }\n        try {\n            if (this.expressionsPlugin) {\n                this.expressionsPlugin.resetFrame();\n            }\n            this.renderer.renderFrame(this.currentFrame + this.firstFrame);\n        } catch (error) {\n            this.triggerRenderFrameError(error);\n        }\n    };\n    AnimationItem.prototype.play = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.isPaused = false;\n            this.trigger(\"_play\");\n            this.audioController.resume();\n            if (this._idle) {\n                this._idle = false;\n                this.trigger(\"_active\");\n            }\n        }\n    };\n    AnimationItem.prototype.pause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === false) {\n            this.isPaused = true;\n            this.trigger(\"_pause\");\n            this._idle = true;\n            this.trigger(\"_idle\");\n            this.audioController.pause();\n        }\n    };\n    AnimationItem.prototype.togglePause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    };\n    AnimationItem.prototype.stop = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.pause();\n        this.playCount = 0;\n        this._completedLoop = false;\n        this.setCurrentRawFrameValue(0);\n    };\n    AnimationItem.prototype.getMarkerData = function(markerName) {\n        var marker;\n        for(var i = 0; i < this.markers.length; i += 1){\n            marker = this.markers[i];\n            if (marker.payload && marker.payload.name === markerName) {\n                return marker;\n            }\n        }\n        return null;\n    };\n    AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                this.goToAndStop(marker.time, true);\n            }\n        } else if (isFrame) {\n            this.setCurrentRawFrameValue(value);\n        } else {\n            this.setCurrentRawFrameValue(value * this.frameModifier);\n        }\n        this.pause();\n    };\n    AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                if (!marker.duration) {\n                    this.goToAndStop(marker.time, true);\n                } else {\n                    this.playSegments([\n                        marker.time,\n                        marker.time + marker.duration\n                    ], true);\n                }\n            }\n        } else {\n            this.goToAndStop(numValue, isFrame, name);\n        }\n        this.play();\n    };\n    AnimationItem.prototype.advanceTime = function(value) {\n        if (this.isPaused === true || this.isLoaded === false) {\n            return;\n        }\n        var nextValue = this.currentRawFrame + value * this.frameModifier;\n        var _isComplete = false; // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n            if (!this.loop || this.playCount === this.loop) {\n                if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n                    _isComplete = true;\n                    nextValue = this.totalFrames - 1;\n                }\n            } else if (nextValue >= this.totalFrames) {\n                this.playCount += 1;\n                if (!this.checkSegments(nextValue % this.totalFrames)) {\n                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);\n                    this._completedLoop = true;\n                    this.trigger(\"loopComplete\");\n                }\n            } else {\n                this.setCurrentRawFrameValue(nextValue);\n            }\n        } else if (nextValue < 0) {\n            if (!this.checkSegments(nextValue % this.totalFrames)) {\n                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n                    // eslint-disable-line no-plusplus\n                    this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);\n                    if (!this._completedLoop) {\n                        this._completedLoop = true;\n                    } else {\n                        this.trigger(\"loopComplete\");\n                    }\n                } else {\n                    _isComplete = true;\n                    nextValue = 0;\n                }\n            }\n        } else {\n            this.setCurrentRawFrameValue(nextValue);\n        }\n        if (_isComplete) {\n            this.setCurrentRawFrameValue(nextValue);\n            this.pause();\n            this.trigger(\"complete\");\n        }\n    };\n    AnimationItem.prototype.adjustSegment = function(arr, offset) {\n        this.playCount = 0;\n        if (arr[1] < arr[0]) {\n            if (this.frameModifier > 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(-1);\n                }\n            }\n            this.totalFrames = arr[0] - arr[1];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[1];\n            this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\n        } else if (arr[1] > arr[0]) {\n            if (this.frameModifier < 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(1);\n                }\n            }\n            this.totalFrames = arr[1] - arr[0];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[0];\n            this.setCurrentRawFrameValue(0.001 + offset);\n        }\n        this.trigger(\"segmentStart\");\n    };\n    AnimationItem.prototype.setSegment = function(init, end) {\n        var pendingFrame = -1;\n        if (this.isPaused) {\n            if (this.currentRawFrame + this.firstFrame < init) {\n                pendingFrame = init;\n            } else if (this.currentRawFrame + this.firstFrame > end) {\n                pendingFrame = end - init;\n            }\n        }\n        this.firstFrame = init;\n        this.totalFrames = end - init;\n        this.timeCompleted = this.totalFrames;\n        if (pendingFrame !== -1) {\n            this.goToAndStop(pendingFrame, true);\n        }\n    };\n    AnimationItem.prototype.playSegments = function(arr, forceFlag) {\n        if (forceFlag) {\n            this.segments.length = 0;\n        }\n        if (_typeof$4(arr[0]) === \"object\") {\n            var i;\n            var len = arr.length;\n            for(i = 0; i < len; i += 1){\n                this.segments.push(arr[i]);\n            }\n        } else {\n            this.segments.push(arr);\n        }\n        if (this.segments.length && forceFlag) {\n            this.adjustSegment(this.segments.shift(), 0);\n        }\n        if (this.isPaused) {\n            this.play();\n        }\n    };\n    AnimationItem.prototype.resetSegments = function(forceFlag) {\n        this.segments.length = 0;\n        this.segments.push([\n            this.animationData.ip,\n            this.animationData.op\n        ]);\n        if (forceFlag) {\n            this.checkSegments(0);\n        }\n    };\n    AnimationItem.prototype.checkSegments = function(offset) {\n        if (this.segments.length) {\n            this.adjustSegment(this.segments.shift(), offset);\n            return true;\n        }\n        return false;\n    };\n    AnimationItem.prototype.destroy = function(name) {\n        if (name && this.name !== name || !this.renderer) {\n            return;\n        }\n        this.renderer.destroy();\n        this.imagePreloader.destroy();\n        this.trigger(\"destroy\");\n        this._cbs = null;\n        this.onEnterFrame = null;\n        this.onLoopComplete = null;\n        this.onComplete = null;\n        this.onSegmentStart = null;\n        this.onDestroy = null;\n        this.renderer = null;\n        this.expressionsPlugin = null;\n        this.imagePreloader = null;\n        this.projectInterface = null;\n    };\n    AnimationItem.prototype.setCurrentRawFrameValue = function(value) {\n        this.currentRawFrame = value;\n        this.gotoFrame();\n    };\n    AnimationItem.prototype.setSpeed = function(val) {\n        this.playSpeed = val;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setDirection = function(val) {\n        this.playDirection = val < 0 ? -1 : 1;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setLoop = function(isLooping) {\n        this.loop = isLooping;\n    };\n    AnimationItem.prototype.setVolume = function(val, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.setVolume(val);\n    };\n    AnimationItem.prototype.getVolume = function() {\n        return this.audioController.getVolume();\n    };\n    AnimationItem.prototype.mute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.mute();\n    };\n    AnimationItem.prototype.unmute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.unmute();\n    };\n    AnimationItem.prototype.updaFrameModifier = function() {\n        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\n        this.audioController.setRate(this.playSpeed * this.playDirection);\n    };\n    AnimationItem.prototype.getPath = function() {\n        return this.path;\n    };\n    AnimationItem.prototype.getAssetsPath = function(assetData) {\n        var path = \"\";\n        if (assetData.e) {\n            path = assetData.p;\n        } else if (this.assetsPath) {\n            var imagePath = assetData.p;\n            if (imagePath.indexOf(\"images/\") !== -1) {\n                imagePath = imagePath.split(\"/\")[1];\n            }\n            path = this.assetsPath + imagePath;\n        } else {\n            path = this.path;\n            path += assetData.u ? assetData.u : \"\";\n            path += assetData.p;\n        }\n        return path;\n    };\n    AnimationItem.prototype.getAssetData = function(id) {\n        var i = 0;\n        var len = this.assets.length;\n        while(i < len){\n            if (id === this.assets[i].id) {\n                return this.assets[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    AnimationItem.prototype.hide = function() {\n        this.renderer.hide();\n    };\n    AnimationItem.prototype.show = function() {\n        this.renderer.show();\n    };\n    AnimationItem.prototype.getDuration = function(isFrame) {\n        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\n    };\n    AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {\n        try {\n            var element = this.renderer.getElementByPath(path);\n            element.updateDocumentData(documentData, index);\n        } catch (error) {}\n    };\n    AnimationItem.prototype.trigger = function(name) {\n        if (this._cbs && this._cbs[name]) {\n            switch(name){\n                case \"enterFrame\":\n                    this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));\n                    break;\n                case \"drawnFrame\":\n                    this.drawnFrameEvent.currentTime = this.currentFrame;\n                    this.drawnFrameEvent.totalTime = this.totalFrames;\n                    this.drawnFrameEvent.direction = this.frameModifier;\n                    this.triggerEvent(name, this.drawnFrameEvent);\n                    break;\n                case \"loopComplete\":\n                    this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n                    break;\n                case \"complete\":\n                    this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));\n                    break;\n                case \"segmentStart\":\n                    this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n                    break;\n                case \"destroy\":\n                    this.triggerEvent(name, new BMDestroyEvent(name, this));\n                    break;\n                default:\n                    this.triggerEvent(name);\n            }\n        }\n        if (name === \"enterFrame\" && this.onEnterFrame) {\n            this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));\n        }\n        if (name === \"loopComplete\" && this.onLoopComplete) {\n            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n        }\n        if (name === \"complete\" && this.onComplete) {\n            this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));\n        }\n        if (name === \"segmentStart\" && this.onSegmentStart) {\n            this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n        }\n        if (name === \"destroy\" && this.onDestroy) {\n            this.onDestroy.call(this, new BMDestroyEvent(name, this));\n        }\n    };\n    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {\n        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent(\"error\", error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    AnimationItem.prototype.triggerConfigError = function(nativeError) {\n        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent(\"error\", error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    var animationManager = function() {\n        var moduleOb = {};\n        var registeredAnimations = [];\n        var initTime = 0;\n        var len = 0;\n        var playingAnimationsNum = 0;\n        var _stopped = true;\n        var _isFrozen = false;\n        function removeElement(ev) {\n            var i = 0;\n            var animItem = ev.target;\n            while(i < len){\n                if (registeredAnimations[i].animation === animItem) {\n                    registeredAnimations.splice(i, 1);\n                    i -= 1;\n                    len -= 1;\n                    if (!animItem.isPaused) {\n                        subtractPlayingCount();\n                    }\n                }\n                i += 1;\n            }\n        }\n        function registerAnimation(element, animationData) {\n            if (!element) {\n                return null;\n            }\n            var i = 0;\n            while(i < len){\n                if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n                    return registeredAnimations[i].animation;\n                }\n                i += 1;\n            }\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, element);\n            animItem.setData(element, animationData);\n            return animItem;\n        }\n        function getRegisteredAnimations() {\n            var i;\n            var lenAnims = registeredAnimations.length;\n            var animations = [];\n            for(i = 0; i < lenAnims; i += 1){\n                animations.push(registeredAnimations[i].animation);\n            }\n            return animations;\n        }\n        function addPlayingCount() {\n            playingAnimationsNum += 1;\n            activate();\n        }\n        function subtractPlayingCount() {\n            playingAnimationsNum -= 1;\n        }\n        function setupAnimation(animItem, element) {\n            animItem.addEventListener(\"destroy\", removeElement);\n            animItem.addEventListener(\"_active\", addPlayingCount);\n            animItem.addEventListener(\"_idle\", subtractPlayingCount);\n            registeredAnimations.push({\n                elem: element,\n                animation: animItem\n            });\n            len += 1;\n        }\n        function loadAnimation(params) {\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, null);\n            animItem.setParams(params);\n            return animItem;\n        }\n        function setSpeed(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setSpeed(val, animation);\n            }\n        }\n        function setDirection(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setDirection(val, animation);\n            }\n        }\n        function play(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.play(animation);\n            }\n        }\n        function resume(nowTime) {\n            var elapsedTime = nowTime - initTime;\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.advanceTime(elapsedTime);\n            }\n            initTime = nowTime;\n            if (playingAnimationsNum && !_isFrozen) {\n                window.requestAnimationFrame(resume);\n            } else {\n                _stopped = true;\n            }\n        }\n        function first(nowTime) {\n            initTime = nowTime;\n            window.requestAnimationFrame(resume);\n        }\n        function pause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.pause(animation);\n            }\n        }\n        function goToAndStop(value, isFrame, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);\n            }\n        }\n        function stop(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.stop(animation);\n            }\n        }\n        function togglePause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.togglePause(animation);\n            }\n        }\n        function destroy(animation) {\n            var i;\n            for(i = len - 1; i >= 0; i -= 1){\n                registeredAnimations[i].animation.destroy(animation);\n            }\n        }\n        function searchAnimations(animationData, standalone, renderer) {\n            var animElements = [].concat([].slice.call(document.getElementsByClassName(\"lottie\")), [].slice.call(document.getElementsByClassName(\"bodymovin\")));\n            var i;\n            var lenAnims = animElements.length;\n            for(i = 0; i < lenAnims; i += 1){\n                if (renderer) {\n                    animElements[i].setAttribute(\"data-bm-type\", renderer);\n                }\n                registerAnimation(animElements[i], animationData);\n            }\n            if (standalone && lenAnims === 0) {\n                if (!renderer) {\n                    renderer = \"svg\";\n                }\n                var body = document.getElementsByTagName(\"body\")[0];\n                body.innerText = \"\";\n                var div = createTag(\"div\");\n                div.style.width = \"100%\";\n                div.style.height = \"100%\";\n                div.setAttribute(\"data-bm-type\", renderer);\n                body.appendChild(div);\n                registerAnimation(div, animationData);\n            }\n        }\n        function resize() {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.resize();\n            }\n        }\n        function activate() {\n            if (!_isFrozen && playingAnimationsNum) {\n                if (_stopped) {\n                    window.requestAnimationFrame(first);\n                    _stopped = false;\n                }\n            }\n        }\n        function freeze() {\n            _isFrozen = true;\n        }\n        function unfreeze() {\n            _isFrozen = false;\n            activate();\n        }\n        function setVolume(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setVolume(val, animation);\n            }\n        }\n        function mute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.mute(animation);\n            }\n        }\n        function unmute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.unmute(animation);\n            }\n        }\n        moduleOb.registerAnimation = registerAnimation;\n        moduleOb.loadAnimation = loadAnimation;\n        moduleOb.setSpeed = setSpeed;\n        moduleOb.setDirection = setDirection;\n        moduleOb.play = play;\n        moduleOb.pause = pause;\n        moduleOb.stop = stop;\n        moduleOb.togglePause = togglePause;\n        moduleOb.searchAnimations = searchAnimations;\n        moduleOb.resize = resize; // moduleOb.start = start;\n        moduleOb.goToAndStop = goToAndStop;\n        moduleOb.destroy = destroy;\n        moduleOb.freeze = freeze;\n        moduleOb.unfreeze = unfreeze;\n        moduleOb.setVolume = setVolume;\n        moduleOb.mute = mute;\n        moduleOb.unmute = unmute;\n        moduleOb.getRegisteredAnimations = getRegisteredAnimations;\n        return moduleOb;\n    }();\n    /* eslint-disable */ var BezierFactory = function() {\n        /**\r\n       * BezierEasing - use bezier curve for transition easing function\r\n       * by Gatan Renaudeau 2014 - 2015  MIT License\r\n       *\r\n       * Credits: is based on Firefox's nsSMILKeySpline.cpp\r\n       * Usage:\r\n       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\r\n       * spline.get(x) => returns the easing value | x must be in [0, 1] range\r\n       *\r\n       */ var ob = {};\n        ob.getBezierEasing = getBezierEasing;\n        var beziers = {};\n        function getBezierEasing(a, b, c, d, nm) {\n            var str = nm || (\"bez_\" + a + \"_\" + b + \"_\" + c + \"_\" + d).replace(/\\./g, \"p\");\n            if (beziers[str]) {\n                return beziers[str];\n            }\n            var bezEasing = new BezierEasing([\n                a,\n                b,\n                c,\n                d\n            ]);\n            beziers[str] = bezEasing;\n            return bezEasing;\n        } // These values are established by empiricism with tests (tradeoff: performance VS precision)\n        var NEWTON_ITERATIONS = 4;\n        var NEWTON_MIN_SLOPE = 0.001;\n        var SUBDIVISION_PRECISION = 0.0000001;\n        var SUBDIVISION_MAX_ITERATIONS = 10;\n        var kSplineTableSize = 11;\n        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n        var float32ArraySupported = typeof Float32Array === \"function\";\n        function A(aA1, aA2) {\n            return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n        }\n        function B(aA1, aA2) {\n            return 3.0 * aA2 - 6.0 * aA1;\n        }\n        function C(aA1) {\n            return 3.0 * aA1;\n        } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n        function calcBezier(aT, aA1, aA2) {\n            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n        } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n        function getSlope(aT, aA1, aA2) {\n            return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n        }\n        function binarySubdivide(aX, aA, aB, mX1, mX2) {\n            var currentX, currentT, i = 0;\n            do {\n                currentT = aA + (aB - aA) / 2.0;\n                currentX = calcBezier(currentT, mX1, mX2) - aX;\n                if (currentX > 0.0) {\n                    aB = currentT;\n                } else {\n                    aA = currentT;\n                }\n            }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n            return currentT;\n        }\n        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n            for(var i = 0; i < NEWTON_ITERATIONS; ++i){\n                var currentSlope = getSlope(aGuessT, mX1, mX2);\n                if (currentSlope === 0.0) return aGuessT;\n                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n                aGuessT -= currentX / currentSlope;\n            }\n            return aGuessT;\n        }\n        /**\r\n       * points is an array of [ mX1, mY1, mX2, mY2 ]\r\n       */ function BezierEasing(points) {\n            this._p = points;\n            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n            this._precomputed = false;\n            this.get = this.get.bind(this);\n        }\n        BezierEasing.prototype = {\n            get: function get(x) {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                if (!this._precomputed) this._precompute();\n                if (mX1 === mY1 && mX2 === mY2) return x; // linear\n                // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n                if (x === 0) return 0;\n                if (x === 1) return 1;\n                return calcBezier(this._getTForX(x), mY1, mY2);\n            },\n            // Private part\n            _precompute: function _precompute() {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                this._precomputed = true;\n                if (mX1 !== mY1 || mX2 !== mY2) {\n                    this._calcSampleValues();\n                }\n            },\n            _calcSampleValues: function _calcSampleValues() {\n                var mX1 = this._p[0], mX2 = this._p[2];\n                for(var i = 0; i < kSplineTableSize; ++i){\n                    this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n                }\n            },\n            /**\r\n           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\r\n           */ _getTForX: function _getTForX(aX) {\n                var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;\n                var intervalStart = 0.0;\n                var currentSample = 1;\n                var lastSample = kSplineTableSize - 1;\n                for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n                    intervalStart += kSampleStepSize;\n                }\n                --currentSample; // Interpolate to provide an initial guess for t\n                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n                var guessForT = intervalStart + dist * kSampleStepSize;\n                var initialSlope = getSlope(guessForT, mX1, mX2);\n                if (initialSlope >= NEWTON_MIN_SLOPE) {\n                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n                }\n                if (initialSlope === 0.0) {\n                    return guessForT;\n                }\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        };\n        return ob;\n    }();\n    var pooling = function() {\n        function _double(arr) {\n            return arr.concat(createSizedArray(arr.length));\n        }\n        return {\n            \"double\": _double\n        };\n    }();\n    var poolFactory = function() {\n        return function(initialLength, _create, _release) {\n            var _length = 0;\n            var _maxLength = initialLength;\n            var pool = createSizedArray(_maxLength);\n            var ob = {\n                newElement: newElement,\n                release: release\n            };\n            function newElement() {\n                var element;\n                if (_length) {\n                    _length -= 1;\n                    element = pool[_length];\n                } else {\n                    element = _create();\n                }\n                return element;\n            }\n            function release(element) {\n                if (_length === _maxLength) {\n                    pool = pooling[\"double\"](pool);\n                    _maxLength *= 2;\n                }\n                if (_release) {\n                    _release(element);\n                }\n                pool[_length] = element;\n                _length += 1;\n            }\n            return ob;\n        };\n    }();\n    var bezierLengthPool = function() {\n        function create() {\n            return {\n                addedLength: 0,\n                percents: createTypedArray(\"float32\", getDefaultCurveSegments()),\n                lengths: createTypedArray(\"float32\", getDefaultCurveSegments())\n            };\n        }\n        return poolFactory(8, create);\n    }();\n    var segmentsLengthPool = function() {\n        function create() {\n            return {\n                lengths: [],\n                totalLength: 0\n            };\n        }\n        function release(element) {\n            var i;\n            var len = element.lengths.length;\n            for(i = 0; i < len; i += 1){\n                bezierLengthPool.release(element.lengths[i]);\n            }\n            element.lengths.length = 0;\n        }\n        return poolFactory(8, create, release);\n    }();\n    function bezFunction() {\n        var math = Math;\n        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;\n            return det1 > -0.001 && det1 < 0.001;\n        }\n        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n            if (z1 === 0 && z2 === 0 && z3 === 0) {\n                return pointOnLine2D(x1, y1, x2, y2, x3, y3);\n            }\n            var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));\n            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));\n            var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));\n            var diffDist;\n            if (dist1 > dist2) {\n                if (dist1 > dist3) {\n                    diffDist = dist1 - dist2 - dist3;\n                } else {\n                    diffDist = dist3 - dist2 - dist1;\n                }\n            } else if (dist3 > dist2) {\n                diffDist = dist3 - dist2 - dist1;\n            } else {\n                diffDist = dist2 - dist1 - dist3;\n            }\n            return diffDist > -0.0001 && diffDist < 0.0001;\n        }\n        var getBezierLength = function() {\n            return function(pt1, pt2, pt3, pt4) {\n                var curveSegments = getDefaultCurveSegments();\n                var k;\n                var i;\n                var len;\n                var ptCoord;\n                var perc;\n                var addedLength = 0;\n                var ptDistance;\n                var point = [];\n                var lastPoint = [];\n                var lengthData = bezierLengthPool.newElement();\n                len = pt3.length;\n                for(k = 0; k < curveSegments; k += 1){\n                    perc = k / (curveSegments - 1);\n                    ptDistance = 0;\n                    for(i = 0; i < len; i += 1){\n                        ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];\n                        point[i] = ptCoord;\n                        if (lastPoint[i] !== null) {\n                            ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                        }\n                        lastPoint[i] = point[i];\n                    }\n                    if (ptDistance) {\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                    }\n                    lengthData.percents[k] = perc;\n                    lengthData.lengths[k] = addedLength;\n                }\n                lengthData.addedLength = addedLength;\n                return lengthData;\n            };\n        }();\n        function getSegmentsLength(shapeData) {\n            var segmentsLength = segmentsLengthPool.newElement();\n            var closed = shapeData.c;\n            var pathV = shapeData.v;\n            var pathO = shapeData.o;\n            var pathI = shapeData.i;\n            var i;\n            var len = shapeData._length;\n            var lengths = segmentsLength.lengths;\n            var totalLength = 0;\n            for(i = 0; i < len - 1; i += 1){\n                lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);\n                totalLength += lengths[i].addedLength;\n            }\n            if (closed && len) {\n                lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);\n                totalLength += lengths[i].addedLength;\n            }\n            segmentsLength.totalLength = totalLength;\n            return segmentsLength;\n        }\n        function BezierData(length) {\n            this.segmentLength = 0;\n            this.points = new Array(length);\n        }\n        function PointData(partial, point) {\n            this.partialLength = partial;\n            this.point = point;\n        }\n        var buildBezierData = function() {\n            var storedData = {};\n            return function(pt1, pt2, pt3, pt4) {\n                var bezierName = (pt1[0] + \"_\" + pt1[1] + \"_\" + pt2[0] + \"_\" + pt2[1] + \"_\" + pt3[0] + \"_\" + pt3[1] + \"_\" + pt4[0] + \"_\" + pt4[1]).replace(/\\./g, \"p\");\n                if (!storedData[bezierName]) {\n                    var curveSegments = getDefaultCurveSegments();\n                    var k;\n                    var i;\n                    var len;\n                    var ptCoord;\n                    var perc;\n                    var addedLength = 0;\n                    var ptDistance;\n                    var point;\n                    var lastPoint = null;\n                    if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {\n                        curveSegments = 2;\n                    }\n                    var bezierData = new BezierData(curveSegments);\n                    len = pt3.length;\n                    for(k = 0; k < curveSegments; k += 1){\n                        point = createSizedArray(len);\n                        perc = k / (curveSegments - 1);\n                        ptDistance = 0;\n                        for(i = 0; i < len; i += 1){\n                            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];\n                            point[i] = ptCoord;\n                            if (lastPoint !== null) {\n                                ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                            }\n                        }\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                        bezierData.points[k] = new PointData(ptDistance, point);\n                        lastPoint = point;\n                    }\n                    bezierData.segmentLength = addedLength;\n                    storedData[bezierName] = bezierData;\n                }\n                return storedData[bezierName];\n            };\n        }();\n        function getDistancePerc(perc, bezierData) {\n            var percents = bezierData.percents;\n            var lengths = bezierData.lengths;\n            var len = percents.length;\n            var initPos = bmFloor((len - 1) * perc);\n            var lengthPos = perc * bezierData.addedLength;\n            var lPerc = 0;\n            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n                return percents[initPos];\n            }\n            var dir = lengths[initPos] > lengthPos ? -1 : 1;\n            var flag = true;\n            while(flag){\n                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);\n                    flag = false;\n                } else {\n                    initPos += dir;\n                }\n                if (initPos < 0 || initPos >= len - 1) {\n                    // FIX for TypedArrays that don't store floating point values with enough accuracy\n                    if (initPos === len - 1) {\n                        return percents[initPos];\n                    }\n                    flag = false;\n                }\n            }\n            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;\n        }\n        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n            var t1 = getDistancePerc(percent, bezierData);\n            var u1 = 1 - t1;\n            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;\n            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;\n            return [\n                ptX,\n                ptY\n            ];\n        }\n        var bezierSegmentPoints = createTypedArray(\"float32\", 8);\n        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n            if (startPerc < 0) {\n                startPerc = 0;\n            } else if (startPerc > 1) {\n                startPerc = 1;\n            }\n            var t0 = getDistancePerc(startPerc, bezierData);\n            endPerc = endPerc > 1 ? 1 : endPerc;\n            var t1 = getDistancePerc(endPerc, bezierData);\n            var i;\n            var len = pt1.length;\n            var u0 = 1 - t0;\n            var u1 = 1 - t1;\n            var u0u0u0 = u0 * u0 * u0;\n            var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0t0 = t0 * t0 * t0; //\n            var u0u0u1 = u0 * u0 * u1;\n            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0t1 = t0 * t0 * t1; //\n            var u0u1u1 = u0 * u1 * u1;\n            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1t1 = t0 * t1 * t1; //\n            var u1u1u1 = u1 * u1 * u1;\n            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1t1 = t1 * t1 * t1;\n            for(i = 0; i < len; i += 1){\n                bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n            }\n            return bezierSegmentPoints;\n        }\n        return {\n            getSegmentsLength: getSegmentsLength,\n            getNewSegment: getNewSegment,\n            getPointInSegment: getPointInSegment,\n            buildBezierData: buildBezierData,\n            pointOnLine2D: pointOnLine2D,\n            pointOnLine3D: pointOnLine3D\n        };\n    }\n    var bez = bezFunction();\n    var initFrame = initialDefaultFrame;\n    var mathAbs = Math.abs;\n    function interpolateValue(frameNum, caching) {\n        var offsetTime = this.offsetTime;\n        var newValue;\n        if (this.propType === \"multidimensional\") {\n            newValue = createTypedArray(\"float32\", this.pv.length);\n        }\n        var iterationIndex = caching.lastIndex;\n        var i = iterationIndex;\n        var len = this.keyframes.length - 1;\n        var flag = true;\n        var keyData;\n        var nextKeyData;\n        var keyframeMetadata;\n        while(flag){\n            keyData = this.keyframes[i];\n            nextKeyData = this.keyframes[i + 1];\n            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n                if (keyData.h) {\n                    keyData = nextKeyData;\n                }\n                iterationIndex = 0;\n                break;\n            }\n            if (nextKeyData.t - offsetTime > frameNum) {\n                iterationIndex = i;\n                break;\n            }\n            if (i < len - 1) {\n                i += 1;\n            } else {\n                iterationIndex = 0;\n                flag = false;\n            }\n        }\n        keyframeMetadata = this.keyframesMetadata[i] || {};\n        var k;\n        var kLen;\n        var perc;\n        var jLen;\n        var j;\n        var fnc;\n        var nextKeyTime = nextKeyData.t - offsetTime;\n        var keyTime = keyData.t - offsetTime;\n        var endValue;\n        if (keyData.to) {\n            if (!keyframeMetadata.bezierData) {\n                keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);\n            }\n            var bezierData = keyframeMetadata.bezierData;\n            if (frameNum >= nextKeyTime || frameNum < keyTime) {\n                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\n                kLen = bezierData.points[ind].point.length;\n                for(k = 0; k < kLen; k += 1){\n                    newValue[k] = bezierData.points[ind].point[k];\n                } // caching._lastKeyframeIndex = -1;\n            } else {\n                if (keyframeMetadata.__fnct) {\n                    fnc = keyframeMetadata.__fnct;\n                } else {\n                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\n                    keyframeMetadata.__fnct = fnc;\n                }\n                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                var distanceInLine = bezierData.segmentLength * perc;\n                var segmentPerc;\n                var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;\n                j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;\n                flag = true;\n                jLen = bezierData.points.length;\n                while(flag){\n                    addedLength += bezierData.points[j].partialLength;\n                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k];\n                        }\n                        break;\n                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\n                        segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\n                        }\n                        break;\n                    }\n                    if (j < jLen - 1) {\n                        j += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                caching._lastPoint = j;\n                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\n                caching._lastKeyframeIndex = i;\n            }\n        } else {\n            var outX;\n            var outY;\n            var inX;\n            var inY;\n            var keyValue;\n            len = keyData.s.length;\n            endValue = nextKeyData.s || keyData.e;\n            if (this.sh && keyData.h !== 1) {\n                if (frameNum >= nextKeyTime) {\n                    newValue[0] = endValue[0];\n                    newValue[1] = endValue[1];\n                    newValue[2] = endValue[2];\n                } else if (frameNum <= keyTime) {\n                    newValue[0] = keyData.s[0];\n                    newValue[1] = keyData.s[1];\n                    newValue[2] = keyData.s[2];\n                } else {\n                    var quatStart = createQuaternion(keyData.s);\n                    var quatEnd = createQuaternion(endValue);\n                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\n                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\n                }\n            } else {\n                for(i = 0; i < len; i += 1){\n                    if (keyData.h !== 1) {\n                        if (frameNum >= nextKeyTime) {\n                            perc = 1;\n                        } else if (frameNum < keyTime) {\n                            perc = 0;\n                        } else {\n                            if (keyData.o.x.constructor === Array) {\n                                if (!keyframeMetadata.__fnct) {\n                                    keyframeMetadata.__fnct = [];\n                                }\n                                if (!keyframeMetadata.__fnct[i]) {\n                                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];\n                                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];\n                                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];\n                                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];\n                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                    keyframeMetadata.__fnct[i] = fnc;\n                                } else {\n                                    fnc = keyframeMetadata.__fnct[i];\n                                }\n                            } else if (!keyframeMetadata.__fnct) {\n                                outX = keyData.o.x;\n                                outY = keyData.o.y;\n                                inX = keyData.i.x;\n                                inY = keyData.i.y;\n                                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                keyData.keyframeMetadata = fnc;\n                            } else {\n                                fnc = keyframeMetadata.__fnct;\n                            }\n                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                        }\n                    }\n                    endValue = nextKeyData.s || keyData.e;\n                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;\n                    if (this.propType === \"multidimensional\") {\n                        newValue[i] = keyValue;\n                    } else {\n                        newValue = keyValue;\n                    }\n                }\n            }\n        }\n        caching.lastIndex = iterationIndex;\n        return newValue;\n    } // based on @Toji's https://github.com/toji/gl-matrix/\n    function slerp(a, b, t) {\n        var out = [];\n        var ax = a[0];\n        var ay = a[1];\n        var az = a[2];\n        var aw = a[3];\n        var bx = b[0];\n        var by = b[1];\n        var bz = b[2];\n        var bw = b[3];\n        var omega;\n        var cosom;\n        var sinom;\n        var scale0;\n        var scale1;\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosom < 0.0) {\n            cosom = -cosom;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        if (1.0 - cosom > 0.000001) {\n            omega = Math.acos(cosom);\n            sinom = Math.sin(omega);\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\n            scale1 = Math.sin(t * omega) / sinom;\n        } else {\n            scale0 = 1.0 - t;\n            scale1 = t;\n        }\n        out[0] = scale0 * ax + scale1 * bx;\n        out[1] = scale0 * ay + scale1 * by;\n        out[2] = scale0 * az + scale1 * bz;\n        out[3] = scale0 * aw + scale1 * bw;\n        return out;\n    }\n    function quaternionToEuler(out, quat) {\n        var qx = quat[0];\n        var qy = quat[1];\n        var qz = quat[2];\n        var qw = quat[3];\n        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);\n        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);\n        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);\n        out[0] = heading / degToRads;\n        out[1] = attitude / degToRads;\n        out[2] = bank / degToRads;\n    }\n    function createQuaternion(values) {\n        var heading = values[0] * degToRads;\n        var attitude = values[1] * degToRads;\n        var bank = values[2] * degToRads;\n        var c1 = Math.cos(heading / 2);\n        var c2 = Math.cos(attitude / 2);\n        var c3 = Math.cos(bank / 2);\n        var s1 = Math.sin(heading / 2);\n        var s2 = Math.sin(attitude / 2);\n        var s3 = Math.sin(bank / 2);\n        var w = c1 * c2 * c3 - s1 * s2 * s3;\n        var x = s1 * s2 * c3 + c1 * c2 * s3;\n        var y = s1 * c2 * c3 + c1 * s2 * s3;\n        var z = c1 * s2 * c3 - s1 * c2 * s3;\n        return [\n            x,\n            y,\n            z,\n            w\n        ];\n    }\n    function getValueAtCurrentTime() {\n        var frameNum = this.comp.renderedFrame - this.offsetTime;\n        var initTime = this.keyframes[0].t - this.offsetTime;\n        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {\n            if (this._caching.lastFrame >= frameNum) {\n                this._caching._lastKeyframeIndex = -1;\n                this._caching.lastIndex = 0;\n            }\n            var renderResult = this.interpolateValue(frameNum, this._caching);\n            this.pv = renderResult;\n        }\n        this._caching.lastFrame = frameNum;\n        return this.pv;\n    }\n    function setVValue(val) {\n        var multipliedValue;\n        if (this.propType === \"unidimensional\") {\n            multipliedValue = val * this.mult;\n            if (mathAbs(this.v - multipliedValue) > 0.00001) {\n                this.v = multipliedValue;\n                this._mdf = true;\n            }\n        } else {\n            var i = 0;\n            var len = this.v.length;\n            while(i < len){\n                multipliedValue = val[i] * this.mult;\n                if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n                    this.v[i] = multipliedValue;\n                    this._mdf = true;\n                }\n                i += 1;\n            }\n        }\n    }\n    function processEffectsSequence() {\n        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n            return;\n        }\n        if (this.lock) {\n            this.setVValue(this.pv);\n            return;\n        }\n        this.lock = true;\n        this._mdf = this._isFirstFrame;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = this.kf ? this.pv : this.data.k;\n        for(i = 0; i < len; i += 1){\n            finalValue = this.effectsSequence[i](finalValue);\n        }\n        this.setVValue(finalValue);\n        this._isFirstFrame = false;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    }\n    function addEffect(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.container.addDynamicProperty(this);\n    }\n    function ValueProperty(elem, data, mult, container) {\n        this.propType = \"unidimensional\";\n        this.mult = mult || 1;\n        this.data = data;\n        this.v = mult ? data.k * mult : data.k;\n        this.pv = data.k;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.vel = 0;\n        this.effectsSequence = [];\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function MultiDimensionalProperty(elem, data, mult, container) {\n        this.propType = \"multidimensional\";\n        this.mult = mult || 1;\n        this.data = data;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.frameId = -1;\n        var i;\n        var len = data.k.length;\n        this.v = createTypedArray(\"float32\", len);\n        this.pv = createTypedArray(\"float32\", len);\n        this.vel = createTypedArray(\"float32\", len);\n        for(i = 0; i < len; i += 1){\n            this.v[i] = data.k[i] * this.mult;\n            this.pv[i] = data.k[i];\n        }\n        this._isFirstFrame = true;\n        this.effectsSequence = [];\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function KeyframedValueProperty(elem, data, mult, container) {\n        this.propType = \"unidimensional\";\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.frameId = -1;\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: 0,\n            _lastKeyframeIndex: -1\n        };\n        this.k = true;\n        this.kf = true;\n        this.data = data;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.v = initFrame;\n        this.pv = initFrame;\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.addEffect = addEffect;\n    }\n    function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n        this.propType = \"multidimensional\";\n        var i;\n        var len = data.k.length;\n        var s;\n        var e;\n        var to;\n        var ti;\n        for(i = 0; i < len - 1; i += 1){\n            if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n                s = data.k[i].s;\n                e = data.k[i + 1].s;\n                to = data.k[i].to;\n                ti = data.k[i].ti;\n                if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {\n                    data.k[i].to = null;\n                    data.k[i].ti = null;\n                }\n                if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {\n                        data.k[i].to = null;\n                        data.k[i].ti = null;\n                    }\n                }\n            }\n        }\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.data = data;\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.k = true;\n        this.kf = true;\n        this._isFirstFrame = true;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.frameId = -1;\n        var arrLen = data.k[0].s.length;\n        this.v = createTypedArray(\"float32\", arrLen);\n        this.pv = createTypedArray(\"float32\", arrLen);\n        for(i = 0; i < arrLen; i += 1){\n            this.v[i] = initFrame;\n            this.pv[i] = initFrame;\n        }\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: createTypedArray(\"float32\", arrLen)\n        };\n        this.addEffect = addEffect;\n    }\n    var PropertyFactory = function() {\n        function getProp(elem, data, type, mult, container) {\n            if (data.sid) {\n                data = elem.globalData.slotManager.getProp(data);\n            }\n            var p;\n            if (!data.k.length) {\n                p = new ValueProperty(elem, data, mult, container);\n            } else if (typeof data.k[0] === \"number\") {\n                p = new MultiDimensionalProperty(elem, data, mult, container);\n            } else {\n                switch(type){\n                    case 0:\n                        p = new KeyframedValueProperty(elem, data, mult, container);\n                        break;\n                    case 1:\n                        p = new KeyframedMultidimensionalProperty(elem, data, mult, container);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (p.effectsSequence.length) {\n                container.addDynamicProperty(p);\n            }\n            return p;\n        }\n        var ob = {\n            getProp: getProp\n        };\n        return ob;\n    }();\n    function DynamicPropertyContainer() {}\n    DynamicPropertyContainer.prototype = {\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n                this.container.addDynamicProperty(this);\n                this._isAnimated = true;\n            }\n        },\n        iterateDynamicProperties: function iterateDynamicProperties() {\n            this._mdf = false;\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                this.dynamicProperties[i].getValue();\n                if (this.dynamicProperties[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        },\n        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {\n            this.container = container;\n            this.dynamicProperties = [];\n            this._mdf = false;\n            this._isAnimated = false;\n        }\n    };\n    var pointPool = function() {\n        function create() {\n            return createTypedArray(\"float32\", 2);\n        }\n        return poolFactory(8, create);\n    }();\n    function ShapePath() {\n        this.c = false;\n        this._length = 0;\n        this._maxLength = 8;\n        this.v = createSizedArray(this._maxLength);\n        this.o = createSizedArray(this._maxLength);\n        this.i = createSizedArray(this._maxLength);\n    }\n    ShapePath.prototype.setPathData = function(closed, len) {\n        this.c = closed;\n        this.setLength(len);\n        var i = 0;\n        while(i < len){\n            this.v[i] = pointPool.newElement();\n            this.o[i] = pointPool.newElement();\n            this.i[i] = pointPool.newElement();\n            i += 1;\n        }\n    };\n    ShapePath.prototype.setLength = function(len) {\n        while(this._maxLength < len){\n            this.doubleArrayLength();\n        }\n        this._length = len;\n    };\n    ShapePath.prototype.doubleArrayLength = function() {\n        this.v = this.v.concat(createSizedArray(this._maxLength));\n        this.i = this.i.concat(createSizedArray(this._maxLength));\n        this.o = this.o.concat(createSizedArray(this._maxLength));\n        this._maxLength *= 2;\n    };\n    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {\n        var arr;\n        this._length = Math.max(this._length, pos + 1);\n        if (this._length >= this._maxLength) {\n            this.doubleArrayLength();\n        }\n        switch(type){\n            case \"v\":\n                arr = this.v;\n                break;\n            case \"i\":\n                arr = this.i;\n                break;\n            case \"o\":\n                arr = this.o;\n                break;\n            default:\n                arr = [];\n                break;\n        }\n        if (!arr[pos] || arr[pos] && !replace) {\n            arr[pos] = pointPool.newElement();\n        }\n        arr[pos][0] = x;\n        arr[pos][1] = y;\n    };\n    ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {\n        this.setXYAt(vX, vY, \"v\", pos, replace);\n        this.setXYAt(oX, oY, \"o\", pos, replace);\n        this.setXYAt(iX, iY, \"i\", pos, replace);\n    };\n    ShapePath.prototype.reverse = function() {\n        var newPath = new ShapePath();\n        newPath.setPathData(this.c, this._length);\n        var vertices = this.v;\n        var outPoints = this.o;\n        var inPoints = this.i;\n        var init = 0;\n        if (this.c) {\n            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\n            init = 1;\n        }\n        var cnt = this._length - 1;\n        var len = this._length;\n        var i;\n        for(i = init; i < len; i += 1){\n            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\n            cnt -= 1;\n        }\n        return newPath;\n    };\n    ShapePath.prototype.length = function() {\n        return this._length;\n    };\n    var shapePool = function() {\n        function create() {\n            return new ShapePath();\n        }\n        function release(shapePath) {\n            var len = shapePath._length;\n            var i;\n            for(i = 0; i < len; i += 1){\n                pointPool.release(shapePath.v[i]);\n                pointPool.release(shapePath.i[i]);\n                pointPool.release(shapePath.o[i]);\n                shapePath.v[i] = null;\n                shapePath.i[i] = null;\n                shapePath.o[i] = null;\n            }\n            shapePath._length = 0;\n            shapePath.c = false;\n        }\n        function clone(shape) {\n            var cloned = factory.newElement();\n            var i;\n            var len = shape._length === undefined ? shape.v.length : shape._length;\n            cloned.setLength(len);\n            cloned.c = shape.c;\n            for(i = 0; i < len; i += 1){\n                cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);\n            }\n            return cloned;\n        }\n        var factory = poolFactory(4, create, release);\n        factory.clone = clone;\n        return factory;\n    }();\n    function ShapeCollection() {\n        this._length = 0;\n        this._maxLength = 4;\n        this.shapes = createSizedArray(this._maxLength);\n    }\n    ShapeCollection.prototype.addShape = function(shapeData) {\n        if (this._length === this._maxLength) {\n            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));\n            this._maxLength *= 2;\n        }\n        this.shapes[this._length] = shapeData;\n        this._length += 1;\n    };\n    ShapeCollection.prototype.releaseShapes = function() {\n        var i;\n        for(i = 0; i < this._length; i += 1){\n            shapePool.release(this.shapes[i]);\n        }\n        this._length = 0;\n    };\n    var shapeCollectionPool = function() {\n        var ob = {\n            newShapeCollection: newShapeCollection,\n            release: release\n        };\n        var _length = 0;\n        var _maxLength = 4;\n        var pool = createSizedArray(_maxLength);\n        function newShapeCollection() {\n            var shapeCollection;\n            if (_length) {\n                _length -= 1;\n                shapeCollection = pool[_length];\n            } else {\n                shapeCollection = new ShapeCollection();\n            }\n            return shapeCollection;\n        }\n        function release(shapeCollection) {\n            var i;\n            var len = shapeCollection._length;\n            for(i = 0; i < len; i += 1){\n                shapePool.release(shapeCollection.shapes[i]);\n            }\n            shapeCollection._length = 0;\n            if (_length === _maxLength) {\n                pool = pooling[\"double\"](pool);\n                _maxLength *= 2;\n            }\n            pool[_length] = shapeCollection;\n            _length += 1;\n        }\n        return ob;\n    }();\n    var ShapePropertyFactory = function() {\n        var initFrame = -999999;\n        function interpolateShape(frameNum, previousValue, caching) {\n            var iterationIndex = caching.lastIndex;\n            var keyPropS;\n            var keyPropE;\n            var isHold;\n            var j;\n            var k;\n            var jLen;\n            var kLen;\n            var perc;\n            var vertexValue;\n            var kf = this.keyframes;\n            if (frameNum < kf[0].t - this.offsetTime) {\n                keyPropS = kf[0].s[0];\n                isHold = true;\n                iterationIndex = 0;\n            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];\n                /* if(kf[kf.length - 1].s){\r\n                  keyPropS = kf[kf.length - 1].s[0];\r\n              }else{\r\n                  keyPropS = kf[kf.length - 2].e[0];\r\n              } */ isHold = true;\n            } else {\n                var i = iterationIndex;\n                var len = kf.length - 1;\n                var flag = true;\n                var keyData;\n                var nextKeyData;\n                var keyframeMetadata;\n                while(flag){\n                    keyData = kf[i];\n                    nextKeyData = kf[i + 1];\n                    if (nextKeyData.t - this.offsetTime > frameNum) {\n                        break;\n                    }\n                    if (i < len - 1) {\n                        i += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                keyframeMetadata = this.keyframesMetadata[i] || {};\n                isHold = keyData.h === 1;\n                iterationIndex = i;\n                if (!isHold) {\n                    if (frameNum >= nextKeyData.t - this.offsetTime) {\n                        perc = 1;\n                    } else if (frameNum < keyData.t - this.offsetTime) {\n                        perc = 0;\n                    } else {\n                        var fnc;\n                        if (keyframeMetadata.__fnct) {\n                            fnc = keyframeMetadata.__fnct;\n                        } else {\n                            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;\n                            keyframeMetadata.__fnct = fnc;\n                        }\n                        perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));\n                    }\n                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];\n                }\n                keyPropS = keyData.s[0];\n            }\n            jLen = previousValue._length;\n            kLen = keyPropS.i[0].length;\n            caching.lastIndex = iterationIndex;\n            for(j = 0; j < jLen; j += 1){\n                for(k = 0; k < kLen; k += 1){\n                    vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;\n                    previousValue.i[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;\n                    previousValue.o[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;\n                    previousValue.v[j][k] = vertexValue;\n                }\n            }\n        }\n        function interpolateShapeCurrentTime() {\n            var frameNum = this.comp.renderedFrame - this.offsetTime;\n            var initTime = this.keyframes[0].t - this.offsetTime;\n            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n            var lastFrame = this._caching.lastFrame;\n            if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {\n                /// /\n                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\n                this.interpolateShape(frameNum, this.pv, this._caching); /// /\n            }\n            this._caching.lastFrame = frameNum;\n            return this.pv;\n        }\n        function resetShape() {\n            this.paths = this.localShapeCollection;\n        }\n        function shapesEqual(shape1, shape2) {\n            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n                return false;\n            }\n            var i;\n            var len = shape1._length;\n            for(i = 0; i < len; i += 1){\n                if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function setVValue(newPath) {\n            if (!shapesEqual(this.v, newPath)) {\n                this.v = shapePool.clone(newPath);\n                this.localShapeCollection.releaseShapes();\n                this.localShapeCollection.addShape(this.v);\n                this._mdf = true;\n                this.paths = this.localShapeCollection;\n            }\n        }\n        function processEffectsSequence() {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (!this.effectsSequence.length) {\n                this._mdf = false;\n                return;\n            }\n            if (this.lock) {\n                this.setVValue(this.pv);\n                return;\n            }\n            this.lock = true;\n            this._mdf = false;\n            var finalValue;\n            if (this.kf) {\n                finalValue = this.pv;\n            } else if (this.data.ks) {\n                finalValue = this.data.ks.k;\n            } else {\n                finalValue = this.data.pt.k;\n            }\n            var i;\n            var len = this.effectsSequence.length;\n            for(i = 0; i < len; i += 1){\n                finalValue = this.effectsSequence[i](finalValue);\n            }\n            this.setVValue(finalValue);\n            this.lock = false;\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function ShapeProperty(elem, data, type) {\n            this.propType = \"shape\";\n            this.comp = elem.comp;\n            this.container = elem;\n            this.elem = elem;\n            this.data = data;\n            this.k = false;\n            this.kf = false;\n            this._mdf = false;\n            var pathData = type === 3 ? data.pt.k : data.ks.k;\n            this.v = shapePool.clone(pathData);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.reset = resetShape;\n            this.effectsSequence = [];\n        }\n        function addEffect(effectFunction) {\n            this.effectsSequence.push(effectFunction);\n            this.container.addDynamicProperty(this);\n        }\n        ShapeProperty.prototype.interpolateShape = interpolateShape;\n        ShapeProperty.prototype.getValue = processEffectsSequence;\n        ShapeProperty.prototype.setVValue = setVValue;\n        ShapeProperty.prototype.addEffect = addEffect;\n        function KeyframedShapeProperty(elem, data, type) {\n            this.propType = \"shape\";\n            this.comp = elem.comp;\n            this.elem = elem;\n            this.container = elem;\n            this.offsetTime = elem.data.st;\n            this.keyframes = type === 3 ? data.pt.k : data.ks.k;\n            this.keyframesMetadata = [];\n            this.k = true;\n            this.kf = true;\n            var len = this.keyframes[0].s[0].i.length;\n            this.v = shapePool.newElement();\n            this.v.setPathData(this.keyframes[0].s[0].c, len);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.lastFrame = initFrame;\n            this.reset = resetShape;\n            this._caching = {\n                lastFrame: initFrame,\n                lastIndex: 0\n            };\n            this.effectsSequence = [\n                interpolateShapeCurrentTime.bind(this)\n            ];\n        }\n        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\n        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\n        KeyframedShapeProperty.prototype.setVValue = setVValue;\n        KeyframedShapeProperty.prototype.addEffect = addEffect;\n        var EllShapeProperty = function() {\n            var cPoint = roundCorner;\n            function EllShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 4);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.paths = this.localShapeCollection;\n                this.localShapeCollection.addShape(this.v);\n                this.d = data.d;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertEllToPath();\n                }\n            }\n            EllShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertEllToPath();\n                    }\n                },\n                convertEllToPath: function convertEllToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var s0 = this.s.v[0] / 2;\n                    var s1 = this.s.v[1] / 2;\n                    var _cw = this.d !== 3;\n                    var _v = this.v;\n                    _v.v[0][0] = p0;\n                    _v.v[0][1] = p1 - s1;\n                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.v[1][1] = p1;\n                    _v.v[2][0] = p0;\n                    _v.v[2][1] = p1 + s1;\n                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.v[3][1] = p1;\n                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.i[0][1] = p1 - s1;\n                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.i[1][1] = p1 - s1 * cPoint;\n                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.i[2][1] = p1 + s1;\n                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.i[3][1] = p1 + s1 * cPoint;\n                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.o[0][1] = p1 - s1;\n                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.o[1][1] = p1 + s1 * cPoint;\n                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.o[2][1] = p1 + s1;\n                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.o[3][1] = p1 - s1 * cPoint;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], EllShapePropertyFactory);\n            return EllShapePropertyFactory;\n        }();\n        var StarShapeProperty = function() {\n            function StarShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 0);\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.data = data;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                if (data.sy === 1) {\n                    this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);\n                    this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);\n                    this.convertToPath = this.convertStarToPath;\n                } else {\n                    this.convertToPath = this.convertPolygonToPath;\n                }\n                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\n                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);\n                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertToPath();\n                }\n            }\n            StarShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertToPath();\n                    }\n                },\n                convertStarToPath: function convertStarToPath() {\n                    var numPts = Math.floor(this.pt.v) * 2;\n                    var angle = Math.PI * 2 / numPts;\n                    /* this.v.v.length = numPts;\r\n                  this.v.i.length = numPts;\r\n                  this.v.o.length = numPts; */ var longFlag = true;\n                    var longRad = this.or.v;\n                    var shortRad = this.ir.v;\n                    var longRound = this.os.v;\n                    var shortRound = this.is.v;\n                    var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);\n                    var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);\n                    var i;\n                    var rad;\n                    var roundness;\n                    var perimSegment;\n                    var currentAng = -Math.PI / 2;\n                    currentAng += this.r.v;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        rad = longFlag ? longRad : shortRad;\n                        roundness = longFlag ? longRound : shortRound;\n                        perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        /* this.v.v[i] = [x,y];\r\n                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\r\n                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\r\n                      this.v._length = numPts; */ longFlag = !longFlag;\n                        currentAng += angle * dir;\n                    }\n                },\n                convertPolygonToPath: function convertPolygonToPath() {\n                    var numPts = Math.floor(this.pt.v);\n                    var angle = Math.PI * 2 / numPts;\n                    var rad = this.or.v;\n                    var roundness = this.os.v;\n                    var perimSegment = 2 * Math.PI * rad / (numPts * 4);\n                    var i;\n                    var currentAng = -Math.PI * 0.5;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    currentAng += this.r.v;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        currentAng += angle * dir;\n                    }\n                    this.paths.length = 0;\n                    this.paths[0] = this.v;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], StarShapePropertyFactory);\n            return StarShapePropertyFactory;\n        }();\n        var RectShapeProperty = function() {\n            function RectShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.c = true;\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertRectToPath();\n                }\n            }\n            RectShapePropertyFactory.prototype = {\n                convertRectToPath: function convertRectToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var v0 = this.s.v[0] / 2;\n                    var v1 = this.s.v[1] / 2;\n                    var round = bmMin(v0, v1, this.r.v);\n                    var cPoint = round * (1 - roundCorner);\n                    this.v._length = 0;\n                    if (this.d === 2 || this.d === 1) {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);\n                        this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);\n                        }\n                    } else {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);\n                        }\n                    }\n                },\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertRectToPath();\n                    }\n                },\n                reset: resetShape\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], RectShapePropertyFactory);\n            return RectShapePropertyFactory;\n        }();\n        function getShapeProp(elem, data, type) {\n            var prop;\n            if (type === 3 || type === 4) {\n                var dataProp = type === 3 ? data.pt : data.ks;\n                var keys = dataProp.k;\n                if (keys.length) {\n                    prop = new KeyframedShapeProperty(elem, data, type);\n                } else {\n                    prop = new ShapeProperty(elem, data, type);\n                }\n            } else if (type === 5) {\n                prop = new RectShapeProperty(elem, data);\n            } else if (type === 6) {\n                prop = new EllShapeProperty(elem, data);\n            } else if (type === 7) {\n                prop = new StarShapeProperty(elem, data);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        }\n        function getConstructorFunction() {\n            return ShapeProperty;\n        }\n        function getKeyframedConstructorFunction() {\n            return KeyframedShapeProperty;\n        }\n        var ob = {};\n        ob.getShapeProp = getShapeProp;\n        ob.getConstructorFunction = getConstructorFunction;\n        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\n        return ob;\n    }();\n    /*!\r\n   Transformation Matrix v2.0\r\n   (c) Epistemex 2014-2015\r\n   www.epistemex.com\r\n   By Ken Fyrstenberg\r\n   Contributions by leeoniya.\r\n   License: MIT, header required.\r\n   */ /**\r\n   * 2D transformation matrix object initialized with identity matrix.\r\n   *\r\n   * The matrix can synchronize a canvas context by supplying the context\r\n   * as an argument, or later apply current absolute transform to an\r\n   * existing context.\r\n   *\r\n   * All values are handled as floating point values.\r\n   *\r\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\r\n   * @prop {number} a - scale x\r\n   * @prop {number} b - shear y\r\n   * @prop {number} c - shear x\r\n   * @prop {number} d - scale y\r\n   * @prop {number} e - translate x\r\n   * @prop {number} f - translate y\r\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\r\n   * @constructor\r\n   */ var Matrix = function() {\n        var _cos = Math.cos;\n        var _sin = Math.sin;\n        var _tan = Math.tan;\n        var _rnd = Math.round;\n        function reset() {\n            this.props[0] = 1;\n            this.props[1] = 0;\n            this.props[2] = 0;\n            this.props[3] = 0;\n            this.props[4] = 0;\n            this.props[5] = 1;\n            this.props[6] = 0;\n            this.props[7] = 0;\n            this.props[8] = 0;\n            this.props[9] = 0;\n            this.props[10] = 1;\n            this.props[11] = 0;\n            this.props[12] = 0;\n            this.props[13] = 0;\n            this.props[14] = 0;\n            this.props[15] = 1;\n            return this;\n        }\n        function rotate(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function rotateX(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateY(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateZ(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function shear(sx, sy) {\n            return this._t(1, sy, sx, 1, 0, 0);\n        }\n        function skew(ax, ay) {\n            return this.shear(_tan(ax), _tan(ay));\n        }\n        function skewFromAxis(ax, angle) {\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1); // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n        }\n        function scale(sx, sy, sz) {\n            if (!sz && sz !== 0) {\n                sz = 1;\n            }\n            if (sx === 1 && sy === 1 && sz === 1) {\n                return this;\n            }\n            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\n        }\n        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n            this.props[0] = a;\n            this.props[1] = b;\n            this.props[2] = c;\n            this.props[3] = d;\n            this.props[4] = e;\n            this.props[5] = f;\n            this.props[6] = g;\n            this.props[7] = h;\n            this.props[8] = i;\n            this.props[9] = j;\n            this.props[10] = k;\n            this.props[11] = l;\n            this.props[12] = m;\n            this.props[13] = n;\n            this.props[14] = o;\n            this.props[15] = p;\n            return this;\n        }\n        function translate(tx, ty, tz) {\n            tz = tz || 0;\n            if (tx !== 0 || ty !== 0 || tz !== 0) {\n                return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);\n            }\n            return this;\n        }\n        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n            var _p = this.props;\n            if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {\n                // NOTE: commenting this condition because TurboFan deoptimizes code when present\n                // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n                _p[12] = _p[12] * a2 + _p[15] * m2;\n                _p[13] = _p[13] * f2 + _p[15] * n2;\n                _p[14] = _p[14] * k2 + _p[15] * o2;\n                _p[15] *= p2; // }\n                this._identityCalculated = false;\n                return this;\n            }\n            var a1 = _p[0];\n            var b1 = _p[1];\n            var c1 = _p[2];\n            var d1 = _p[3];\n            var e1 = _p[4];\n            var f1 = _p[5];\n            var g1 = _p[6];\n            var h1 = _p[7];\n            var i1 = _p[8];\n            var j1 = _p[9];\n            var k1 = _p[10];\n            var l1 = _p[11];\n            var m1 = _p[12];\n            var n1 = _p[13];\n            var o1 = _p[14];\n            var p1 = _p[15];\n            /* matrix order (canvas compatible):\r\n           * ace\r\n           * bdf\r\n           * 001\r\n           */ _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\n            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;\n            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;\n            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;\n            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;\n            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;\n            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;\n            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;\n            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;\n            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;\n            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;\n            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;\n            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;\n            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;\n            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;\n            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;\n            this._identityCalculated = false;\n            return this;\n        }\n        function multiply(matrix) {\n            var matrixProps = matrix.props;\n            return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);\n        }\n        function isIdentity() {\n            if (!this._identityCalculated) {\n                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\n                this._identityCalculated = true;\n            }\n            return this._identity;\n        }\n        function equals(matr) {\n            var i = 0;\n            while(i < 16){\n                if (matr.props[i] !== this.props[i]) {\n                    return false;\n                }\n                i += 1;\n            }\n            return true;\n        }\n        function clone(matr) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                matr.props[i] = this.props[i];\n            }\n            return matr;\n        }\n        function cloneFromProps(props) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                this.props[i] = props[i];\n            }\n        }\n        function applyToPoint(x, y, z) {\n            return {\n                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n            };\n        /* return {\r\n           x: x * me.a + y * me.c + me.e,\r\n           y: x * me.b + y * me.d + me.f\r\n           }; */ }\n        function applyToX(x, y, z) {\n            return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\n        }\n        function applyToY(x, y, z) {\n            return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\n        }\n        function applyToZ(x, y, z) {\n            return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\n        }\n        function getInverseMatrix() {\n            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\n            var a = this.props[5] / determinant;\n            var b = -this.props[1] / determinant;\n            var c = -this.props[4] / determinant;\n            var d = this.props[0] / determinant;\n            var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;\n            var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;\n            var inverseMatrix = new Matrix();\n            inverseMatrix.props[0] = a;\n            inverseMatrix.props[1] = b;\n            inverseMatrix.props[4] = c;\n            inverseMatrix.props[5] = d;\n            inverseMatrix.props[12] = e;\n            inverseMatrix.props[13] = f;\n            return inverseMatrix;\n        }\n        function inversePoint(pt) {\n            var inverseMatrix = this.getInverseMatrix();\n            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);\n        }\n        function inversePoints(pts) {\n            var i;\n            var len = pts.length;\n            var retPts = [];\n            for(i = 0; i < len; i += 1){\n                retPts[i] = inversePoint(pts[i]);\n            }\n            return retPts;\n        }\n        function applyToTriplePoints(pt1, pt2, pt3) {\n            var arr = createTypedArray(\"float32\", 6);\n            if (this.isIdentity()) {\n                arr[0] = pt1[0];\n                arr[1] = pt1[1];\n                arr[2] = pt2[0];\n                arr[3] = pt2[1];\n                arr[4] = pt3[0];\n                arr[5] = pt3[1];\n            } else {\n                var p0 = this.props[0];\n                var p1 = this.props[1];\n                var p4 = this.props[4];\n                var p5 = this.props[5];\n                var p12 = this.props[12];\n                var p13 = this.props[13];\n                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\n                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\n                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\n                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\n                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\n                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\n            }\n            return arr;\n        }\n        function applyToPointArray(x, y, z) {\n            var arr;\n            if (this.isIdentity()) {\n                arr = [\n                    x,\n                    y,\n                    z\n                ];\n            } else {\n                arr = [\n                    x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                    x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                    x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n                ];\n            }\n            return arr;\n        }\n        function applyToPointStringified(x, y) {\n            if (this.isIdentity()) {\n                return x + \",\" + y;\n            }\n            var _p = this.props;\n            return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + \",\" + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\n        }\n        function toCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\r\n              return '';\r\n          } */ var i = 0;\n            var props = this.props;\n            var cssValue = \"matrix3d(\";\n            var v = 10000;\n            while(i < 16){\n                cssValue += _rnd(props[i] * v) / v;\n                cssValue += i === 15 ? \")\" : \",\";\n                i += 1;\n            }\n            return cssValue;\n        }\n        function roundMatrixProperty(val) {\n            var v = 10000;\n            if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {\n                return _rnd(val * v) / v;\n            }\n            return val;\n        }\n        function to2dCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\r\n              return '';\r\n          } */ var props = this.props;\n            var _a = roundMatrixProperty(props[0]);\n            var _b = roundMatrixProperty(props[1]);\n            var _c = roundMatrixProperty(props[4]);\n            var _d = roundMatrixProperty(props[5]);\n            var _e = roundMatrixProperty(props[12]);\n            var _f = roundMatrixProperty(props[13]);\n            return \"matrix(\" + _a + \",\" + _b + \",\" + _c + \",\" + _d + \",\" + _e + \",\" + _f + \")\";\n        }\n        return function() {\n            this.reset = reset;\n            this.rotate = rotate;\n            this.rotateX = rotateX;\n            this.rotateY = rotateY;\n            this.rotateZ = rotateZ;\n            this.skew = skew;\n            this.skewFromAxis = skewFromAxis;\n            this.shear = shear;\n            this.scale = scale;\n            this.setTransform = setTransform;\n            this.translate = translate;\n            this.transform = transform;\n            this.multiply = multiply;\n            this.applyToPoint = applyToPoint;\n            this.applyToX = applyToX;\n            this.applyToY = applyToY;\n            this.applyToZ = applyToZ;\n            this.applyToPointArray = applyToPointArray;\n            this.applyToTriplePoints = applyToTriplePoints;\n            this.applyToPointStringified = applyToPointStringified;\n            this.toCSS = toCSS;\n            this.to2dCSS = to2dCSS;\n            this.clone = clone;\n            this.cloneFromProps = cloneFromProps;\n            this.equals = equals;\n            this.inversePoints = inversePoints;\n            this.inversePoint = inversePoint;\n            this.getInverseMatrix = getInverseMatrix;\n            this._t = this.transform;\n            this.isIdentity = isIdentity;\n            this._identity = true;\n            this._identityCalculated = false;\n            this.props = createTypedArray(\"float32\", 16);\n            this.reset();\n        };\n    }();\n    function _typeof$3(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$3 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$3 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$3(obj);\n    }\n    var lottie = {};\n    var standalone = \"__[STANDALONE]__\";\n    var animationData = \"__[ANIMATIONDATA]__\";\n    var renderer = \"\";\n    function setLocation(href) {\n        setLocationHref(href);\n    }\n    function searchAnimations() {\n        if (standalone === true) {\n            animationManager.searchAnimations(animationData, standalone, renderer);\n        } else {\n            animationManager.searchAnimations();\n        }\n    }\n    function setSubframeRendering(flag) {\n        setSubframeEnabled(flag);\n    }\n    function setPrefix(prefix) {\n        setIdPrefix(prefix);\n    }\n    function loadAnimation(params) {\n        if (standalone === true) {\n            params.animationData = JSON.parse(animationData);\n        }\n        return animationManager.loadAnimation(params);\n    }\n    function setQuality(value) {\n        if (typeof value === \"string\") {\n            switch(value){\n                case \"high\":\n                    setDefaultCurveSegments(200);\n                    break;\n                default:\n                case \"medium\":\n                    setDefaultCurveSegments(50);\n                    break;\n                case \"low\":\n                    setDefaultCurveSegments(10);\n                    break;\n            }\n        } else if (!isNaN(value) && value > 1) {\n            setDefaultCurveSegments(value);\n        }\n        if (getDefaultCurveSegments() >= 50) {\n            roundValues(false);\n        } else {\n            roundValues(true);\n        }\n    }\n    function inBrowser() {\n        return typeof navigator !== \"undefined\";\n    }\n    function installPlugin(type, plugin) {\n        if (type === \"expressions\") {\n            setExpressionsPlugin(plugin);\n        }\n    }\n    function getFactory(name) {\n        switch(name){\n            case \"propertyFactory\":\n                return PropertyFactory;\n            case \"shapePropertyFactory\":\n                return ShapePropertyFactory;\n            case \"matrix\":\n                return Matrix;\n            default:\n                return null;\n        }\n    }\n    lottie.play = animationManager.play;\n    lottie.pause = animationManager.pause;\n    lottie.setLocationHref = setLocation;\n    lottie.togglePause = animationManager.togglePause;\n    lottie.setSpeed = animationManager.setSpeed;\n    lottie.setDirection = animationManager.setDirection;\n    lottie.stop = animationManager.stop;\n    lottie.searchAnimations = searchAnimations;\n    lottie.registerAnimation = animationManager.registerAnimation;\n    lottie.loadAnimation = loadAnimation;\n    lottie.setSubframeRendering = setSubframeRendering;\n    lottie.resize = animationManager.resize; // lottie.start = start;\n    lottie.goToAndStop = animationManager.goToAndStop;\n    lottie.destroy = animationManager.destroy;\n    lottie.setQuality = setQuality;\n    lottie.inBrowser = inBrowser;\n    lottie.installPlugin = installPlugin;\n    lottie.freeze = animationManager.freeze;\n    lottie.unfreeze = animationManager.unfreeze;\n    lottie.setVolume = animationManager.setVolume;\n    lottie.mute = animationManager.mute;\n    lottie.unmute = animationManager.unmute;\n    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;\n    lottie.useWebWorker = setWebWorker;\n    lottie.setIDPrefix = setPrefix;\n    lottie.__getFactory = getFactory;\n    lottie.version = \"5.12.2\";\n    function checkReady() {\n        if (document.readyState === \"complete\") {\n            clearInterval(readyStateCheckInterval);\n            searchAnimations();\n        }\n    }\n    function getQueryVariable(variable) {\n        var vars = queryString.split(\"&\");\n        for(var i = 0; i < vars.length; i += 1){\n            var pair = vars[i].split(\"=\");\n            if (decodeURIComponent(pair[0]) == variable) {\n                // eslint-disable-line eqeqeq\n                return decodeURIComponent(pair[1]);\n            }\n        }\n        return null;\n    }\n    var queryString = \"\";\n    if (standalone) {\n        var scripts = document.getElementsByTagName(\"script\");\n        var index = scripts.length - 1;\n        var myScript = scripts[index] || {\n            src: \"\"\n        };\n        queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, \"\") : \"\"; // eslint-disable-line no-useless-escape\n        renderer = getQueryVariable(\"renderer\");\n    }\n    var readyStateCheckInterval = setInterval(checkReady, 100); // this adds bodymovin to the window object for backwards compatibility\n    try {\n        if (!(( false ? 0 : _typeof$3(exports)) === \"object\" && \"object\" !== \"undefined\") && !( true && __webpack_require__.amdO // eslint-disable-line no-undef\n        )) {}\n    } catch (err) {}\n    var ShapeModifiers = function() {\n        var ob = {};\n        var modifiers = {};\n        ob.registerModifier = registerModifier;\n        ob.getModifier = getModifier;\n        function registerModifier(nm, factory) {\n            if (!modifiers[nm]) {\n                modifiers[nm] = factory;\n            }\n        }\n        function getModifier(nm, elem, data) {\n            return new modifiers[nm](elem, data);\n        }\n        return ob;\n    }();\n    function ShapeModifier() {}\n    ShapeModifier.prototype.initModifierProperties = function() {};\n    ShapeModifier.prototype.addShapeToModifier = function() {};\n    ShapeModifier.prototype.addShape = function(data) {\n        if (!this.closed) {\n            // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n            data.sh.container.addDynamicProperty(data.sh);\n            var shapeData = {\n                shape: data.sh,\n                data: data,\n                localShapeCollection: shapeCollectionPool.newShapeCollection()\n            };\n            this.shapes.push(shapeData);\n            this.addShapeToModifier(shapeData);\n            if (this._isAnimated) {\n                data.setAsAnimated();\n            }\n        }\n    };\n    ShapeModifier.prototype.init = function(elem, data) {\n        this.shapes = [];\n        this.elem = elem;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, data);\n        this.frameId = initialDefaultFrame;\n        this.closed = false;\n        this.k = false;\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    ShapeModifier.prototype.processKeys = function() {\n        if (this.elem.globalData.frameId === this.frameId) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], ShapeModifier);\n    function TrimModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], TrimModifier);\n    TrimModifier.prototype.initModifierProperties = function(elem, data) {\n        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\n        this.sValue = 0;\n        this.eValue = 0;\n        this.getValue = this.processKeys;\n        this.m = data.m;\n        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\n    };\n    TrimModifier.prototype.addShapeToModifier = function(shapeData) {\n        shapeData.pathsData = [];\n    };\n    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {\n        var segments = [];\n        if (e <= 1) {\n            segments.push({\n                s: s,\n                e: e\n            });\n        } else if (s >= 1) {\n            segments.push({\n                s: s - 1,\n                e: e - 1\n            });\n        } else {\n            segments.push({\n                s: s,\n                e: 1\n            });\n            segments.push({\n                s: 0,\n                e: e - 1\n            });\n        }\n        var shapeSegments = [];\n        var i;\n        var len = segments.length;\n        var segmentOb;\n        for(i = 0; i < len; i += 1){\n            segmentOb = segments[i];\n            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {\n                var shapeS;\n                var shapeE;\n                if (segmentOb.s * totalModifierLength <= addedLength) {\n                    shapeS = 0;\n                } else {\n                    shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\n                }\n                if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n                    shapeE = 1;\n                } else {\n                    shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;\n                }\n                shapeSegments.push([\n                    shapeS,\n                    shapeE\n                ]);\n            }\n        }\n        if (!shapeSegments.length) {\n            shapeSegments.push([\n                0,\n                0\n            ]);\n        }\n        return shapeSegments;\n    };\n    TrimModifier.prototype.releasePathsData = function(pathsData) {\n        var i;\n        var len = pathsData.length;\n        for(i = 0; i < len; i += 1){\n            segmentsLengthPool.release(pathsData[i]);\n        }\n        pathsData.length = 0;\n        return pathsData;\n    };\n    TrimModifier.prototype.processShapes = function(_isFirstFrame) {\n        var s;\n        var e;\n        if (this._mdf || _isFirstFrame) {\n            var o = this.o.v % 360 / 360;\n            if (o < 0) {\n                o += 1;\n            }\n            if (this.s.v > 1) {\n                s = 1 + o;\n            } else if (this.s.v < 0) {\n                s = 0 + o;\n            } else {\n                s = this.s.v + o;\n            }\n            if (this.e.v > 1) {\n                e = 1 + o;\n            } else if (this.e.v < 0) {\n                e = 0 + o;\n            } else {\n                e = this.e.v + o;\n            }\n            if (s > e) {\n                var _s = s;\n                s = e;\n                e = _s;\n            }\n            s = Math.round(s * 10000) * 0.0001;\n            e = Math.round(e * 10000) * 0.0001;\n            this.sValue = s;\n            this.eValue = e;\n        } else {\n            s = this.sValue;\n            e = this.eValue;\n        }\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var pathsData;\n        var pathData;\n        var totalShapeLength;\n        var totalModifierLength = 0;\n        if (e === s) {\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].localShapeCollection.releaseShapes();\n                this.shapes[i].shape._mdf = true;\n                this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\n                if (this._mdf) {\n                    this.shapes[i].pathsData.length = 0;\n                }\n            }\n        } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {\n            var segments = [];\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i]; // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n                    shapeData.shape.paths = shapeData.localShapeCollection;\n                } else {\n                    shapePaths = shapeData.shape.paths;\n                    jLen = shapePaths._length;\n                    totalShapeLength = 0;\n                    if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n                        totalShapeLength = shapeData.totalShapeLength;\n                    } else {\n                        pathsData = this.releasePathsData(shapeData.pathsData);\n                        for(j = 0; j < jLen; j += 1){\n                            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\n                            pathsData.push(pathData);\n                            totalShapeLength += pathData.totalLength;\n                        }\n                        shapeData.totalShapeLength = totalShapeLength;\n                        shapeData.pathsData = pathsData;\n                    }\n                    totalModifierLength += totalShapeLength;\n                    shapeData.shape._mdf = true;\n                }\n            }\n            var shapeS = s;\n            var shapeE = e;\n            var addedLength = 0;\n            var edges;\n            for(i = len - 1; i >= 0; i -= 1){\n                shapeData = this.shapes[i];\n                if (shapeData.shape._mdf) {\n                    localShapeCollection = shapeData.localShapeCollection;\n                    localShapeCollection.releaseShapes(); // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n                    if (this.m === 2 && len > 1) {\n                        edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\n                        addedLength += shapeData.totalShapeLength;\n                    } else {\n                        edges = [\n                            [\n                                shapeS,\n                                shapeE\n                            ]\n                        ];\n                    }\n                    jLen = edges.length;\n                    for(j = 0; j < jLen; j += 1){\n                        shapeS = edges[j][0];\n                        shapeE = edges[j][1];\n                        segments.length = 0;\n                        if (shapeE <= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength * shapeE\n                            });\n                        } else if (shapeS >= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * (shapeS - 1),\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        } else {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength\n                            });\n                            segments.push({\n                                s: 0,\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        }\n                        var newShapesData = this.addShapes(shapeData, segments[0]);\n                        if (segments[0].s !== segments[0].e) {\n                            if (segments.length > 1) {\n                                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\n                                if (lastShapeInCollection.c) {\n                                    var lastShape = newShapesData.pop();\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);\n                                } else {\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1]);\n                                }\n                            }\n                            this.addPaths(newShapesData, localShapeCollection);\n                        }\n                    }\n                    shapeData.shape.paths = localShapeCollection;\n                }\n            }\n        } else if (this._mdf) {\n            for(i = 0; i < len; i += 1){\n                // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n                // Don't remove this even if it's losing cached info.\n                this.shapes[i].pathsData.length = 0;\n                this.shapes[i].shape._mdf = true;\n            }\n        }\n    };\n    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {\n        var i;\n        var len = newPaths.length;\n        for(i = 0; i < len; i += 1){\n            localShapeCollection.addShape(newPaths[i]);\n        }\n    };\n    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n        shapePath.setXYAt(pt2[0], pt2[1], \"o\", pos);\n        shapePath.setXYAt(pt3[0], pt3[1], \"i\", pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(pt1[0], pt1[1], \"v\", pos);\n        }\n        shapePath.setXYAt(pt4[0], pt4[1], \"v\", pos + 1);\n    };\n    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {\n        shapePath.setXYAt(points[1], points[5], \"o\", pos);\n        shapePath.setXYAt(points[2], points[6], \"i\", pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(points[0], points[4], \"v\", pos);\n        }\n        shapePath.setXYAt(points[3], points[7], \"v\", pos + 1);\n    };\n    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {\n        var pathsData = shapeData.pathsData;\n        var shapePaths = shapeData.shape.paths.shapes;\n        var i;\n        var len = shapeData.shape.paths._length;\n        var j;\n        var jLen;\n        var addedLength = 0;\n        var currentLengthData;\n        var segmentCount;\n        var lengths;\n        var segment;\n        var shapes = [];\n        var initPos;\n        var newShape = true;\n        if (!shapePath) {\n            shapePath = shapePool.newElement();\n            segmentCount = 0;\n            initPos = 0;\n        } else {\n            segmentCount = shapePath._length;\n            initPos = shapePath._length;\n        }\n        shapes.push(shapePath);\n        for(i = 0; i < len; i += 1){\n            lengths = pathsData[i].lengths;\n            shapePath.c = shapePaths[i].c;\n            jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\n            for(j = 1; j < jLen; j += 1){\n                currentLengthData = lengths[j - 1];\n                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n                    addedLength += currentLengthData.addedLength;\n                    shapePath.c = false;\n                } else if (addedLength > shapeSegment.e) {\n                    shapePath.c = false;\n                    break;\n                } else {\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                    addedLength += currentLengthData.addedLength;\n                    segmentCount += 1;\n                }\n            }\n            if (shapePaths[i].c && lengths.length) {\n                currentLengthData = lengths[j - 1];\n                if (addedLength <= shapeSegment.e) {\n                    var segmentLength = lengths[j - 1].addedLength;\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape); // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                } else {\n                    shapePath.c = false;\n                }\n                addedLength += currentLengthData.addedLength;\n                segmentCount += 1;\n            }\n            if (shapePath._length) {\n                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], \"i\", initPos);\n                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], \"o\", shapePath._length - 1);\n            }\n            if (addedLength > shapeSegment.e) {\n                break;\n            }\n            if (i < len - 1) {\n                shapePath = shapePool.newElement();\n                newShape = true;\n                shapes.push(shapePath);\n                segmentCount = 0;\n            }\n        }\n        return shapes;\n    };\n    function PuckerAndBloatModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], PuckerAndBloatModifier);\n    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this._isAnimated = !!this.amount.effectsSequence.length;\n    };\n    PuckerAndBloatModifier.prototype.processPath = function(path, amount) {\n        var percent = amount / 100;\n        var centerPoint = [\n            0,\n            0\n        ];\n        var pathLength = path._length;\n        var i = 0;\n        for(i = 0; i < pathLength; i += 1){\n            centerPoint[0] += path.v[i][0];\n            centerPoint[1] += path.v[i][1];\n        }\n        centerPoint[0] /= pathLength;\n        centerPoint[1] /= pathLength;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < pathLength; i += 1){\n            vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;\n            vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;\n            oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;\n            oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;\n            iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;\n            iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;\n            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);\n        }\n        return clonedPath;\n    };\n    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    var TransformPropertyFactory = function() {\n        var defaultVector = [\n            0,\n            0\n        ];\n        function applyToMatrix(mat) {\n            var _mdf = this._mdf;\n            this.iterateDynamicProperties();\n            this._mdf = this._mdf || _mdf;\n            if (this.a) {\n                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n            }\n            if (this.s) {\n                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n            }\n            if (this.sk) {\n                mat.skewFromAxis(-this.sk.v, this.sa.v);\n            }\n            if (this.r) {\n                mat.rotate(-this.r.v);\n            } else {\n                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n            }\n            if (this.data.p.s) {\n                if (this.data.p.z) {\n                    mat.translate(this.px.v, this.py.v, -this.pz.v);\n                } else {\n                    mat.translate(this.px.v, this.py.v, 0);\n                }\n            } else {\n                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n            }\n        }\n        function processKeys(forceRender) {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (this._isDirty) {\n                this.precalculateMatrix();\n                this._isDirty = false;\n            }\n            this.iterateDynamicProperties();\n            if (this._mdf || forceRender) {\n                var frameRate;\n                this.v.cloneFromProps(this.pre.props);\n                if (this.appliedTransformations < 1) {\n                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                }\n                if (this.appliedTransformations < 2) {\n                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                }\n                if (this.sk && this.appliedTransformations < 3) {\n                    this.v.skewFromAxis(-this.sk.v, this.sa.v);\n                }\n                if (this.r && this.appliedTransformations < 4) {\n                    this.v.rotate(-this.r.v);\n                } else if (!this.r && this.appliedTransformations < 4) {\n                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                }\n                if (this.autoOriented) {\n                    var v1;\n                    var v2;\n                    frameRate = this.elem.globalData.frameRate;\n                    if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n                        if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n                            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\n                        } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\n                            v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);\n                            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);\n                        } else {\n                            v1 = this.p.pv;\n                            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\n                        }\n                    } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\n                        v1 = [];\n                        v2 = [];\n                        var px = this.px;\n                        var py = this.py;\n                        if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n                            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);\n                            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);\n                            v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);\n                        } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n                            v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);\n                            v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);\n                            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                        } else {\n                            v1 = [\n                                px.pv,\n                                py.pv\n                            ];\n                            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);\n                            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);\n                        }\n                    } else {\n                        v2 = defaultVector;\n                        v1 = v2;\n                    }\n                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\n                }\n                if (this.data.p && this.data.p.s) {\n                    if (this.data.p.z) {\n                        this.v.translate(this.px.v, this.py.v, -this.pz.v);\n                    } else {\n                        this.v.translate(this.px.v, this.py.v, 0);\n                    }\n                } else {\n                    this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n                }\n            }\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function precalculateMatrix() {\n            this.appliedTransformations = 0;\n            this.pre.reset();\n            if (!this.a.effectsSequence.length) {\n                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                this.appliedTransformations = 1;\n            } else {\n                return;\n            }\n            if (!this.s.effectsSequence.length) {\n                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                this.appliedTransformations = 2;\n            } else {\n                return;\n            }\n            if (this.sk) {\n                if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);\n                    this.appliedTransformations = 3;\n                } else {\n                    return;\n                }\n            }\n            if (this.r) {\n                if (!this.r.effectsSequence.length) {\n                    this.pre.rotate(-this.r.v);\n                    this.appliedTransformations = 4;\n                }\n            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\n                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                this.appliedTransformations = 4;\n            }\n        }\n        function autoOrient() {\n        // var prevP = this.getValueAtTime();\n        }\n        function addDynamicProperty(prop) {\n            this._addDynamicProperty(prop);\n            this.elem.addDynamicProperty(prop);\n            this._isDirty = true;\n        }\n        function TransformProperty(elem, data, container) {\n            this.elem = elem;\n            this.frameId = -1;\n            this.propType = \"transform\";\n            this.data = data;\n            this.v = new Matrix(); // Precalculated matrix with non animated properties\n            this.pre = new Matrix();\n            this.appliedTransformations = 0;\n            this.initDynamicPropertyContainer(container || elem);\n            if (data.p && data.p.s) {\n                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);\n                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);\n                if (data.p.z) {\n                    this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);\n                }\n            } else {\n                this.p = PropertyFactory.getProp(elem, data.p || {\n                    k: [\n                        0,\n                        0,\n                        0\n                    ]\n                }, 1, 0, this);\n            }\n            if (data.rx) {\n                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\n                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\n                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\n                if (data.or.k[0].ti) {\n                    var i;\n                    var len = data.or.k.length;\n                    for(i = 0; i < len; i += 1){\n                        data.or.k[i].to = null;\n                        data.or.k[i].ti = null;\n                    }\n                }\n                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this); // sh Indicates it needs to be capped between -180 and 180\n                this.or.sh = true;\n            } else {\n                this.r = PropertyFactory.getProp(elem, data.r || {\n                    k: 0\n                }, 0, degToRads, this);\n            }\n            if (data.sk) {\n                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\n                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\n            }\n            this.a = PropertyFactory.getProp(elem, data.a || {\n                k: [\n                    0,\n                    0,\n                    0\n                ]\n            }, 1, 0, this);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: [\n                    100,\n                    100,\n                    100\n                ]\n            }, 1, 0.01, this); // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n            if (data.o) {\n                this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);\n            } else {\n                this.o = {\n                    _mdf: false,\n                    v: 1\n                };\n            }\n            this._isDirty = true;\n            if (!this.dynamicProperties.length) {\n                this.getValue(true);\n            }\n        }\n        TransformProperty.prototype = {\n            applyToMatrix: applyToMatrix,\n            getValue: processKeys,\n            precalculateMatrix: precalculateMatrix,\n            autoOrient: autoOrient\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TransformProperty);\n        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\n        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\n        function getTransformProperty(elem, data, container) {\n            return new TransformProperty(elem, data, container);\n        }\n        return {\n            getTransformProperty: getTransformProperty\n        };\n    }();\n    function RepeaterModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RepeaterModifier);\n    RepeaterModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);\n        this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);\n        this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);\n        this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);\n        this.data = data;\n        if (!this.dynamicProperties.length) {\n            this.getValue(true);\n        }\n        this._isAnimated = !!this.dynamicProperties.length;\n        this.pMatrix = new Matrix();\n        this.rMatrix = new Matrix();\n        this.sMatrix = new Matrix();\n        this.tMatrix = new Matrix();\n        this.matrix = new Matrix();\n    };\n    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n        var dir = inv ? -1 : 1;\n        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\n        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\n        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\n        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        rMatrix.rotate(-transform.r.v * dir * perc);\n        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);\n        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n    };\n    RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {\n        this.elem = elem;\n        this.arr = arr;\n        this.pos = pos;\n        this.elemsData = elemsData;\n        this._currentCopies = 0;\n        this._elements = [];\n        this._groups = [];\n        this.frameId = -1;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, arr[pos]);\n        while(pos > 0){\n            pos -= 1; // this._elements.unshift(arr.splice(pos,1)[0]);\n            this._elements.unshift(arr[pos]);\n        }\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    RepeaterModifier.prototype.resetElements = function(elements) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._processed = false;\n            if (elements[i].ty === \"gr\") {\n                this.resetElements(elements[i].it);\n            }\n        }\n    };\n    RepeaterModifier.prototype.cloneElements = function(elements) {\n        var newElements = JSON.parse(JSON.stringify(elements));\n        this.resetElements(newElements);\n        return newElements;\n    };\n    RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._render = renderFlag;\n            if (elements[i].ty === \"gr\") {\n                this.changeGroupRender(elements[i].it, renderFlag);\n            }\n        }\n    };\n    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {\n        var items;\n        var itemsTransform;\n        var i;\n        var dir;\n        var cont;\n        var hasReloaded = false;\n        if (this._mdf || _isFirstFrame) {\n            var copies = Math.ceil(this.c.v);\n            if (this._groups.length < copies) {\n                while(this._groups.length < copies){\n                    var group = {\n                        it: this.cloneElements(this._elements),\n                        ty: \"gr\"\n                    };\n                    group.it.push({\n                        a: {\n                            a: 0,\n                            ix: 1,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        nm: \"Transform\",\n                        o: {\n                            a: 0,\n                            ix: 7,\n                            k: 100\n                        },\n                        p: {\n                            a: 0,\n                            ix: 2,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        r: {\n                            a: 1,\n                            ix: 6,\n                            k: [\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 0\n                                },\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 1\n                                }\n                            ]\n                        },\n                        s: {\n                            a: 0,\n                            ix: 3,\n                            k: [\n                                100,\n                                100\n                            ]\n                        },\n                        sa: {\n                            a: 0,\n                            ix: 5,\n                            k: 0\n                        },\n                        sk: {\n                            a: 0,\n                            ix: 4,\n                            k: 0\n                        },\n                        ty: \"tr\"\n                    });\n                    this.arr.splice(0, 0, group);\n                    this._groups.splice(0, 0, group);\n                    this._currentCopies += 1;\n                }\n                this.elem.reloadShapes();\n                hasReloaded = true;\n            }\n            cont = 0;\n            var renderFlag;\n            for(i = 0; i <= this._groups.length - 1; i += 1){\n                renderFlag = cont < copies;\n                this._groups[i]._render = renderFlag;\n                this.changeGroupRender(this._groups[i].it, renderFlag);\n                if (!renderFlag) {\n                    var elems = this.elemsData[i].it;\n                    var transformData = elems[elems.length - 1];\n                    if (transformData.transform.op.v !== 0) {\n                        transformData.transform.op._mdf = true;\n                        transformData.transform.op.v = 0;\n                    } else {\n                        transformData.transform.op._mdf = false;\n                    }\n                }\n                cont += 1;\n            }\n            this._currentCopies = copies; /// /\n            var offset = this.o.v;\n            var offsetModulo = offset % 1;\n            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n            var pProps = this.pMatrix.props;\n            var rProps = this.rMatrix.props;\n            var sProps = this.sMatrix.props;\n            this.pMatrix.reset();\n            this.rMatrix.reset();\n            this.sMatrix.reset();\n            this.tMatrix.reset();\n            this.matrix.reset();\n            var iteration = 0;\n            if (offset > 0) {\n                while(iteration < roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    iteration += 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\n                    iteration += offsetModulo;\n                }\n            } else if (offset < 0) {\n                while(iteration > roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\n                    iteration -= 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);\n                    iteration -= offsetModulo;\n                }\n            }\n            i = this.data.m === 1 ? 0 : this._currentCopies - 1;\n            dir = this.data.m === 1 ? 1 : -1;\n            cont = this._currentCopies;\n            var j;\n            var jLen;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                jLen = itemsTransform.length;\n                items[items.length - 1].transform.mProps._mdf = true;\n                items[items.length - 1].transform.op._mdf = true;\n                items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\n                if (iteration !== 0) {\n                    if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {\n                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    }\n                    this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);\n                    this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);\n                    this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                    this.matrix.reset();\n                } else {\n                    this.matrix.reset();\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                }\n                iteration += 1;\n                cont -= 1;\n                i += dir;\n            }\n        } else {\n            cont = this._currentCopies;\n            i = 0;\n            dir = 1;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                items[items.length - 1].transform.mProps._mdf = false;\n                items[items.length - 1].transform.op._mdf = false;\n                cont -= 1;\n                i += dir;\n            }\n        }\n        return hasReloaded;\n    };\n    RepeaterModifier.prototype.addShape = function() {};\n    function RoundCornersModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RoundCornersModifier);\n    RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this._isAnimated = !!this.rd.effectsSequence.length;\n    };\n    RoundCornersModifier.prototype.processPath = function(path, round) {\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var i;\n        var len = path._length;\n        var currentV;\n        var currentI;\n        var currentO;\n        var closerV;\n        var distance;\n        var newPosPerc;\n        var index = 0;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < len; i += 1){\n            currentV = path.v[i];\n            currentO = path.o[i];\n            currentI = path.i[i];\n            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {\n                if ((i === 0 || i === len - 1) && !path.c) {\n                    clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);\n                    /* clonedPath.v[index] = currentV;\r\n                  clonedPath.o[index] = currentO;\r\n                  clonedPath.i[index] = currentI; */ index += 1;\n                } else {\n                    if (i === 0) {\n                        closerV = path.v[len - 1];\n                    } else {\n                        closerV = path.v[i - 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = iX;\n                    iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;\n                    vY = iY;\n                    oX = vX - (vX - currentV[0]) * roundCorner;\n                    oY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                    if (i === len - 1) {\n                        closerV = path.v[0];\n                    } else {\n                        closerV = path.v[i + 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = oX;\n                    oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;\n                    vY = oY;\n                    iX = vX - (vX - currentV[0]) * roundCorner;\n                    iY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                }\n            } else {\n                clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);\n                index += 1;\n            }\n        }\n        return clonedPath;\n    };\n    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var rd = this.rd.v;\n        if (rd !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], rd));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function floatEqual(a, b) {\n        return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));\n    }\n    function floatZero(f) {\n        return Math.abs(f) <= 0.00001;\n    }\n    function lerp(p0, p1, amount) {\n        return p0 * (1 - amount) + p1 * amount;\n    }\n    function lerpPoint(p0, p1, amount) {\n        return [\n            lerp(p0[0], p1[0], amount),\n            lerp(p0[1], p1[1], amount)\n        ];\n    }\n    function quadRoots(a, b, c) {\n        // no root\n        if (a === 0) return [];\n        var s = b * b - 4 * a * c; // Complex roots\n        if (s < 0) return [];\n        var singleRoot = -b / (2 * a); // 1 root\n        if (s === 0) return [\n            singleRoot\n        ];\n        var delta = Math.sqrt(s) / (2 * a); // 2 roots\n        return [\n            singleRoot - delta,\n            singleRoot + delta\n        ];\n    }\n    function polynomialCoefficients(p0, p1, p2, p3) {\n        return [\n            -p0 + 3 * p1 - 3 * p2 + p3,\n            3 * p0 - 6 * p1 + 3 * p2,\n            -3 * p0 + 3 * p1,\n            p0\n        ];\n    }\n    function singlePoint(p) {\n        return new PolynomialBezier(p, p, p, p, false);\n    }\n    function PolynomialBezier(p0, p1, p2, p3, linearize) {\n        if (linearize && pointEqual(p0, p1)) {\n            p1 = lerpPoint(p0, p3, 1 / 3);\n        }\n        if (linearize && pointEqual(p2, p3)) {\n            p2 = lerpPoint(p0, p3, 2 / 3);\n        }\n        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);\n        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);\n        this.a = [\n            coeffx[0],\n            coeffy[0]\n        ];\n        this.b = [\n            coeffx[1],\n            coeffy[1]\n        ];\n        this.c = [\n            coeffx[2],\n            coeffy[2]\n        ];\n        this.d = [\n            coeffx[3],\n            coeffy[3]\n        ];\n        this.points = [\n            p0,\n            p1,\n            p2,\n            p3\n        ];\n    }\n    PolynomialBezier.prototype.point = function(t) {\n        return [\n            ((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0],\n            ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]\n        ];\n    };\n    PolynomialBezier.prototype.derivative = function(t) {\n        return [\n            (3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0],\n            (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]\n        ];\n    };\n    PolynomialBezier.prototype.tangentAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[1], p[0]);\n    };\n    PolynomialBezier.prototype.normalAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[0], p[1]);\n    };\n    PolynomialBezier.prototype.inflectionPoints = function() {\n        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];\n        if (floatZero(denom)) return [];\n        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;\n        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;\n        if (square < 0) return [];\n        var root = Math.sqrt(square);\n        if (floatZero(root)) {\n            if (root > 0 && root < 1) return [\n                tcusp\n            ];\n            return [];\n        }\n        return [\n            tcusp - root,\n            tcusp + root\n        ].filter(function(r) {\n            return r > 0 && r < 1;\n        });\n    };\n    PolynomialBezier.prototype.split = function(t) {\n        if (t <= 0) return [\n            singlePoint(this.points[0]),\n            this\n        ];\n        if (t >= 1) return [\n            this,\n            singlePoint(this.points[this.points.length - 1])\n        ];\n        var p10 = lerpPoint(this.points[0], this.points[1], t);\n        var p11 = lerpPoint(this.points[1], this.points[2], t);\n        var p12 = lerpPoint(this.points[2], this.points[3], t);\n        var p20 = lerpPoint(p10, p11, t);\n        var p21 = lerpPoint(p11, p12, t);\n        var p3 = lerpPoint(p20, p21, t);\n        return [\n            new PolynomialBezier(this.points[0], p10, p20, p3, true),\n            new PolynomialBezier(p3, p21, p12, this.points[3], true)\n        ];\n    };\n    function extrema(bez, comp) {\n        var min = bez.points[0][comp];\n        var max = bez.points[bez.points.length - 1][comp];\n        if (min > max) {\n            var e = max;\n            max = min;\n            min = e;\n        } // Derivative roots to find min/max\n        var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);\n        for(var i = 0; i < f.length; i += 1){\n            if (f[i] > 0 && f[i] < 1) {\n                var val = bez.point(f[i])[comp];\n                if (val < min) min = val;\n                else if (val > max) max = val;\n            }\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    PolynomialBezier.prototype.bounds = function() {\n        return {\n            x: extrema(this, 0),\n            y: extrema(this, 1)\n        };\n    };\n    PolynomialBezier.prototype.boundingBox = function() {\n        var bounds = this.bounds();\n        return {\n            left: bounds.x.min,\n            right: bounds.x.max,\n            top: bounds.y.min,\n            bottom: bounds.y.max,\n            width: bounds.x.max - bounds.x.min,\n            height: bounds.y.max - bounds.y.min,\n            cx: (bounds.x.max + bounds.x.min) / 2,\n            cy: (bounds.y.max + bounds.y.min) / 2\n        };\n    };\n    function intersectData(bez, t1, t2) {\n        var box = bez.boundingBox();\n        return {\n            cx: box.cx,\n            cy: box.cy,\n            width: box.width,\n            height: box.height,\n            bez: bez,\n            t: (t1 + t2) / 2,\n            t1: t1,\n            t2: t2\n        };\n    }\n    function splitData(data) {\n        var split = data.bez.split(0.5);\n        return [\n            intersectData(split[0], data.t1, data.t),\n            intersectData(split[1], data.t, data.t2)\n        ];\n    }\n    function boxIntersect(b1, b2) {\n        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;\n    }\n    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {\n        if (!boxIntersect(d1, d2)) return;\n        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {\n            intersections.push([\n                d1.t,\n                d2.t\n            ]);\n            return;\n        }\n        var d1s = splitData(d1);\n        var d2s = splitData(d2);\n        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n    }\n    PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {\n        if (tolerance === undefined) tolerance = 2;\n        if (maxRecursion === undefined) maxRecursion = 7;\n        var intersections = [];\n        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);\n        return intersections;\n    };\n    PolynomialBezier.shapeSegment = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);\n    };\n    PolynomialBezier.shapeSegmentInverted = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);\n    };\n    function crossProduct(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    }\n    function lineIntersection(start1, end1, start2, end2) {\n        var v1 = [\n            start1[0],\n            start1[1],\n            1\n        ];\n        var v2 = [\n            end1[0],\n            end1[1],\n            1\n        ];\n        var v3 = [\n            start2[0],\n            start2[1],\n            1\n        ];\n        var v4 = [\n            end2[0],\n            end2[1],\n            1\n        ];\n        var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));\n        if (floatZero(r[2])) return null;\n        return [\n            r[0] / r[2],\n            r[1] / r[2]\n        ];\n    }\n    function polarOffset(p, angle, length) {\n        return [\n            p[0] + Math.cos(angle) * length,\n            p[1] - Math.sin(angle) * length\n        ];\n    }\n    function pointDistance(p1, p2) {\n        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);\n    }\n    function pointEqual(p1, p2) {\n        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);\n    }\n    function ZigZagModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], ZigZagModifier);\n    ZigZagModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);\n        this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);\n        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;\n    };\n    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {\n        var angO = angle - Math.PI / 2;\n        var angI = angle + Math.PI / 2;\n        var px = point[0] + Math.cos(angle) * direction * amplitude;\n        var py = point[1] - Math.sin(angle) * direction * amplitude;\n        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());\n    }\n    function getPerpendicularVector(pt1, pt2) {\n        var vector = [\n            pt2[0] - pt1[0],\n            pt2[1] - pt1[1]\n        ];\n        var rot = -Math.PI * 0.5;\n        var rotatedVector = [\n            Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1],\n            Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]\n        ];\n        return rotatedVector;\n    }\n    function getProjectingAngle(path, cur) {\n        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;\n        var nextIndex = (cur + 1) % path.length();\n        var prevPoint = path.v[prevIndex];\n        var nextPoint = path.v[nextIndex];\n        var pVector = getPerpendicularVector(prevPoint, nextPoint);\n        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);\n    }\n    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {\n        var angle = getProjectingAngle(path, cur);\n        var point = path.v[cur % path._length];\n        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];\n        var nextPoint = path.v[(cur + 1) % path._length];\n        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;\n        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;\n        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);\n    }\n    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {\n        for(var i = 0; i < frequency; i += 1){\n            var t = (i + 1) / (frequency + 1);\n            var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;\n            var angle = segment.normalAngle(t);\n            var point = segment.point(t);\n            setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);\n            direction = -direction;\n        }\n        return direction;\n    }\n    ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {\n        var count = path._length;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        if (!path.c) {\n            count -= 1;\n        }\n        if (count === 0) return clonedPath;\n        var direction = -1;\n        var segment = PolynomialBezier.shapeSegment(path, 0);\n        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);\n        for(var i = 0; i < count; i += 1){\n            direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);\n            if (i === count - 1 && !path.c) {\n                segment = null;\n            } else {\n                segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);\n            }\n            zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);\n        }\n        return clonedPath;\n    };\n    ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amplitude = this.amplitude.v;\n        var frequency = Math.max(0, Math.round(this.frequency.v));\n        var pointType = this.pointsType.v;\n        if (amplitude !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function linearOffset(p1, p2, amount) {\n        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);\n        return [\n            polarOffset(p1, angle, amount),\n            polarOffset(p2, angle, amount)\n        ];\n    }\n    function offsetSegment(segment, amount) {\n        var p0;\n        var p1a;\n        var p1b;\n        var p2b;\n        var p2a;\n        var p3;\n        var e;\n        e = linearOffset(segment.points[0], segment.points[1], amount);\n        p0 = e[0];\n        p1a = e[1];\n        e = linearOffset(segment.points[1], segment.points[2], amount);\n        p1b = e[0];\n        p2b = e[1];\n        e = linearOffset(segment.points[2], segment.points[3], amount);\n        p2a = e[0];\n        p3 = e[1];\n        var p1 = lineIntersection(p0, p1a, p1b, p2b);\n        if (p1 === null) p1 = p1a;\n        var p2 = lineIntersection(p2a, p3, p1b, p2b);\n        if (p2 === null) p2 = p2a;\n        return new PolynomialBezier(p0, p1, p2, p3);\n    }\n    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {\n        var p0 = seg1.points[3];\n        var p1 = seg2.points[0]; // Bevel\n        if (lineJoin === 3) return p0; // Connected, they don't need a joint\n        if (pointEqual(p0, p1)) return p0; // Round\n        if (lineJoin === 2) {\n            var angleOut = -seg1.tangentAngle(1);\n            var angleIn = -seg2.tangentAngle(0) + Math.PI;\n            var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));\n            var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;\n            var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);\n            outputBezier.setXYAt(tan[0], tan[1], \"o\", outputBezier.length() - 1);\n            tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);\n            outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());\n            return p1;\n        } // Miter\n        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];\n        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];\n        var intersection = lineIntersection(t0, p0, p1, t1);\n        if (intersection && pointDistance(intersection, p0) < miterLimit) {\n            outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());\n            return intersection;\n        }\n        return p0;\n    }\n    function getIntersection(a, b) {\n        var intersect = a.intersections(b);\n        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();\n        if (intersect.length) return intersect[0];\n        return null;\n    }\n    function pruneSegmentIntersection(a, b) {\n        var outa = a.slice();\n        var outb = b.slice();\n        var intersect = getIntersection(a[a.length - 1], b[0]);\n        if (intersect) {\n            outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];\n            outb[0] = b[0].split(intersect[1])[1];\n        }\n        if (a.length > 1 && b.length > 1) {\n            intersect = getIntersection(a[0], b[b.length - 1]);\n            if (intersect) {\n                return [\n                    [\n                        a[0].split(intersect[0])[0]\n                    ],\n                    [\n                        b[b.length - 1].split(intersect[1])[1]\n                    ]\n                ];\n            }\n        }\n        return [\n            outa,\n            outb\n        ];\n    }\n    function pruneIntersections(segments) {\n        var e;\n        for(var i = 1; i < segments.length; i += 1){\n            e = pruneSegmentIntersection(segments[i - 1], segments[i]);\n            segments[i - 1] = e[0];\n            segments[i] = e[1];\n        }\n        if (segments.length > 1) {\n            e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);\n            segments[segments.length - 1] = e[0];\n            segments[0] = e[1];\n        }\n        return segments;\n    }\n    function offsetSegmentSplit(segment, amount) {\n        /*\r\n      We split each bezier segment into smaller pieces based\r\n      on inflection points, this ensures the control point\r\n      polygon is convex.\r\n        (A cubic bezier can have none, one, or two inflection points)\r\n    */ var flex = segment.inflectionPoints();\n        var left;\n        var right;\n        var split;\n        var mid;\n        if (flex.length === 0) {\n            return [\n                offsetSegment(segment, amount)\n            ];\n        }\n        if (flex.length === 1 || floatEqual(flex[1], 1)) {\n            split = segment.split(flex[0]);\n            left = split[0];\n            right = split[1];\n            return [\n                offsetSegment(left, amount),\n                offsetSegment(right, amount)\n            ];\n        }\n        split = segment.split(flex[0]);\n        left = split[0];\n        var t = (flex[1] - flex[0]) / (1 - flex[0]);\n        split = split[1].split(t);\n        mid = split[0];\n        right = split[1];\n        return [\n            offsetSegment(left, amount),\n            offsetSegment(mid, amount),\n            offsetSegment(right, amount)\n        ];\n    }\n    function OffsetPathModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], OffsetPathModifier);\n    OffsetPathModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);\n        this.lineJoin = data.lj;\n        this._isAnimated = this.amount.effectsSequence.length !== 0;\n    };\n    OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {\n        var outputBezier = shapePool.newElement();\n        outputBezier.c = inputBezier.c;\n        var count = inputBezier.length();\n        if (!inputBezier.c) {\n            count -= 1;\n        }\n        var i;\n        var j;\n        var segment;\n        var multiSegments = [];\n        for(i = 0; i < count; i += 1){\n            segment = PolynomialBezier.shapeSegment(inputBezier, i);\n            multiSegments.push(offsetSegmentSplit(segment, amount));\n        }\n        if (!inputBezier.c) {\n            for(i = count - 1; i >= 0; i -= 1){\n                segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);\n                multiSegments.push(offsetSegmentSplit(segment, amount));\n            }\n        }\n        multiSegments = pruneIntersections(multiSegments); // Add bezier segments to the output and apply line joints\n        var lastPoint = null;\n        var lastSeg = null;\n        for(i = 0; i < multiSegments.length; i += 1){\n            var multiSegment = multiSegments[i];\n            if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);\n            lastSeg = multiSegment[multiSegment.length - 1];\n            for(j = 0; j < multiSegment.length; j += 1){\n                segment = multiSegment[j];\n                if (lastPoint && pointEqual(segment.points[0], lastPoint)) {\n                    outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], \"o\", outputBezier.length() - 1);\n                } else {\n                    outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());\n                }\n                outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());\n                lastPoint = segment.points[3];\n            }\n        }\n        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);\n        return outputBezier;\n    };\n    OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        var miterLimit = this.miterLimit.v;\n        var lineJoin = this.lineJoin;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function getFontProperties(fontData) {\n        var styles = fontData.fStyle ? fontData.fStyle.split(\" \") : [];\n        var fWeight = \"normal\";\n        var fStyle = \"normal\";\n        var len = styles.length;\n        var styleName;\n        for(var i = 0; i < len; i += 1){\n            styleName = styles[i].toLowerCase();\n            switch(styleName){\n                case \"italic\":\n                    fStyle = \"italic\";\n                    break;\n                case \"bold\":\n                    fWeight = \"700\";\n                    break;\n                case \"black\":\n                    fWeight = \"900\";\n                    break;\n                case \"medium\":\n                    fWeight = \"500\";\n                    break;\n                case \"regular\":\n                case \"normal\":\n                    fWeight = \"400\";\n                    break;\n                case \"light\":\n                case \"thin\":\n                    fWeight = \"200\";\n                    break;\n                default:\n                    break;\n            }\n        }\n        return {\n            style: fStyle,\n            weight: fontData.fWeight || fWeight\n        };\n    }\n    var FontManager = function() {\n        var maxWaitingTime = 5000;\n        var emptyChar = {\n            w: 0,\n            size: 0,\n            shapes: [],\n            data: {\n                shapes: []\n            }\n        };\n        var combinedCharacters = []; // Hindi characters\n        combinedCharacters = combinedCharacters.concat([\n            2304,\n            2305,\n            2306,\n            2307,\n            2362,\n            2363,\n            2364,\n            2364,\n            2366,\n            2367,\n            2368,\n            2369,\n            2370,\n            2371,\n            2372,\n            2373,\n            2374,\n            2375,\n            2376,\n            2377,\n            2378,\n            2379,\n            2380,\n            2381,\n            2382,\n            2383,\n            2387,\n            2388,\n            2389,\n            2390,\n            2391,\n            2402,\n            2403\n        ]);\n        var BLACK_FLAG_CODE_POINT = 127988;\n        var CANCEL_TAG_CODE_POINT = 917631;\n        var A_TAG_CODE_POINT = 917601;\n        var Z_TAG_CODE_POINT = 917626;\n        var VARIATION_SELECTOR_16_CODE_POINT = 65039;\n        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;\n        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;\n        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;\n        var surrogateModifiers = [\n            \"d83cdffb\",\n            \"d83cdffc\",\n            \"d83cdffd\",\n            \"d83cdffe\",\n            \"d83cdfff\"\n        ];\n        function trimFontOptions(font) {\n            var familyArray = font.split(\",\");\n            var i;\n            var len = familyArray.length;\n            var enabledFamilies = [];\n            for(i = 0; i < len; i += 1){\n                if (familyArray[i] !== \"sans-serif\" && familyArray[i] !== \"monospace\") {\n                    enabledFamilies.push(familyArray[i]);\n                }\n            }\n            return enabledFamilies.join(\",\");\n        }\n        function setUpNode(font, family) {\n            var parentNode = createTag(\"span\"); // Node is invisible to screen readers.\n            parentNode.setAttribute(\"aria-hidden\", true);\n            parentNode.style.fontFamily = family;\n            var node = createTag(\"span\"); // Characters that vary significantly among different fonts\n            node.innerText = \"giItT1WQy@!-/#\"; // Visible - so we can measure it - but not on the screen\n            parentNode.style.position = \"absolute\";\n            parentNode.style.left = \"-10000px\";\n            parentNode.style.top = \"-10000px\"; // Large font size makes even subtle changes obvious\n            parentNode.style.fontSize = \"300px\"; // Reset any font properties\n            parentNode.style.fontVariant = \"normal\";\n            parentNode.style.fontStyle = \"normal\";\n            parentNode.style.fontWeight = \"normal\";\n            parentNode.style.letterSpacing = \"0\";\n            parentNode.appendChild(node);\n            document.body.appendChild(parentNode); // Remember width with no applied web font\n            var width = node.offsetWidth;\n            node.style.fontFamily = trimFontOptions(font) + \", \" + family;\n            return {\n                node: node,\n                w: width,\n                parent: parentNode\n            };\n        }\n        function checkLoadedFonts() {\n            var i;\n            var len = this.fonts.length;\n            var node;\n            var w;\n            var loadedCount = len;\n            for(i = 0; i < len; i += 1){\n                if (this.fonts[i].loaded) {\n                    loadedCount -= 1;\n                } else if (this.fonts[i].fOrigin === \"n\" || this.fonts[i].origin === 0) {\n                    this.fonts[i].loaded = true;\n                } else {\n                    node = this.fonts[i].monoCase.node;\n                    w = this.fonts[i].monoCase.w;\n                    if (node.offsetWidth !== w) {\n                        loadedCount -= 1;\n                        this.fonts[i].loaded = true;\n                    } else {\n                        node = this.fonts[i].sansCase.node;\n                        w = this.fonts[i].sansCase.w;\n                        if (node.offsetWidth !== w) {\n                            loadedCount -= 1;\n                            this.fonts[i].loaded = true;\n                        }\n                    }\n                    if (this.fonts[i].loaded) {\n                        this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\n                        this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\n                    }\n                }\n            }\n            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n                setTimeout(this.checkLoadedFontsBinded, 20);\n            } else {\n                setTimeout(this.setIsLoadedBinded, 10);\n            }\n        }\n        function createHelper(fontData, def) {\n            var engine = document.body && def ? \"svg\" : \"canvas\";\n            var helper;\n            var fontProps = getFontProperties(fontData);\n            if (engine === \"svg\") {\n                var tHelper = createNS(\"text\");\n                tHelper.style.fontSize = \"100px\"; // tHelper.style.fontFamily = fontData.fFamily;\n                tHelper.setAttribute(\"font-family\", fontData.fFamily);\n                tHelper.setAttribute(\"font-style\", fontProps.style);\n                tHelper.setAttribute(\"font-weight\", fontProps.weight);\n                tHelper.textContent = \"1\";\n                if (fontData.fClass) {\n                    tHelper.style.fontFamily = \"inherit\";\n                    tHelper.setAttribute(\"class\", fontData.fClass);\n                } else {\n                    tHelper.style.fontFamily = fontData.fFamily;\n                }\n                def.appendChild(tHelper);\n                helper = tHelper;\n            } else {\n                var tCanvasHelper = new OffscreenCanvas(500, 500).getContext(\"2d\");\n                tCanvasHelper.font = fontProps.style + \" \" + fontProps.weight + \" 100px \" + fontData.fFamily;\n                helper = tCanvasHelper;\n            }\n            function measure(text) {\n                if (engine === \"svg\") {\n                    helper.textContent = text;\n                    return helper.getComputedTextLength();\n                }\n                return helper.measureText(text).width;\n            }\n            return {\n                measureText: measure\n            };\n        }\n        function addFonts(fontData, defs) {\n            if (!fontData) {\n                this.isLoaded = true;\n                return;\n            }\n            if (this.chars) {\n                this.isLoaded = true;\n                this.fonts = fontData.list;\n                return;\n            }\n            if (!document.body) {\n                this.isLoaded = true;\n                fontData.list.forEach(function(data) {\n                    data.helper = createHelper(data);\n                    data.cache = {};\n                });\n                this.fonts = fontData.list;\n                return;\n            }\n            var fontArr = fontData.list;\n            var i;\n            var len = fontArr.length;\n            var _pendingFonts = len;\n            for(i = 0; i < len; i += 1){\n                var shouldLoadFont = true;\n                var loadedSelector;\n                var j;\n                fontArr[i].loaded = false;\n                fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, \"monospace\");\n                fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, \"sans-serif\");\n                if (!fontArr[i].fPath) {\n                    fontArr[i].loaded = true;\n                    _pendingFonts -= 1;\n                } else if (fontArr[i].fOrigin === \"p\" || fontArr[i].origin === 3) {\n                    loadedSelector = document.querySelectorAll('style[f-forigin=\"p\"][f-family=\"' + fontArr[i].fFamily + '\"], style[f-origin=\"3\"][f-family=\"' + fontArr[i].fFamily + '\"]');\n                    if (loadedSelector.length > 0) {\n                        shouldLoadFont = false;\n                    }\n                    if (shouldLoadFont) {\n                        var s = createTag(\"style\");\n                        s.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        s.setAttribute(\"f-origin\", fontArr[i].origin);\n                        s.setAttribute(\"f-family\", fontArr[i].fFamily);\n                        s.type = \"text/css\";\n                        s.innerText = \"@font-face {font-family: \" + fontArr[i].fFamily + \"; font-style: normal; src: url('\" + fontArr[i].fPath + \"');}\";\n                        defs.appendChild(s);\n                    }\n                } else if (fontArr[i].fOrigin === \"g\" || fontArr[i].origin === 1) {\n                    loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var l = createTag(\"link\");\n                        l.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        l.setAttribute(\"f-origin\", fontArr[i].origin);\n                        l.type = \"text/css\";\n                        l.rel = \"stylesheet\";\n                        l.href = fontArr[i].fPath;\n                        document.body.appendChild(l);\n                    }\n                } else if (fontArr[i].fOrigin === \"t\" || fontArr[i].origin === 2) {\n                    loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (fontArr[i].fPath === loadedSelector[j].src) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var sc = createTag(\"link\");\n                        sc.setAttribute(\"f-forigin\", fontArr[i].fOrigin);\n                        sc.setAttribute(\"f-origin\", fontArr[i].origin);\n                        sc.setAttribute(\"rel\", \"stylesheet\");\n                        sc.setAttribute(\"href\", fontArr[i].fPath);\n                        defs.appendChild(sc);\n                    }\n                }\n                fontArr[i].helper = createHelper(fontArr[i], defs);\n                fontArr[i].cache = {};\n                this.fonts.push(fontArr[i]);\n            }\n            if (_pendingFonts === 0) {\n                this.isLoaded = true;\n            } else {\n                // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n                // Adding this timeout seems to fix it\n                setTimeout(this.checkLoadedFonts.bind(this), 100);\n            }\n        }\n        function addChars(chars) {\n            if (!chars) {\n                return;\n            }\n            if (!this.chars) {\n                this.chars = [];\n            }\n            var i;\n            var len = chars.length;\n            var j;\n            var jLen = this.chars.length;\n            var found;\n            for(i = 0; i < len; i += 1){\n                j = 0;\n                found = false;\n                while(j < jLen){\n                    if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {\n                        found = true;\n                    }\n                    j += 1;\n                }\n                if (!found) {\n                    this.chars.push(chars[i]);\n                    jLen += 1;\n                }\n            }\n        }\n        function getCharData(_char, style, font) {\n            var i = 0;\n            var len = this.chars.length;\n            while(i < len){\n                if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n                    return this.chars[i];\n                }\n                i += 1;\n            }\n            if ((typeof _char === \"string\" && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console\n             && !this._warned) {\n                this._warned = true;\n                console.warn(\"Missing character from exported characters list: \", _char, style, font); // eslint-disable-line no-console\n            }\n            return emptyChar;\n        }\n        function measureText(_char2, fontName, size) {\n            var fontData = this.getFontByName(fontName); // Using the char instead of char.charCodeAt(0)\n            // to avoid collisions between equal chars\n            var index = _char2;\n            if (!fontData.cache[index]) {\n                var tHelper = fontData.helper;\n                if (_char2 === \" \") {\n                    var doubleSize = tHelper.measureText(\"|\" + _char2 + \"|\");\n                    var singleSize = tHelper.measureText(\"||\");\n                    fontData.cache[index] = (doubleSize - singleSize) / 100;\n                } else {\n                    fontData.cache[index] = tHelper.measureText(_char2) / 100;\n                }\n            }\n            return fontData.cache[index] * size;\n        }\n        function getFontByName(name) {\n            var i = 0;\n            var len = this.fonts.length;\n            while(i < len){\n                if (this.fonts[i].fName === name) {\n                    return this.fonts[i];\n                }\n                i += 1;\n            }\n            return this.fonts[0];\n        }\n        function getCodePoint(string) {\n            var codePoint = 0;\n            var first = string.charCodeAt(0);\n            if (first >= 0xD800 && first <= 0xDBFF) {\n                var second = string.charCodeAt(1);\n                if (second >= 0xDC00 && second <= 0xDFFF) {\n                    codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n                }\n            }\n            return codePoint;\n        } // Skin tone modifiers\n        function isModifier(firstCharCode, secondCharCode) {\n            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);\n            return surrogateModifiers.indexOf(sum) !== -1;\n        }\n        function isZeroWidthJoiner(charCode) {\n            return charCode === ZERO_WIDTH_JOINER_CODE_POINT;\n        } // This codepoint may change the appearance of the preceding character.\n        // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered\n        // as a colorful image as compared to a monochrome text variant.\n        function isVariationSelector(charCode) {\n            return charCode === VARIATION_SELECTOR_16_CODE_POINT;\n        } // The regional indicator symbols are a set of 26 alphabetic Unicode\n        /// characters (AZ) intended to be used to encode ISO 3166-1 alpha-2\n        // two-letter country codes in a way that allows optional special treatment.\n        function isRegionalCode(string) {\n            var codePoint = getCodePoint(string);\n            if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {\n                return true;\n            }\n            return false;\n        } // Some Emoji implementations represent combinations of\n        // two regional indicator letters as a single flag symbol.\n        function isFlagEmoji(string) {\n            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));\n        }\n        function isCombinedCharacter(_char3) {\n            return combinedCharacters.indexOf(_char3) !== -1;\n        } // Regional flags start with a BLACK_FLAG_CODE_POINT\n        // folowed by 5 chars in the TAG range\n        // and end with a CANCEL_TAG_CODE_POINT\n        function isRegionalFlag(text, index) {\n            var codePoint = getCodePoint(text.substr(index, 2));\n            if (codePoint !== BLACK_FLAG_CODE_POINT) {\n                return false;\n            }\n            var count = 0;\n            index += 2;\n            while(count < 5){\n                codePoint = getCodePoint(text.substr(index, 2));\n                if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {\n                    return false;\n                }\n                count += 1;\n                index += 2;\n            }\n            return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;\n        }\n        function setIsLoaded() {\n            this.isLoaded = true;\n        }\n        var Font = function Font() {\n            this.fonts = [];\n            this.chars = null;\n            this.typekitLoaded = 0;\n            this.isLoaded = false;\n            this._warned = false;\n            this.initTime = Date.now();\n            this.setIsLoadedBinded = this.setIsLoaded.bind(this);\n            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);\n        };\n        Font.isModifier = isModifier;\n        Font.isZeroWidthJoiner = isZeroWidthJoiner;\n        Font.isFlagEmoji = isFlagEmoji;\n        Font.isRegionalCode = isRegionalCode;\n        Font.isCombinedCharacter = isCombinedCharacter;\n        Font.isRegionalFlag = isRegionalFlag;\n        Font.isVariationSelector = isVariationSelector;\n        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;\n        var fontPrototype = {\n            addChars: addChars,\n            addFonts: addFonts,\n            getCharData: getCharData,\n            getFontByName: getFontByName,\n            measureText: measureText,\n            checkLoadedFonts: checkLoadedFonts,\n            setIsLoaded: setIsLoaded\n        };\n        Font.prototype = fontPrototype;\n        return Font;\n    }();\n    function SlotManager(animationData) {\n        this.animationData = animationData;\n    }\n    SlotManager.prototype.getProp = function(data) {\n        if (this.animationData.slots && this.animationData.slots[data.sid]) {\n            return Object.assign(data, this.animationData.slots[data.sid].p);\n        }\n        return data;\n    };\n    function slotFactory(animationData) {\n        return new SlotManager(animationData);\n    }\n    function RenderableElement() {}\n    RenderableElement.prototype = {\n        initRenderable: function initRenderable() {\n            // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n            this.isInRange = false; // layer's display state\n            this.hidden = false; // If layer's transparency equals 0, it can be hidden\n            this.isTransparent = false; // list of animated components\n            this.renderableComponents = [];\n        },\n        addRenderableComponent: function addRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) === -1) {\n                this.renderableComponents.push(component);\n            }\n        },\n        removeRenderableComponent: function removeRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) !== -1) {\n                this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\n            }\n        },\n        prepareRenderableFrame: function prepareRenderableFrame(num) {\n            this.checkLayerLimits(num);\n        },\n        checkTransparency: function checkTransparency() {\n            if (this.finalTransform.mProp.o.v <= 0) {\n                if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n                    this.isTransparent = true;\n                    this.hide();\n                }\n            } else if (this.isTransparent) {\n                this.isTransparent = false;\n                this.show();\n            }\n        },\n        /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       *\r\n       */ checkLayerLimits: function checkLayerLimits(num) {\n            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n                if (this.isInRange !== true) {\n                    this.globalData._mdf = true;\n                    this._mdf = true;\n                    this.isInRange = true;\n                    this.show();\n                }\n            } else if (this.isInRange !== false) {\n                this.globalData._mdf = true;\n                this.isInRange = false;\n                this.hide();\n            }\n        },\n        renderRenderable: function renderRenderable() {\n            var i;\n            var len = this.renderableComponents.length;\n            for(i = 0; i < len; i += 1){\n                this.renderableComponents[i].renderFrame(this._isFirstFrame);\n            }\n        /* this.maskManager.renderFrame(this.finalTransform.mat);\r\n          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */ },\n        sourceRectAtTime: function sourceRectAtTime() {\n            return {\n                top: 0,\n                left: 0,\n                width: 100,\n                height: 100\n            };\n        },\n        getLayerSize: function getLayerSize() {\n            if (this.data.ty === 5) {\n                return {\n                    w: this.data.textData.width,\n                    h: this.data.textData.height\n                };\n            }\n            return {\n                w: this.data.width,\n                h: this.data.height\n            };\n        }\n    };\n    var getBlendMode = function() {\n        var blendModeEnums = {\n            0: \"source-over\",\n            1: \"multiply\",\n            2: \"screen\",\n            3: \"overlay\",\n            4: \"darken\",\n            5: \"lighten\",\n            6: \"color-dodge\",\n            7: \"color-burn\",\n            8: \"hard-light\",\n            9: \"soft-light\",\n            10: \"difference\",\n            11: \"exclusion\",\n            12: \"hue\",\n            13: \"saturation\",\n            14: \"color\",\n            15: \"luminosity\"\n        };\n        return function(mode) {\n            return blendModeEnums[mode] || \"\";\n        };\n    }();\n    function SliderEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function AngleEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function ColorEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function PointEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function LayerIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function MaskIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function CheckboxEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function NoValueEffect() {\n        this.p = {};\n    }\n    function EffectsManager(data, element) {\n        var effects = data.ef || [];\n        this.effectElements = [];\n        var i;\n        var len = effects.length;\n        var effectItem;\n        for(i = 0; i < len; i += 1){\n            effectItem = new GroupEffect(effects[i], element);\n            this.effectElements.push(effectItem);\n        }\n    }\n    function GroupEffect(data, element) {\n        this.init(data, element);\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GroupEffect);\n    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\n    GroupEffect.prototype.init = function(data, element) {\n        this.data = data;\n        this.effectElements = [];\n        this.initDynamicPropertyContainer(element);\n        var i;\n        var len = this.data.ef.length;\n        var eff;\n        var effects = this.data.ef;\n        for(i = 0; i < len; i += 1){\n            eff = null;\n            switch(effects[i].ty){\n                case 0:\n                    eff = new SliderEffect(effects[i], element, this);\n                    break;\n                case 1:\n                    eff = new AngleEffect(effects[i], element, this);\n                    break;\n                case 2:\n                    eff = new ColorEffect(effects[i], element, this);\n                    break;\n                case 3:\n                    eff = new PointEffect(effects[i], element, this);\n                    break;\n                case 4:\n                case 7:\n                    eff = new CheckboxEffect(effects[i], element, this);\n                    break;\n                case 10:\n                    eff = new LayerIndexEffect(effects[i], element, this);\n                    break;\n                case 11:\n                    eff = new MaskIndexEffect(effects[i], element, this);\n                    break;\n                case 5:\n                    eff = new EffectsManager(effects[i], element, this);\n                    break;\n                // case 6:\n                default:\n                    eff = new NoValueEffect(effects[i], element, this);\n                    break;\n            }\n            if (eff) {\n                this.effectElements.push(eff);\n            }\n        }\n    };\n    function BaseElement() {}\n    BaseElement.prototype = {\n        checkMasks: function checkMasks() {\n            if (!this.data.hasMask) {\n                return false;\n            }\n            var i = 0;\n            var len = this.data.masksProperties.length;\n            while(i < len){\n                if (this.data.masksProperties[i].mode !== \"n\" && this.data.masksProperties[i].cl !== false) {\n                    return true;\n                }\n                i += 1;\n            }\n            return false;\n        },\n        initExpressions: function initExpressions() {\n            var expressionsInterfaces = getExpressionInterfaces();\n            if (!expressionsInterfaces) {\n                return;\n            }\n            var LayerExpressionInterface = expressionsInterfaces(\"layer\");\n            var EffectsExpressionInterface = expressionsInterfaces(\"effects\");\n            var ShapeExpressionInterface = expressionsInterfaces(\"shape\");\n            var TextExpressionInterface = expressionsInterfaces(\"text\");\n            var CompExpressionInterface = expressionsInterfaces(\"comp\");\n            this.layerInterface = LayerExpressionInterface(this);\n            if (this.data.hasMask && this.maskManager) {\n                this.layerInterface.registerMaskInterface(this.maskManager);\n            }\n            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);\n            this.layerInterface.registerEffectsInterface(effectsInterface);\n            if (this.data.ty === 0 || this.data.xt) {\n                this.compInterface = CompExpressionInterface(this);\n            } else if (this.data.ty === 4) {\n                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);\n                this.layerInterface.content = this.layerInterface.shapeInterface;\n            } else if (this.data.ty === 5) {\n                this.layerInterface.textInterface = TextExpressionInterface(this);\n                this.layerInterface.text = this.layerInterface.textInterface;\n            }\n        },\n        setBlendMode: function setBlendMode() {\n            var blendModeValue = getBlendMode(this.data.bm);\n            var elem = this.baseElement || this.layerElement;\n            elem.style[\"mix-blend-mode\"] = blendModeValue;\n        },\n        initBaseData: function initBaseData(data, globalData, comp) {\n            this.globalData = globalData;\n            this.comp = comp;\n            this.data = data;\n            this.layerId = createElementID(); // Stretch factor for old animations missing this property.\n            if (!this.data.sr) {\n                this.data.sr = 1;\n            } // effects manager\n            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);\n        },\n        getType: function getType() {\n            return this.type;\n        },\n        sourceRectAtTime: function sourceRectAtTime() {}\n    };\n    /**\r\n   * @file\r\n   * Handles element's layer frame update.\r\n   * Checks layer in point and out point\r\n   *\r\n   */ function FrameElement() {}\n    FrameElement.prototype = {\n        /**\r\n       * @function\r\n       * Initializes frame related properties.\r\n       *\r\n       */ initFrame: function initFrame() {\n            // set to true when inpoint is rendered\n            this._isFirstFrame = false; // list of animated properties\n            this.dynamicProperties = []; // If layer has been modified in current tick this will be true\n            this._mdf = false;\n        },\n        /**\r\n       * @function\r\n       * Calculates all dynamic values\r\n       *\r\n       * @param {number} num\r\n       * current frame number in Layer's time\r\n       * @param {boolean} isVisible\r\n       * if layers is currently in range\r\n       *\r\n       */ prepareProperties: function prepareProperties(num, isVisible) {\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                if (isVisible || this._isParent && this.dynamicProperties[i].propType === \"transform\") {\n                    this.dynamicProperties[i].getValue();\n                    if (this.dynamicProperties[i]._mdf) {\n                        this.globalData._mdf = true;\n                        this._mdf = true;\n                    }\n                }\n            }\n        },\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n            }\n        }\n    };\n    function FootageElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.footageData = globalData.imageLoader.getAsset(this.assetData);\n        this.initBaseData(data, globalData, comp);\n    }\n    FootageElement.prototype.prepareFrame = function() {};\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], FootageElement);\n    FootageElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    FootageElement.prototype.renderFrame = function() {};\n    FootageElement.prototype.destroy = function() {};\n    FootageElement.prototype.initExpressions = function() {\n        var expressionsInterfaces = getExpressionInterfaces();\n        if (!expressionsInterfaces) {\n            return;\n        }\n        var FootageInterface = expressionsInterfaces(\"footage\");\n        this.layerInterface = FootageInterface(this);\n    };\n    FootageElement.prototype.getFootageData = function() {\n        return this.footageData;\n    };\n    function AudioElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initBaseData(data, globalData, comp);\n        this._isPlaying = false;\n        this._canPlay = false;\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.audio = this.globalData.audioController.createAudio(assetPath);\n        this._currentTime = 0;\n        this.globalData.audioController.addAudio(this);\n        this._volumeMultiplier = 1;\n        this._volume = 1;\n        this._previousVolume = null;\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n        this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {\n            k: [\n                100\n            ]\n        }, 1, 0.01, this);\n    }\n    AudioElement.prototype.prepareFrame = function(num) {\n        this.prepareRenderableFrame(num, true);\n        this.prepareProperties(num, true);\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            this._currentTime = timeRemapped;\n        } else {\n            this._currentTime = num / this.data.sr;\n        }\n        this._volume = this.lv.v[0];\n        var totalVolume = this._volume * this._volumeMultiplier;\n        if (this._previousVolume !== totalVolume) {\n            this._previousVolume = totalVolume;\n            this.audio.volume(totalVolume);\n        }\n    };\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], AudioElement);\n    AudioElement.prototype.renderFrame = function() {\n        if (this.isInRange && this._canPlay) {\n            if (!this._isPlaying) {\n                this.audio.play();\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n                this._isPlaying = true;\n            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n            }\n        }\n    };\n    AudioElement.prototype.show = function() {};\n    AudioElement.prototype.hide = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n    };\n    AudioElement.prototype.pause = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n        this._canPlay = false;\n    };\n    AudioElement.prototype.resume = function() {\n        this._canPlay = true;\n    };\n    AudioElement.prototype.setRate = function(rateValue) {\n        this.audio.rate(rateValue);\n    };\n    AudioElement.prototype.volume = function(volumeValue) {\n        this._volumeMultiplier = volumeValue;\n        this._previousVolume = volumeValue * this._volume;\n        this.audio.volume(this._previousVolume);\n    };\n    AudioElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    AudioElement.prototype.destroy = function() {};\n    AudioElement.prototype.sourceRectAtTime = function() {};\n    AudioElement.prototype.initExpressions = function() {};\n    function BaseRenderer() {}\n    BaseRenderer.prototype.checkLayers = function(num) {\n        var i;\n        var len = this.layers.length;\n        var data;\n        this.completeLayers = true;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (!this.elements[i]) {\n                data = this.layers[i];\n                if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n                    this.buildItem(i);\n                }\n            }\n            this.completeLayers = this.elements[i] ? this.completeLayers : false;\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.createItem = function(layer) {\n        switch(layer.ty){\n            case 2:\n                return this.createImage(layer);\n            case 0:\n                return this.createComp(layer);\n            case 1:\n                return this.createSolid(layer);\n            case 3:\n                return this.createNull(layer);\n            case 4:\n                return this.createShape(layer);\n            case 5:\n                return this.createText(layer);\n            case 6:\n                return this.createAudio(layer);\n            case 13:\n                return this.createCamera(layer);\n            case 15:\n                return this.createFootage(layer);\n            default:\n                return this.createNull(layer);\n        }\n    };\n    BaseRenderer.prototype.createCamera = function() {\n        throw new Error(\"You're using a 3d camera. Try the html renderer.\");\n    };\n    BaseRenderer.prototype.createAudio = function(data) {\n        return new AudioElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.createFootage = function(data) {\n        return new FootageElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.buildAllItems = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            this.buildItem(i);\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.includeLayers = function(newLayers) {\n        this.completeLayers = false;\n        var i;\n        var len = newLayers.length;\n        var j;\n        var jLen = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            j = 0;\n            while(j < jLen){\n                if (this.layers[j].id === newLayers[i].id) {\n                    this.layers[j] = newLayers[i];\n                    break;\n                }\n                j += 1;\n            }\n        }\n    };\n    BaseRenderer.prototype.setProjectInterface = function(pInterface) {\n        this.globalData.projectInterface = pInterface;\n    };\n    BaseRenderer.prototype.initItems = function() {\n        if (!this.globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n    };\n    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {\n        var elements = this.elements;\n        var layers = this.layers;\n        var i = 0;\n        var len = layers.length;\n        while(i < len){\n            if (layers[i].ind == parentName) {\n                // eslint-disable-line eqeqeq\n                if (!elements[i] || elements[i] === true) {\n                    this.buildItem(i);\n                    this.addPendingElement(element);\n                } else {\n                    hierarchy.push(elements[i]);\n                    elements[i].setAsParent();\n                    if (layers[i].parent !== undefined) {\n                        this.buildElementParenting(element, layers[i].parent, hierarchy);\n                    } else {\n                        element.setHierarchy(hierarchy);\n                    }\n                }\n            }\n            i += 1;\n        }\n    };\n    BaseRenderer.prototype.addPendingElement = function(element) {\n        this.pendingElements.push(element);\n    };\n    BaseRenderer.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i]);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    BaseRenderer.prototype.getElementById = function(ind) {\n        var i;\n        var len = this.elements.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i].data.ind === ind) {\n                return this.elements[i];\n            }\n        }\n        return null;\n    };\n    BaseRenderer.prototype.getElementByPath = function(path) {\n        var pathValue = path.shift();\n        var element;\n        if (typeof pathValue === \"number\") {\n            element = this.elements[pathValue];\n        } else {\n            var i;\n            var len = this.elements.length;\n            for(i = 0; i < len; i += 1){\n                if (this.elements[i].data.nm === pathValue) {\n                    element = this.elements[i];\n                    break;\n                }\n            }\n        }\n        if (path.length === 0) {\n            return element;\n        }\n        return element.getElementByPath(path);\n    };\n    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {\n        this.globalData.fontManager = new FontManager();\n        this.globalData.slotManager = slotFactory(animData);\n        this.globalData.fontManager.addChars(animData.chars);\n        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\n        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\n        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\n        this.globalData.imageLoader = this.animationItem.imagePreloader;\n        this.globalData.audioController = this.animationItem.audioController;\n        this.globalData.frameId = 0;\n        this.globalData.frameRate = animData.fr;\n        this.globalData.nm = animData.nm;\n        this.globalData.compSize = {\n            w: animData.w,\n            h: animData.h\n        };\n    };\n    var effectTypes = {\n        TRANSFORM_EFFECT: \"transformEFfect\"\n    };\n    function TransformElement() {}\n    TransformElement.prototype = {\n        initTransform: function initTransform() {\n            var mat = new Matrix();\n            this.finalTransform = {\n                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {\n                    o: 0\n                },\n                _matMdf: false,\n                _localMatMdf: false,\n                _opMdf: false,\n                mat: mat,\n                localMat: mat,\n                localOpacity: 1\n            };\n            if (this.data.ao) {\n                this.finalTransform.mProp.autoOriented = true;\n            } // TODO: check TYPE 11: Guided elements\n            if (this.data.ty !== 11) {}\n        },\n        renderTransform: function renderTransform() {\n            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\n            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\n            if (this.hierarchy) {\n                var mat;\n                var finalMat = this.finalTransform.mat;\n                var i = 0;\n                var len = this.hierarchy.length; // Checking if any of the transformation matrices in the hierarchy chain has changed.\n                if (!this.finalTransform._matMdf) {\n                    while(i < len){\n                        if (this.hierarchy[i].finalTransform.mProp._mdf) {\n                            this.finalTransform._matMdf = true;\n                            break;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._matMdf) {\n                    mat = this.finalTransform.mProp.v.props;\n                    finalMat.cloneFromProps(mat);\n                    for(i = 0; i < len; i += 1){\n                        finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);\n                    }\n                }\n            }\n            if (this.finalTransform._matMdf) {\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n            }\n            if (this.finalTransform._opMdf) {\n                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderLocalTransform: function renderLocalTransform() {\n            if (this.localTransforms) {\n                var i = 0;\n                var len = this.localTransforms.length;\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n                if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {\n                    while(i < len){\n                        if (this.localTransforms[i]._mdf) {\n                            this.finalTransform._localMatMdf = true;\n                        }\n                        if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {\n                            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n                            this.finalTransform._opMdf = true;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._localMatMdf) {\n                    var localMat = this.finalTransform.localMat;\n                    this.localTransforms[0].matrix.clone(localMat);\n                    for(i = 1; i < len; i += 1){\n                        var lmat = this.localTransforms[i].matrix;\n                        localMat.multiply(lmat);\n                    }\n                    localMat.multiply(this.finalTransform.mat);\n                }\n                if (this.finalTransform._opMdf) {\n                    var localOp = this.finalTransform.localOpacity;\n                    for(i = 0; i < len; i += 1){\n                        localOp *= this.localTransforms[i].opacity * 0.01;\n                    }\n                    this.finalTransform.localOpacity = localOp;\n                }\n            }\n        },\n        searchEffectTransforms: function searchEffectTransforms() {\n            if (this.renderableEffectsManager) {\n                var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n                if (transformEffects.length) {\n                    this.localTransforms = [];\n                    this.finalTransform.localMat = new Matrix();\n                    var i = 0;\n                    var len = transformEffects.length;\n                    for(i = 0; i < len; i += 1){\n                        this.localTransforms.push(transformEffects[i]);\n                    }\n                }\n            }\n        },\n        globalToLocal: function globalToLocal(pt) {\n            var transforms = [];\n            transforms.push(this.finalTransform);\n            var flag = true;\n            var comp = this.comp;\n            while(flag){\n                if (comp.finalTransform) {\n                    if (comp.data.hasMask) {\n                        transforms.splice(0, 0, comp.finalTransform);\n                    }\n                    comp = comp.comp;\n                } else {\n                    flag = false;\n                }\n            }\n            var i;\n            var len = transforms.length;\n            var ptNew;\n            for(i = 0; i < len; i += 1){\n                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0); // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n                pt = [\n                    pt[0] - ptNew[0],\n                    pt[1] - ptNew[1],\n                    0\n                ];\n            }\n            return pt;\n        },\n        mHelper: new Matrix()\n    };\n    function MaskElement(data, element, globalData) {\n        this.data = data;\n        this.element = element;\n        this.globalData = globalData;\n        this.storedData = [];\n        this.masksProperties = this.data.masksProperties || [];\n        this.maskElement = null;\n        var defs = this.globalData.defs;\n        var i;\n        var len = this.masksProperties ? this.masksProperties.length : 0;\n        this.viewData = createSizedArray(len);\n        this.solidPath = \"\";\n        var path;\n        var properties = this.masksProperties;\n        var count = 0;\n        var currentMasks = [];\n        var j;\n        var jLen;\n        var layerId = createElementID();\n        var rect;\n        var expansor;\n        var feMorph;\n        var x;\n        var maskType = \"clipPath\";\n        var maskRef = \"clip-path\";\n        for(i = 0; i < len; i += 1){\n            if (properties[i].mode !== \"a\" && properties[i].mode !== \"n\" || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {\n                maskType = \"mask\";\n                maskRef = \"mask\";\n            }\n            if ((properties[i].mode === \"s\" || properties[i].mode === \"i\") && count === 0) {\n                rect = createNS(\"rect\");\n                rect.setAttribute(\"fill\", \"#ffffff\");\n                rect.setAttribute(\"width\", this.element.comp.data.w || 0);\n                rect.setAttribute(\"height\", this.element.comp.data.h || 0);\n                currentMasks.push(rect);\n            } else {\n                rect = null;\n            }\n            path = createNS(\"path\");\n            if (properties[i].mode === \"n\") {\n                // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    elem: path,\n                    lastPath: \"\"\n                };\n                defs.appendChild(path);\n            } else {\n                count += 1;\n                path.setAttribute(\"fill\", properties[i].mode === \"s\" ? \"#000000\" : \"#ffffff\");\n                path.setAttribute(\"clip-rule\", \"nonzero\");\n                var filterID;\n                if (properties[i].x.k !== 0) {\n                    maskType = \"mask\";\n                    maskRef = \"mask\";\n                    x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);\n                    filterID = createElementID();\n                    expansor = createNS(\"filter\");\n                    expansor.setAttribute(\"id\", filterID);\n                    feMorph = createNS(\"feMorphology\");\n                    feMorph.setAttribute(\"operator\", \"erode\");\n                    feMorph.setAttribute(\"in\", \"SourceGraphic\");\n                    feMorph.setAttribute(\"radius\", \"0\");\n                    expansor.appendChild(feMorph);\n                    defs.appendChild(expansor);\n                    path.setAttribute(\"stroke\", properties[i].mode === \"s\" ? \"#000000\" : \"#ffffff\");\n                } else {\n                    feMorph = null;\n                    x = null;\n                } // TODO move this to a factory or to a constructor\n                this.storedData[i] = {\n                    elem: path,\n                    x: x,\n                    expan: feMorph,\n                    lastPath: \"\",\n                    lastOperator: \"\",\n                    filterId: filterID,\n                    lastRadius: 0\n                };\n                if (properties[i].mode === \"i\") {\n                    jLen = currentMasks.length;\n                    var g = createNS(\"g\");\n                    for(j = 0; j < jLen; j += 1){\n                        g.appendChild(currentMasks[j]);\n                    }\n                    var mask = createNS(\"mask\");\n                    mask.setAttribute(\"mask-type\", \"alpha\");\n                    mask.setAttribute(\"id\", layerId + \"_\" + count);\n                    mask.appendChild(path);\n                    defs.appendChild(mask);\n                    g.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + layerId + \"_\" + count + \")\");\n                    currentMasks.length = 0;\n                    currentMasks.push(g);\n                } else {\n                    currentMasks.push(path);\n                }\n                if (properties[i].inv && !this.solidPath) {\n                    this.solidPath = this.createLayerSolidPath();\n                } // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    elem: path,\n                    lastPath: \"\",\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    invRect: rect\n                };\n                if (!this.viewData[i].prop.k) {\n                    this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);\n                }\n            }\n        }\n        this.maskElement = createNS(maskType);\n        len = currentMasks.length;\n        for(i = 0; i < len; i += 1){\n            this.maskElement.appendChild(currentMasks[i]);\n        }\n        if (count > 0) {\n            this.maskElement.setAttribute(\"id\", layerId);\n            this.element.maskedElement.setAttribute(maskRef, \"url(\" + getLocationHref() + \"#\" + layerId + \")\");\n            defs.appendChild(this.maskElement);\n        }\n        if (this.viewData.length) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    MaskElement.prototype.getMaskProperty = function(pos) {\n        return this.viewData[pos].prop;\n    };\n    MaskElement.prototype.renderFrame = function(isFirstFrame) {\n        var finalMat = this.element.finalTransform.mat;\n        var i;\n        var len = this.masksProperties.length;\n        for(i = 0; i < len; i += 1){\n            if (this.viewData[i].prop._mdf || isFirstFrame) {\n                this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);\n            }\n            if (this.viewData[i].op._mdf || isFirstFrame) {\n                this.viewData[i].elem.setAttribute(\"fill-opacity\", this.viewData[i].op.v);\n            }\n            if (this.masksProperties[i].mode !== \"n\") {\n                if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n                    this.viewData[i].invRect.setAttribute(\"transform\", finalMat.getInverseMatrix().to2dCSS());\n                }\n                if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n                    var feMorph = this.storedData[i].expan;\n                    if (this.storedData[i].x.v < 0) {\n                        if (this.storedData[i].lastOperator !== \"erode\") {\n                            this.storedData[i].lastOperator = \"erode\";\n                            this.storedData[i].elem.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + this.storedData[i].filterId + \")\");\n                        }\n                        feMorph.setAttribute(\"radius\", -this.storedData[i].x.v);\n                    } else {\n                        if (this.storedData[i].lastOperator !== \"dilate\") {\n                            this.storedData[i].lastOperator = \"dilate\";\n                            this.storedData[i].elem.setAttribute(\"filter\", null);\n                        }\n                        this.storedData[i].elem.setAttribute(\"stroke-width\", this.storedData[i].x.v * 2);\n                    }\n                }\n            }\n        }\n    };\n    MaskElement.prototype.getMaskelement = function() {\n        return this.maskElement;\n    };\n    MaskElement.prototype.createLayerSolidPath = function() {\n        var path = \"M0,0 \";\n        path += \" h\" + this.globalData.compSize.w;\n        path += \" v\" + this.globalData.compSize.h;\n        path += \" h-\" + this.globalData.compSize.w;\n        path += \" v-\" + this.globalData.compSize.h + \" \";\n        return path;\n    };\n    MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {\n        var pathString = \" M\" + pathNodes.v[0][0] + \",\" + pathNodes.v[0][1];\n        var i;\n        var len;\n        len = pathNodes._length;\n        for(i = 1; i < len; i += 1){\n            // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n            pathString += \" C\" + pathNodes.o[i - 1][0] + \",\" + pathNodes.o[i - 1][1] + \" \" + pathNodes.i[i][0] + \",\" + pathNodes.i[i][1] + \" \" + pathNodes.v[i][0] + \",\" + pathNodes.v[i][1];\n        } // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n        if (pathNodes.c && len > 1) {\n            pathString += \" C\" + pathNodes.o[i - 1][0] + \",\" + pathNodes.o[i - 1][1] + \" \" + pathNodes.i[0][0] + \",\" + pathNodes.i[0][1] + \" \" + pathNodes.v[0][0] + \",\" + pathNodes.v[0][1];\n        } // pathNodes.__renderedString = pathString;\n        if (viewData.lastPath !== pathString) {\n            var pathShapeValue = \"\";\n            if (viewData.elem) {\n                if (pathNodes.c) {\n                    pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\n                }\n                viewData.elem.setAttribute(\"d\", pathShapeValue);\n            }\n            viewData.lastPath = pathString;\n        }\n    };\n    MaskElement.prototype.destroy = function() {\n        this.element = null;\n        this.globalData = null;\n        this.maskElement = null;\n        this.data = null;\n        this.masksProperties = null;\n    };\n    var filtersFactory = function() {\n        var ob = {};\n        ob.createFilter = createFilter;\n        ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\n        function createFilter(filId, skipCoordinates) {\n            var fil = createNS(\"filter\");\n            fil.setAttribute(\"id\", filId);\n            if (skipCoordinates !== true) {\n                fil.setAttribute(\"filterUnits\", \"objectBoundingBox\");\n                fil.setAttribute(\"x\", \"0%\");\n                fil.setAttribute(\"y\", \"0%\");\n                fil.setAttribute(\"width\", \"100%\");\n                fil.setAttribute(\"height\", \"100%\");\n            }\n            return fil;\n        }\n        function createAlphaToLuminanceFilter() {\n            var feColorMatrix = createNS(\"feColorMatrix\");\n            feColorMatrix.setAttribute(\"type\", \"matrix\");\n            feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            feColorMatrix.setAttribute(\"values\", \"0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1\");\n            return feColorMatrix;\n        }\n        return ob;\n    }();\n    var featureSupport = function() {\n        var ob = {\n            maskType: true,\n            svgLumaHidden: true,\n            offscreenCanvas: typeof OffscreenCanvas !== \"undefined\"\n        };\n        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)) {\n            ob.maskType = false;\n        }\n        if (/firefox/i.test(navigator.userAgent)) {\n            ob.svgLumaHidden = false;\n        }\n        return ob;\n    }();\n    var registeredEffects$1 = {};\n    var idPrefix = \"filter_result_\";\n    function SVGEffects(elem) {\n        var i;\n        var source = \"SourceGraphic\";\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        var filId = createElementID();\n        var fil = filtersFactory.createFilter(filId, true);\n        var count = 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects$1[type]) {\n                var Effect = registeredEffects$1[type].effect;\n                filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);\n                source = idPrefix + count;\n                if (registeredEffects$1[type].countsAsEffect) {\n                    count += 1;\n                }\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (count) {\n            elem.globalData.defs.appendChild(fil);\n            elem.layerElement.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    SVGEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect$1(id, effect, countsAsEffect) {\n        registeredEffects$1[id] = {\n            effect: effect,\n            countsAsEffect: countsAsEffect\n        };\n    }\n    function SVGBaseElement() {}\n    SVGBaseElement.prototype = {\n        initRendererElement: function initRendererElement() {\n            this.layerElement = createNS(\"g\");\n        },\n        createContainerElements: function createContainerElements() {\n            this.matteElement = createNS(\"g\");\n            this.transformedElement = this.layerElement;\n            this.maskedElement = this.layerElement;\n            this._sizeChanged = false;\n            var layerElementParent = null; // If this layer acts as a mask for the following layer\n            if (this.data.td) {\n                this.matteMasks = {};\n                var gg = createNS(\"g\");\n                gg.setAttribute(\"id\", this.layerId);\n                gg.appendChild(this.layerElement);\n                layerElementParent = gg;\n                this.globalData.defs.appendChild(gg);\n            } else if (this.data.tt) {\n                this.matteElement.appendChild(this.layerElement);\n                layerElementParent = this.matteElement;\n                this.baseElement = this.matteElement;\n            } else {\n                this.baseElement = this.layerElement;\n            }\n            if (this.data.ln) {\n                this.layerElement.setAttribute(\"id\", this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute(\"class\", this.data.cl);\n            } // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n            if (this.data.ty === 0 && !this.data.hd) {\n                var cp = createNS(\"clipPath\");\n                var pt = createNS(\"path\");\n                pt.setAttribute(\"d\", \"M0,0 L\" + this.data.w + \",0 L\" + this.data.w + \",\" + this.data.h + \" L0,\" + this.data.h + \"z\");\n                var clipId = createElementID();\n                cp.setAttribute(\"id\", clipId);\n                cp.appendChild(pt);\n                this.globalData.defs.appendChild(cp);\n                if (this.checkMasks()) {\n                    var cpGroup = createNS(\"g\");\n                    cpGroup.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + clipId + \")\");\n                    cpGroup.appendChild(this.layerElement);\n                    this.transformedElement = cpGroup;\n                    if (layerElementParent) {\n                        layerElementParent.appendChild(this.transformedElement);\n                    } else {\n                        this.baseElement = this.transformedElement;\n                    }\n                } else {\n                    this.layerElement.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + clipId + \")\");\n                }\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            if (this.finalTransform._localMatMdf) {\n                this.transformedElement.setAttribute(\"transform\", this.finalTransform.localMat.to2dCSS());\n            }\n            if (this.finalTransform._opMdf) {\n                this.transformedElement.setAttribute(\"opacity\", this.finalTransform.localOpacity);\n            }\n        },\n        destroyBaseElement: function destroyBaseElement() {\n            this.layerElement = null;\n            this.matteElement = null;\n            this.maskManager.destroy();\n        },\n        getBaseElement: function getBaseElement() {\n            if (this.data.hd) {\n                return null;\n            }\n            return this.baseElement;\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n            this.renderableEffectsManager = new SVGEffects(this);\n            this.searchEffectTransforms();\n        },\n        getMatte: function getMatte(matteType) {\n            // This should not be a common case. But for backward compatibility, we'll create the matte object.\n            // It solves animations that have two consecutive layers marked as matte masks.\n            // Which is an undefined behavior in AE.\n            if (!this.matteMasks) {\n                this.matteMasks = {};\n            }\n            if (!this.matteMasks[matteType]) {\n                var id = this.layerId + \"_\" + matteType;\n                var filId;\n                var fil;\n                var useElement;\n                var gg;\n                if (matteType === 1 || matteType === 3) {\n                    var masker = createNS(\"mask\");\n                    masker.setAttribute(\"id\", id);\n                    masker.setAttribute(\"mask-type\", matteType === 3 ? \"luminance\" : \"alpha\");\n                    useElement = createNS(\"use\");\n                    useElement.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", \"#\" + this.layerId);\n                    masker.appendChild(useElement);\n                    this.globalData.defs.appendChild(masker);\n                    if (!featureSupport.maskType && matteType === 1) {\n                        masker.setAttribute(\"mask-type\", \"luminance\");\n                        filId = createElementID();\n                        fil = filtersFactory.createFilter(filId);\n                        this.globalData.defs.appendChild(fil);\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS(\"g\");\n                        gg.appendChild(useElement);\n                        masker.appendChild(gg);\n                        gg.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n                    }\n                } else if (matteType === 2) {\n                    var maskGroup = createNS(\"mask\");\n                    maskGroup.setAttribute(\"id\", id);\n                    maskGroup.setAttribute(\"mask-type\", \"alpha\");\n                    var maskGrouper = createNS(\"g\");\n                    maskGroup.appendChild(maskGrouper);\n                    filId = createElementID();\n                    fil = filtersFactory.createFilter(filId); /// /\n                    var feCTr = createNS(\"feComponentTransfer\");\n                    feCTr.setAttribute(\"in\", \"SourceGraphic\");\n                    fil.appendChild(feCTr);\n                    var feFunc = createNS(\"feFuncA\");\n                    feFunc.setAttribute(\"type\", \"table\");\n                    feFunc.setAttribute(\"tableValues\", \"1.0 0.0\");\n                    feCTr.appendChild(feFunc); /// /\n                    this.globalData.defs.appendChild(fil);\n                    var alphaRect = createNS(\"rect\");\n                    alphaRect.setAttribute(\"width\", this.comp.data.w);\n                    alphaRect.setAttribute(\"height\", this.comp.data.h);\n                    alphaRect.setAttribute(\"x\", \"0\");\n                    alphaRect.setAttribute(\"y\", \"0\");\n                    alphaRect.setAttribute(\"fill\", \"#ffffff\");\n                    alphaRect.setAttribute(\"opacity\", \"0\");\n                    maskGrouper.setAttribute(\"filter\", \"url(\" + getLocationHref() + \"#\" + filId + \")\");\n                    maskGrouper.appendChild(alphaRect);\n                    useElement = createNS(\"use\");\n                    useElement.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", \"#\" + this.layerId);\n                    maskGrouper.appendChild(useElement);\n                    if (!featureSupport.maskType) {\n                        maskGroup.setAttribute(\"mask-type\", \"luminance\");\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS(\"g\");\n                        maskGrouper.appendChild(alphaRect);\n                        gg.appendChild(this.layerElement);\n                        maskGrouper.appendChild(gg);\n                    }\n                    this.globalData.defs.appendChild(maskGroup);\n                }\n                this.matteMasks[matteType] = id;\n            }\n            return this.matteMasks[matteType];\n        },\n        setMatte: function setMatte(id) {\n            if (!this.matteElement) {\n                return;\n            }\n            this.matteElement.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + id + \")\");\n        }\n    };\n    /**\r\n   * @file\r\n   * Handles AE's layer parenting property.\r\n   *\r\n   */ function HierarchyElement() {}\n    HierarchyElement.prototype = {\n        /**\r\n       * @function\r\n       * Initializes hierarchy properties\r\n       *\r\n       */ initHierarchy: function initHierarchy() {\n            // element's parent list\n            this.hierarchy = []; // if element is parent of another layer _isParent will be true\n            this._isParent = false;\n            this.checkParenting();\n        },\n        /**\r\n       * @function\r\n       * Sets layer's hierarchy.\r\n       * @param {array} hierarch\r\n       * layer's parent list\r\n       *\r\n       */ setHierarchy: function setHierarchy(hierarchy) {\n            this.hierarchy = hierarchy;\n        },\n        /**\r\n       * @function\r\n       * Sets layer as parent.\r\n       *\r\n       */ setAsParent: function setAsParent() {\n            this._isParent = true;\n        },\n        /**\r\n       * @function\r\n       * Searches layer's parenting chain\r\n       *\r\n       */ checkParenting: function checkParenting() {\n            if (this.data.parent !== undefined) {\n                this.comp.buildElementParenting(this, this.data.parent, []);\n            }\n        }\n    };\n    function RenderableDOMElement() {}\n    (function() {\n        var _prototype = {\n            initElement: function initElement(data, globalData, comp) {\n                this.initFrame();\n                this.initBaseData(data, globalData, comp);\n                this.initTransform(data, globalData, comp);\n                this.initHierarchy();\n                this.initRenderable();\n                this.initRendererElement();\n                this.createContainerElements();\n                this.createRenderableComponents();\n                this.createContent();\n                this.hide();\n            },\n            hide: function hide() {\n                // console.log('HIDE', this);\n                if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                    var elem = this.baseElement || this.layerElement;\n                    elem.style.display = \"none\";\n                    this.hidden = true;\n                }\n            },\n            show: function show() {\n                // console.log('SHOW', this);\n                if (this.isInRange && !this.isTransparent) {\n                    if (!this.data.hd) {\n                        var elem = this.baseElement || this.layerElement;\n                        elem.style.display = \"block\";\n                    }\n                    this.hidden = false;\n                    this._isFirstFrame = true;\n                }\n            },\n            renderFrame: function renderFrame() {\n                // If it is exported as hidden (data.hd === true) no need to render\n                // If it is not visible no need to render\n                if (this.data.hd || this.hidden) {\n                    return;\n                }\n                this.renderTransform();\n                this.renderRenderable();\n                this.renderLocalTransform();\n                this.renderElement();\n                this.renderInnerContent();\n                if (this._isFirstFrame) {\n                    this._isFirstFrame = false;\n                }\n            },\n            renderInnerContent: function renderInnerContent() {},\n            prepareFrame: function prepareFrame(num) {\n                this._mdf = false;\n                this.prepareRenderableFrame(num);\n                this.prepareProperties(num, this.isInRange);\n                this.checkTransparency();\n            },\n            destroy: function destroy() {\n                this.innerElem = null;\n                this.destroyBaseElement();\n            }\n        };\n        extendPrototype([\n            RenderableElement,\n            createProxyFunction(_prototype)\n        ], RenderableDOMElement);\n    })();\n    function IImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        if (this.assetData && this.assetData.sid) {\n            this.assetData = globalData.slotManager.getProp(this.assetData);\n        }\n        this.initElement(data, globalData, comp);\n        this.sourceRect = {\n            top: 0,\n            left: 0,\n            width: this.assetData.w,\n            height: this.assetData.h\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], IImageElement);\n    IImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.innerElem = createNS(\"image\");\n        this.innerElem.setAttribute(\"width\", this.assetData.w + \"px\");\n        this.innerElem.setAttribute(\"height\", this.assetData.h + \"px\");\n        this.innerElem.setAttribute(\"preserveAspectRatio\", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\n        this.innerElem.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", assetPath);\n        this.layerElement.appendChild(this.innerElem);\n    };\n    IImageElement.prototype.sourceRectAtTime = function() {\n        return this.sourceRect;\n    };\n    function ProcessedElement(element, position) {\n        this.elem = element;\n        this.pos = position;\n    }\n    function IShapeElement() {}\n    IShapeElement.prototype = {\n        addShapeToModifiers: function addShapeToModifiers(data) {\n            var i;\n            var len = this.shapeModifiers.length;\n            for(i = 0; i < len; i += 1){\n                this.shapeModifiers[i].addShape(data);\n            }\n        },\n        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {\n            var i = 0;\n            var len = this.shapeModifiers.length;\n            while(i < len){\n                if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        renderModifiers: function renderModifiers() {\n            if (!this.shapeModifiers.length) {\n                return;\n            }\n            var i;\n            var len = this.shapes.length;\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].sh.reset();\n            }\n            len = this.shapeModifiers.length;\n            var shouldBreakProcess;\n            for(i = len - 1; i >= 0; i -= 1){\n                shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame); // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n                // TODO: find a better solution for this\n                if (shouldBreakProcess) {\n                    break;\n                }\n            }\n        },\n        searchProcessedElement: function searchProcessedElement(elem) {\n            var elements = this.processedElements;\n            var i = 0;\n            var len = elements.length;\n            while(i < len){\n                if (elements[i].elem === elem) {\n                    return elements[i].pos;\n                }\n                i += 1;\n            }\n            return 0;\n        },\n        addProcessedElement: function addProcessedElement(elem, pos) {\n            var elements = this.processedElements;\n            var i = elements.length;\n            while(i){\n                i -= 1;\n                if (elements[i].elem === elem) {\n                    elements[i].pos = pos;\n                    return;\n                }\n            }\n            elements.push(new ProcessedElement(elem, pos));\n        },\n        prepareFrame: function prepareFrame(num) {\n            this.prepareRenderableFrame(num);\n            this.prepareProperties(num, this.isInRange);\n        }\n    };\n    var lineCapEnum = {\n        1: \"butt\",\n        2: \"round\",\n        3: \"square\"\n    };\n    var lineJoinEnum = {\n        1: \"miter\",\n        2: \"round\",\n        3: \"bevel\"\n    };\n    function SVGShapeData(transformers, level, shape) {\n        this.caches = [];\n        this.styles = [];\n        this.transformers = transformers;\n        this.lStr = \"\";\n        this.sh = shape;\n        this.lvl = level; // TODO find if there are some cases where _isAnimated can be false.\n        // For now, since shapes add up with other shapes. They have to be calculated every time.\n        // One way of finding out is checking if all styles associated to this shape depend only of this shape\n        this._isAnimated = !!shape.k; // TODO: commenting this for now since all shapes are animated\n        var i = 0;\n        var len = transformers.length;\n        while(i < len){\n            if (transformers[i].mProps.dynamicProperties.length) {\n                this._isAnimated = true;\n                break;\n            }\n            i += 1;\n        }\n    }\n    SVGShapeData.prototype.setAsAnimated = function() {\n        this._isAnimated = true;\n    };\n    function SVGStyleData(data, level) {\n        this.data = data;\n        this.type = data.ty;\n        this.d = \"\";\n        this.lvl = level;\n        this._mdf = false;\n        this.closed = data.hd === true;\n        this.pElem = createNS(\"path\");\n        this.msElem = null;\n    }\n    SVGStyleData.prototype.reset = function() {\n        this.d = \"\";\n        this._mdf = false;\n    };\n    function DashProperty(elem, data, renderer, container) {\n        this.elem = elem;\n        this.frameId = -1;\n        this.dataProps = createSizedArray(data.length);\n        this.renderer = renderer;\n        this.k = false;\n        this.dashStr = \"\";\n        this.dashArray = createTypedArray(\"float32\", data.length ? data.length - 1 : 0);\n        this.dashoffset = createTypedArray(\"float32\", 1);\n        this.initDynamicPropertyContainer(container);\n        var i;\n        var len = data.length || 0;\n        var prop;\n        for(i = 0; i < len; i += 1){\n            prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);\n            this.k = prop.k || this.k;\n            this.dataProps[i] = {\n                n: data[i].n,\n                p: prop\n            };\n        }\n        if (!this.k) {\n            this.getValue(true);\n        }\n        this._isAnimated = this.k;\n    }\n    DashProperty.prototype.getValue = function(forceRender) {\n        if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n        this._mdf = this._mdf || forceRender;\n        if (this._mdf) {\n            var i = 0;\n            var len = this.dataProps.length;\n            if (this.renderer === \"svg\") {\n                this.dashStr = \"\";\n            }\n            for(i = 0; i < len; i += 1){\n                if (this.dataProps[i].n !== \"o\") {\n                    if (this.renderer === \"svg\") {\n                        this.dashStr += \" \" + this.dataProps[i].p.v;\n                    } else {\n                        this.dashArray[i] = this.dataProps[i].p.v;\n                    }\n                } else {\n                    this.dashoffset[0] = this.dataProps[i].p.v;\n                }\n            }\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], DashProperty);\n    function SVGStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, \"svg\", this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGStrokeStyleData);\n    function SVGFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGFillStyleData);\n    function SVGNoStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGNoStyleData);\n    function GradientProperty(elem, data, container) {\n        this.data = data;\n        this.c = createTypedArray(\"uint8c\", data.p * 4);\n        var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;\n        this.o = createTypedArray(\"float32\", cLength);\n        this._cmdf = false;\n        this._omdf = false;\n        this._collapsable = this.checkCollapsable();\n        this._hasOpacity = cLength;\n        this.initDynamicPropertyContainer(container);\n        this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);\n        this.k = this.prop.k;\n        this.getValue(true);\n    }\n    GradientProperty.prototype.comparePoints = function(values, points) {\n        var i = 0;\n        var len = this.o.length / 2;\n        var diff;\n        while(i < len){\n            diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);\n            if (diff > 0.01) {\n                return false;\n            }\n            i += 1;\n        }\n        return true;\n    };\n    GradientProperty.prototype.checkCollapsable = function() {\n        if (this.o.length / 2 !== this.c.length / 4) {\n            return false;\n        }\n        if (this.data.k.k[0].s) {\n            var i = 0;\n            var len = this.data.k.k.length;\n            while(i < len){\n                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n                    return false;\n                }\n                i += 1;\n            }\n        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n            return false;\n        }\n        return true;\n    };\n    GradientProperty.prototype.getValue = function(forceRender) {\n        this.prop.getValue();\n        this._mdf = false;\n        this._cmdf = false;\n        this._omdf = false;\n        if (this.prop._mdf || forceRender) {\n            var i;\n            var len = this.data.p * 4;\n            var mult;\n            var val;\n            for(i = 0; i < len; i += 1){\n                mult = i % 4 === 0 ? 100 : 255;\n                val = Math.round(this.prop.v[i] * mult);\n                if (this.c[i] !== val) {\n                    this.c[i] = val;\n                    this._cmdf = !forceRender;\n                }\n            }\n            if (this.o.length) {\n                len = this.prop.v.length;\n                for(i = this.data.p * 4; i < len; i += 1){\n                    mult = i % 2 === 0 ? 100 : 1;\n                    val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];\n                    if (this.o[i - this.data.p * 4] !== val) {\n                        this.o[i - this.data.p * 4] = val;\n                        this._omdf = !forceRender;\n                    }\n                }\n            }\n            this._mdf = !forceRender;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GradientProperty);\n    function SVGGradientFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.initGradientData(elem, data, styleOb);\n    }\n    SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);\n        this.h = PropertyFactory.getProp(elem, data.h || {\n            k: 0\n        }, 0, 0.01, this);\n        this.a = PropertyFactory.getProp(elem, data.a || {\n            k: 0\n        }, 0, degToRads, this);\n        this.g = new GradientProperty(elem, data.g, this);\n        this.style = styleOb;\n        this.stops = [];\n        this.setGradientData(styleOb.pElem, data);\n        this.setGradientOpacity(data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    };\n    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {\n        var gradientId = createElementID();\n        var gfill = createNS(data.t === 1 ? \"linearGradient\" : \"radialGradient\");\n        gfill.setAttribute(\"id\", gradientId);\n        gfill.setAttribute(\"spreadMethod\", \"pad\");\n        gfill.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n        var stops = [];\n        var stop;\n        var j;\n        var jLen;\n        jLen = data.g.p * 4;\n        for(j = 0; j < jLen; j += 4){\n            stop = createNS(\"stop\");\n            gfill.appendChild(stop);\n            stops.push(stop);\n        }\n        pathElement.setAttribute(data.ty === \"gf\" ? \"fill\" : \"stroke\", \"url(\" + getLocationHref() + \"#\" + gradientId + \")\");\n        this.gf = gfill;\n        this.cst = stops;\n    };\n    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {\n        if (this.g._hasOpacity && !this.g._collapsable) {\n            var stop;\n            var j;\n            var jLen;\n            var mask = createNS(\"mask\");\n            var maskElement = createNS(\"path\");\n            mask.appendChild(maskElement);\n            var opacityId = createElementID();\n            var maskId = createElementID();\n            mask.setAttribute(\"id\", maskId);\n            var opFill = createNS(data.t === 1 ? \"linearGradient\" : \"radialGradient\");\n            opFill.setAttribute(\"id\", opacityId);\n            opFill.setAttribute(\"spreadMethod\", \"pad\");\n            opFill.setAttribute(\"gradientUnits\", \"userSpaceOnUse\");\n            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\n            var stops = this.stops;\n            for(j = data.g.p * 4; j < jLen; j += 2){\n                stop = createNS(\"stop\");\n                stop.setAttribute(\"stop-color\", \"rgb(255,255,255)\");\n                opFill.appendChild(stop);\n                stops.push(stop);\n            }\n            maskElement.setAttribute(data.ty === \"gf\" ? \"fill\" : \"stroke\", \"url(\" + getLocationHref() + \"#\" + opacityId + \")\");\n            if (data.ty === \"gs\") {\n                maskElement.setAttribute(\"stroke-linecap\", lineCapEnum[data.lc || 2]);\n                maskElement.setAttribute(\"stroke-linejoin\", lineJoinEnum[data.lj || 2]);\n                if (data.lj === 1) {\n                    maskElement.setAttribute(\"stroke-miterlimit\", data.ml);\n                }\n            }\n            this.of = opFill;\n            this.ms = mask;\n            this.ost = stops;\n            this.maskId = maskId;\n            styleOb.msElem = maskElement;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGGradientFillStyleData);\n    function SVGGradientStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, \"svg\", this);\n        this.initGradientData(elem, data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        SVGGradientFillStyleData,\n        DynamicPropertyContainer\n    ], SVGGradientStrokeStyleData);\n    function ShapeGroupData() {\n        this.it = [];\n        this.prevViewData = [];\n        this.gr = createNS(\"g\");\n    }\n    function SVGTransformData(mProps, op, container) {\n        this.transform = {\n            mProps: mProps,\n            op: op,\n            container: container\n        };\n        this.elements = [];\n        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\n    }\n    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {\n        if (length === 0) {\n            return \"\";\n        }\n        var _o = pathNodes.o;\n        var _i = pathNodes.i;\n        var _v = pathNodes.v;\n        var i;\n        var shapeString = \" M\" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n        for(i = 1; i < length; i += 1){\n            shapeString += \" C\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \" \" + mat.applyToPointStringified(_i[i][0], _i[i][1]) + \" \" + mat.applyToPointStringified(_v[i][0], _v[i][1]);\n        }\n        if (closed && length) {\n            shapeString += \" C\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \" \" + mat.applyToPointStringified(_i[0][0], _i[0][1]) + \" \" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n            shapeString += \"z\";\n        }\n        return shapeString;\n    };\n    var SVGElementsRenderer = function() {\n        var _identityMatrix = new Matrix();\n        var _matrixHelper = new Matrix();\n        var ob = {\n            createRenderFunction: createRenderFunction\n        };\n        function createRenderFunction(data) {\n            switch(data.ty){\n                case \"fl\":\n                    return renderFill;\n                case \"gf\":\n                    return renderGradient;\n                case \"gs\":\n                    return renderGradientStroke;\n                case \"st\":\n                    return renderStroke;\n                case \"sh\":\n                case \"el\":\n                case \"rc\":\n                case \"sr\":\n                    return renderPath;\n                case \"tr\":\n                    return renderContentTransform;\n                case \"no\":\n                    return renderNoop;\n                default:\n                    return null;\n            }\n        }\n        function renderContentTransform(styleData, itemData, isFirstFrame) {\n            if (isFirstFrame || itemData.transform.op._mdf) {\n                itemData.transform.container.setAttribute(\"opacity\", itemData.transform.op.v);\n            }\n            if (isFirstFrame || itemData.transform.mProps._mdf) {\n                itemData.transform.container.setAttribute(\"transform\", itemData.transform.mProps.v.to2dCSS());\n            }\n        }\n        function renderNoop() {}\n        function renderPath(styleData, itemData, isFirstFrame) {\n            var j;\n            var jLen;\n            var pathStringTransformed;\n            var redraw;\n            var pathNodes;\n            var l;\n            var lLen = itemData.styles.length;\n            var lvl = itemData.lvl;\n            var paths;\n            var mat;\n            var iterations;\n            var k;\n            for(l = 0; l < lLen; l += 1){\n                redraw = itemData.sh._mdf || isFirstFrame;\n                if (itemData.styles[l].lvl < lvl) {\n                    mat = _matrixHelper.reset();\n                    iterations = lvl - itemData.styles[l].lvl;\n                    k = itemData.transformers.length - 1;\n                    while(!redraw && iterations > 0){\n                        redraw = itemData.transformers[k].mProps._mdf || redraw;\n                        iterations -= 1;\n                        k -= 1;\n                    }\n                    if (redraw) {\n                        iterations = lvl - itemData.styles[l].lvl;\n                        k = itemData.transformers.length - 1;\n                        while(iterations > 0){\n                            mat.multiply(itemData.transformers[k].mProps.v);\n                            iterations -= 1;\n                            k -= 1;\n                        }\n                    }\n                } else {\n                    mat = _identityMatrix;\n                }\n                paths = itemData.sh.paths;\n                jLen = paths._length;\n                if (redraw) {\n                    pathStringTransformed = \"\";\n                    for(j = 0; j < jLen; j += 1){\n                        pathNodes = paths.shapes[j];\n                        if (pathNodes && pathNodes._length) {\n                            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\n                        }\n                    }\n                    itemData.caches[l] = pathStringTransformed;\n                } else {\n                    pathStringTransformed = itemData.caches[l];\n                }\n                itemData.styles[l].d += styleData.hd === true ? \"\" : pathStringTransformed;\n                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\n            }\n        }\n        function renderFill(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            if (itemData.c._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"fill\", \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\");\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"fill-opacity\", itemData.o.v);\n            }\n        }\n        function renderGradientStroke(styleData, itemData, isFirstFrame) {\n            renderGradient(styleData, itemData, isFirstFrame);\n            renderStroke(styleData, itemData, isFirstFrame);\n        }\n        function renderGradient(styleData, itemData, isFirstFrame) {\n            var gfill = itemData.gf;\n            var hasOpacity = itemData.g._hasOpacity;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (itemData.o._mdf || isFirstFrame) {\n                var attr = styleData.ty === \"gf\" ? \"fill-opacity\" : \"stroke-opacity\";\n                itemData.style.pElem.setAttribute(attr, itemData.o.v);\n            }\n            if (itemData.s._mdf || isFirstFrame) {\n                var attr1 = styleData.t === 1 ? \"x1\" : \"cx\";\n                var attr2 = attr1 === \"x1\" ? \"y1\" : \"cy\";\n                gfill.setAttribute(attr1, pt1[0]);\n                gfill.setAttribute(attr2, pt1[1]);\n                if (hasOpacity && !itemData.g._collapsable) {\n                    itemData.of.setAttribute(attr1, pt1[0]);\n                    itemData.of.setAttribute(attr2, pt1[1]);\n                }\n            }\n            var stops;\n            var i;\n            var len;\n            var stop;\n            if (itemData.g._cmdf || isFirstFrame) {\n                stops = itemData.cst;\n                var cValues = itemData.g.c;\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    stop.setAttribute(\"offset\", cValues[i * 4] + \"%\");\n                    stop.setAttribute(\"stop-color\", \"rgb(\" + cValues[i * 4 + 1] + \",\" + cValues[i * 4 + 2] + \",\" + cValues[i * 4 + 3] + \")\");\n                }\n            }\n            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n                var oValues = itemData.g.o;\n                if (itemData.g._collapsable) {\n                    stops = itemData.cst;\n                } else {\n                    stops = itemData.ost;\n                }\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    if (!itemData.g._collapsable) {\n                        stop.setAttribute(\"offset\", oValues[i * 2] + \"%\");\n                    }\n                    stop.setAttribute(\"stop-opacity\", oValues[i * 2 + 1]);\n                }\n            }\n            if (styleData.t === 1) {\n                if (itemData.e._mdf || isFirstFrame) {\n                    gfill.setAttribute(\"x2\", pt2[0]);\n                    gfill.setAttribute(\"y2\", pt2[1]);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"x2\", pt2[0]);\n                        itemData.of.setAttribute(\"y2\", pt2[1]);\n                    }\n                }\n            } else {\n                var rad;\n                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    gfill.setAttribute(\"r\", rad);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"r\", rad);\n                    }\n                }\n                if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n                    if (!rad) {\n                        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    }\n                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                    var percent = itemData.h.v;\n                    if (percent >= 1) {\n                        percent = 0.99;\n                    } else if (percent <= -1) {\n                        percent = -0.99;\n                    }\n                    var dist = rad * percent;\n                    var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                    var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                    gfill.setAttribute(\"fx\", x);\n                    gfill.setAttribute(\"fy\", y);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute(\"fx\", x);\n                        itemData.of.setAttribute(\"fy\", y);\n                    }\n                } // gfill.setAttribute('fy','200');\n            }\n        }\n        function renderStroke(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            var d = itemData.d;\n            if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n                styleElem.pElem.setAttribute(\"stroke-dasharray\", d.dashStr);\n                styleElem.pElem.setAttribute(\"stroke-dashoffset\", d.dashoffset[0]);\n            }\n            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n                styleElem.pElem.setAttribute(\"stroke\", \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\");\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"stroke-opacity\", itemData.o.v);\n            }\n            if (itemData.w._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute(\"stroke-width\", itemData.w.v);\n                if (styleElem.msElem) {\n                    styleElem.msElem.setAttribute(\"stroke-width\", itemData.w.v);\n                }\n            }\n        }\n        return ob;\n    }();\n    function SVGShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = []; // Full shape data\n        this.shapesData = data.shapes; // List of styles that will be applied to shapes\n        this.stylesList = []; // List of modifiers that will be applied to shapes\n        this.shapeModifiers = []; // List of items in shape tree\n        this.itemsData = []; // List of items in previous shape tree\n        this.processedElements = []; // List of animated components\n        this.animatedContents = [];\n        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = []; // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], SVGShapeElement);\n    SVGShapeElement.prototype.initSecondaryElement = function() {};\n    SVGShapeElement.prototype.identityMatrix = new Matrix();\n    SVGShapeElement.prototype.buildExpressionInterface = function() {};\n    SVGShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n    };\n    /*\r\n  This method searches for multiple shapes that affect a single element and one of them is animated\r\n  */ SVGShapeElement.prototype.filterUniqueShapes = function() {\n        var i;\n        var len = this.shapes.length;\n        var shape;\n        var j;\n        var jLen = this.stylesList.length;\n        var style;\n        var tempShapes = [];\n        var areAnimated = false;\n        for(j = 0; j < jLen; j += 1){\n            style = this.stylesList[j];\n            areAnimated = false;\n            tempShapes.length = 0;\n            for(i = 0; i < len; i += 1){\n                shape = this.shapes[i];\n                if (shape.styles.indexOf(style) !== -1) {\n                    tempShapes.push(shape);\n                    areAnimated = shape._isAnimated || areAnimated;\n                }\n            }\n            if (tempShapes.length > 1 && areAnimated) {\n                this.setShapesAsAnimated(tempShapes);\n            }\n        }\n    };\n    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {\n        var i;\n        var len = shapes.length;\n        for(i = 0; i < len; i += 1){\n            shapes[i].setAsAnimated();\n        }\n    };\n    SVGShapeElement.prototype.createStyleElement = function(data, level) {\n        // TODO: prevent drawing of hidden styles\n        var elementData;\n        var styleOb = new SVGStyleData(data, level);\n        var pathElement = styleOb.pElem;\n        if (data.ty === \"st\") {\n            elementData = new SVGStrokeStyleData(this, data, styleOb);\n        } else if (data.ty === \"fl\") {\n            elementData = new SVGFillStyleData(this, data, styleOb);\n        } else if (data.ty === \"gf\" || data.ty === \"gs\") {\n            var GradientConstructor = data.ty === \"gf\" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\n            elementData = new GradientConstructor(this, data, styleOb);\n            this.globalData.defs.appendChild(elementData.gf);\n            if (elementData.maskId) {\n                this.globalData.defs.appendChild(elementData.ms);\n                this.globalData.defs.appendChild(elementData.of);\n                pathElement.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + elementData.maskId + \")\");\n            }\n        } else if (data.ty === \"no\") {\n            elementData = new SVGNoStyleData(this, data, styleOb);\n        }\n        if (data.ty === \"st\" || data.ty === \"gs\") {\n            pathElement.setAttribute(\"stroke-linecap\", lineCapEnum[data.lc || 2]);\n            pathElement.setAttribute(\"stroke-linejoin\", lineJoinEnum[data.lj || 2]);\n            pathElement.setAttribute(\"fill-opacity\", \"0\");\n            if (data.lj === 1) {\n                pathElement.setAttribute(\"stroke-miterlimit\", data.ml);\n            }\n        }\n        if (data.r === 2) {\n            pathElement.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        if (data.ln) {\n            pathElement.setAttribute(\"id\", data.ln);\n        }\n        if (data.cl) {\n            pathElement.setAttribute(\"class\", data.cl);\n        }\n        if (data.bm) {\n            pathElement.style[\"mix-blend-mode\"] = getBlendMode(data.bm);\n        }\n        this.stylesList.push(styleOb);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createGroupElement = function(data) {\n        var elementData = new ShapeGroupData();\n        if (data.ln) {\n            elementData.gr.setAttribute(\"id\", data.ln);\n        }\n        if (data.cl) {\n            elementData.gr.setAttribute(\"class\", data.cl);\n        }\n        if (data.bm) {\n            elementData.gr.style[\"mix-blend-mode\"] = getBlendMode(data.bm);\n        }\n        return elementData;\n    };\n    SVGShapeElement.prototype.createTransformElement = function(data, container) {\n        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);\n        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {\n        var ty = 4;\n        if (data.ty === \"rc\") {\n            ty = 5;\n        } else if (data.ty === \"el\") {\n            ty = 6;\n        } else if (data.ty === \"sr\") {\n            ty = 7;\n        }\n        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);\n        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {\n        var i = 0;\n        var len = this.animatedContents.length;\n        while(i < len){\n            if (this.animatedContents[i].element === element) {\n                return;\n            }\n            i += 1;\n        }\n        this.animatedContents.push({\n            fn: SVGElementsRenderer.createRenderFunction(data),\n            element: element,\n            data: data\n        });\n    };\n    SVGShapeElement.prototype.setElementStyles = function(elementData) {\n        var arr = elementData.styles;\n        var j;\n        var jLen = this.stylesList.length;\n        for(j = 0; j < jLen; j += 1){\n            if (!this.stylesList[j].closed) {\n                arr.push(this.stylesList[j]);\n            }\n        }\n    };\n    SVGShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n    };\n    SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {\n        var ownTransformers = [].concat(transformers);\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var currentTransform;\n        var modifier;\n        var processedPos;\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._render = render;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === \"fl\" || arr[i].ty === \"st\" || arr[i].ty === \"gf\" || arr[i].ty === \"gs\" || arr[i].ty === \"no\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], level);\n                } else {\n                    itemsData[i].style.closed = false;\n                }\n                if (arr[i]._render) {\n                    if (itemsData[i].style.pElem.parentNode !== container) {\n                        container.appendChild(itemsData[i].style.pElem);\n                    }\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === \"gr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);\n                if (arr[i]._render) {\n                    if (itemsData[i].gr.parentNode !== container) {\n                        container.appendChild(itemsData[i].gr);\n                    }\n                }\n            } else if (arr[i].ty === \"tr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createTransformElement(arr[i], container);\n                }\n                currentTransform = itemsData[i].transform;\n                ownTransformers.push(currentTransform);\n            } else if (arr[i].ty === \"sh\" || arr[i].ty === \"rc\" || arr[i].ty === \"el\" || arr[i].ty === \"sr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\n                }\n                this.setElementStyles(itemsData[i]);\n            } else if (arr[i].ty === \"tm\" || arr[i].ty === \"rd\" || arr[i].ty === \"ms\" || arr[i].ty === \"pb\" || arr[i].ty === \"zz\" || arr[i].ty === \"op\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === \"rp\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    render = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        len = ownStyles.length;\n        for(i = 0; i < len; i += 1){\n            ownStyles[i].closed = true;\n        }\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    SVGShapeElement.prototype.renderInnerContent = function() {\n        this.renderModifiers();\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            this.stylesList[i].reset();\n        }\n        this.renderShape();\n        for(i = 0; i < len; i += 1){\n            if (this.stylesList[i]._mdf || this._isFirstFrame) {\n                if (this.stylesList[i].msElem) {\n                    this.stylesList[i].msElem.setAttribute(\"d\", this.stylesList[i].d); // Adding M0 0 fixes same mask bug on all browsers\n                    this.stylesList[i].d = \"M0 0\" + this.stylesList[i].d;\n                }\n                this.stylesList[i].pElem.setAttribute(\"d\", this.stylesList[i].d || \"M0 0\");\n            }\n        }\n    };\n    SVGShapeElement.prototype.renderShape = function() {\n        var i;\n        var len = this.animatedContents.length;\n        var animatedContent;\n        for(i = 0; i < len; i += 1){\n            animatedContent = this.animatedContents[i];\n            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n                animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\n            }\n        }\n    };\n    SVGShapeElement.prototype.destroy = function() {\n        this.destroyBaseElement();\n        this.shapesData = null;\n        this.itemsData = null;\n    };\n    function LetterProps(o, sw, sc, fc, m, p) {\n        this.o = o;\n        this.sw = sw;\n        this.sc = sc;\n        this.fc = fc;\n        this.m = m;\n        this.p = p;\n        this._mdf = {\n            o: true,\n            sw: !!sw,\n            sc: !!sc,\n            fc: !!fc,\n            m: true,\n            p: true\n        };\n    }\n    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {\n        this._mdf.o = false;\n        this._mdf.sw = false;\n        this._mdf.sc = false;\n        this._mdf.fc = false;\n        this._mdf.m = false;\n        this._mdf.p = false;\n        var updated = false;\n        if (this.o !== o) {\n            this.o = o;\n            this._mdf.o = true;\n            updated = true;\n        }\n        if (this.sw !== sw) {\n            this.sw = sw;\n            this._mdf.sw = true;\n            updated = true;\n        }\n        if (this.sc !== sc) {\n            this.sc = sc;\n            this._mdf.sc = true;\n            updated = true;\n        }\n        if (this.fc !== fc) {\n            this.fc = fc;\n            this._mdf.fc = true;\n            updated = true;\n        }\n        if (this.m !== m) {\n            this.m = m;\n            this._mdf.m = true;\n            updated = true;\n        }\n        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\n            this.p = p;\n            this._mdf.p = true;\n            updated = true;\n        }\n        return updated;\n    };\n    function TextProperty(elem, data) {\n        this._frameId = initialDefaultFrame;\n        this.pv = \"\";\n        this.v = \"\";\n        this.kf = false;\n        this._isFirstFrame = true;\n        this._mdf = false;\n        if (data.d && data.d.sid) {\n            data.d = elem.globalData.slotManager.getProp(data.d);\n        }\n        this.data = data;\n        this.elem = elem;\n        this.comp = this.elem.comp;\n        this.keysIndex = 0;\n        this.canResize = false;\n        this.minimumFontSize = 1;\n        this.effectsSequence = [];\n        this.currentData = {\n            ascent: 0,\n            boxWidth: this.defaultBoxWidth,\n            f: \"\",\n            fStyle: \"\",\n            fWeight: \"\",\n            fc: \"\",\n            j: \"\",\n            justifyOffset: \"\",\n            l: [],\n            lh: 0,\n            lineWidths: [],\n            ls: \"\",\n            of: \"\",\n            s: \"\",\n            sc: \"\",\n            sw: 0,\n            t: 0,\n            tr: 0,\n            sz: 0,\n            ps: null,\n            fillColorAnim: false,\n            strokeColorAnim: false,\n            strokeWidthAnim: false,\n            yOffset: 0,\n            finalSize: 0,\n            finalText: [],\n            finalLineHeight: 0,\n            __complete: false\n        };\n        this.copyData(this.currentData, this.data.d.k[0].s);\n        if (!this.searchProperty()) {\n            this.completeTextData(this.currentData);\n        }\n    }\n    TextProperty.prototype.defaultBoxWidth = [\n        0,\n        0\n    ];\n    TextProperty.prototype.copyData = function(obj, data) {\n        for(var s in data){\n            if (Object.prototype.hasOwnProperty.call(data, s)) {\n                obj[s] = data[s];\n            }\n        }\n        return obj;\n    };\n    TextProperty.prototype.setCurrentData = function(data) {\n        if (!data.__complete) {\n            this.completeTextData(data);\n        }\n        this.currentData = data;\n        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\n        this._mdf = true;\n    };\n    TextProperty.prototype.searchProperty = function() {\n        return this.searchKeyframes();\n    };\n    TextProperty.prototype.searchKeyframes = function() {\n        this.kf = this.data.d.k.length > 1;\n        if (this.kf) {\n            this.addEffect(this.getKeyframeValue.bind(this));\n        }\n        return this.kf;\n    };\n    TextProperty.prototype.addEffect = function(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.getValue = function(_finalValue) {\n        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n            return;\n        }\n        this.currentData.t = this.data.d.k[this.keysIndex].s.t;\n        var currentValue = this.currentData;\n        var currentIndex = this.keysIndex;\n        if (this.lock) {\n            this.setCurrentData(this.currentData);\n            return;\n        }\n        this.lock = true;\n        this._mdf = false;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\n        for(i = 0; i < len; i += 1){\n            // Checking if index changed to prevent creating a new object every time the expression updates.\n            if (currentIndex !== this.keysIndex) {\n                finalValue = this.effectsSequence[i](finalValue, finalValue.t);\n            } else {\n                finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\n            }\n        }\n        if (currentValue !== finalValue) {\n            this.setCurrentData(finalValue);\n        }\n        this.v = this.currentData;\n        this.pv = this.v;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    };\n    TextProperty.prototype.getKeyframeValue = function() {\n        var textKeys = this.data.d.k;\n        var frameNum = this.elem.comp.renderedFrame;\n        var i = 0;\n        var len = textKeys.length;\n        while(i <= len - 1){\n            if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n                break;\n            }\n            i += 1;\n        }\n        if (this.keysIndex !== i) {\n            this.keysIndex = i;\n        }\n        return this.data.d.k[this.keysIndex].s;\n    };\n    TextProperty.prototype.buildFinalText = function(text) {\n        var charactersArray = [];\n        var i = 0;\n        var len = text.length;\n        var charCode;\n        var secondCharCode;\n        var shouldCombine = false;\n        var shouldCombineNext = false;\n        var currentChars = \"\";\n        while(i < len){\n            shouldCombine = shouldCombineNext;\n            shouldCombineNext = false;\n            charCode = text.charCodeAt(i);\n            currentChars = text.charAt(i);\n            if (FontManager.isCombinedCharacter(charCode)) {\n                shouldCombine = true; // It's a potential surrogate pair (this is the High surrogate)\n            } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n                if (FontManager.isRegionalFlag(text, i)) {\n                    currentChars = text.substr(i, 14);\n                } else {\n                    secondCharCode = text.charCodeAt(i + 1); // It's a surrogate pair (this is the Low surrogate)\n                    if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {\n                        if (FontManager.isModifier(charCode, secondCharCode)) {\n                            currentChars = text.substr(i, 2);\n                            shouldCombine = true;\n                        } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {\n                            currentChars = text.substr(i, 4);\n                        } else {\n                            currentChars = text.substr(i, 2);\n                        }\n                    }\n                }\n            } else if (charCode > 0xDBFF) {\n                secondCharCode = text.charCodeAt(i + 1);\n                if (FontManager.isVariationSelector(charCode)) {\n                    shouldCombine = true;\n                }\n            } else if (FontManager.isZeroWidthJoiner(charCode)) {\n                shouldCombine = true;\n                shouldCombineNext = true;\n            }\n            if (shouldCombine) {\n                charactersArray[charactersArray.length - 1] += currentChars;\n                shouldCombine = false;\n            } else {\n                charactersArray.push(currentChars);\n            }\n            i += currentChars.length;\n        }\n        return charactersArray;\n    };\n    TextProperty.prototype.completeTextData = function(documentData) {\n        documentData.__complete = true;\n        var fontManager = this.elem.globalData.fontManager;\n        var data = this.data;\n        var letters = [];\n        var i;\n        var len;\n        var newLineFlag;\n        var index = 0;\n        var val;\n        var anchorGrouping = data.m.g;\n        var currentSize = 0;\n        var currentPos = 0;\n        var currentLine = 0;\n        var lineWidths = [];\n        var lineWidth = 0;\n        var maxLineWidth = 0;\n        var j;\n        var jLen;\n        var fontData = fontManager.getFontByName(documentData.f);\n        var charData;\n        var cLength = 0;\n        var fontProps = getFontProperties(fontData);\n        documentData.fWeight = fontProps.weight;\n        documentData.fStyle = fontProps.style;\n        documentData.finalSize = documentData.s;\n        documentData.finalText = this.buildFinalText(documentData.t);\n        len = documentData.finalText.length;\n        documentData.finalLineHeight = documentData.lh;\n        var trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n        var charCode;\n        if (documentData.sz) {\n            var flag = true;\n            var boxWidth = documentData.sz[0];\n            var boxHeight = documentData.sz[1];\n            var currentHeight;\n            var finalText;\n            while(flag){\n                finalText = this.buildFinalText(documentData.t);\n                currentHeight = 0;\n                lineWidth = 0;\n                len = finalText.length;\n                trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n                var lastSpaceIndex = -1;\n                for(i = 0; i < len; i += 1){\n                    charCode = finalText[i].charCodeAt(0);\n                    newLineFlag = false;\n                    if (finalText[i] === \" \") {\n                        lastSpaceIndex = i;\n                    } else if (charCode === 13 || charCode === 3) {\n                        lineWidth = 0;\n                        newLineFlag = true;\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                    }\n                    if (fontManager.chars) {\n                        charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\n                        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n                    } else {\n                        // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n                        cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\n                    }\n                    if (lineWidth + cLength > boxWidth && finalText[i] !== \" \") {\n                        if (lastSpaceIndex === -1) {\n                            len += 1;\n                        } else {\n                            i = lastSpaceIndex;\n                        }\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                        finalText.splice(i, lastSpaceIndex === i ? 1 : 0, \"\\r\"); // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n                        lastSpaceIndex = -1;\n                        lineWidth = 0;\n                    } else {\n                        lineWidth += cLength;\n                        lineWidth += trackingOffset;\n                    }\n                }\n                currentHeight += fontData.ascent * documentData.finalSize / 100;\n                if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n                    documentData.finalSize -= 1;\n                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\n                } else {\n                    documentData.finalText = finalText;\n                    len = documentData.finalText.length;\n                    flag = false;\n                }\n            }\n        }\n        lineWidth = -trackingOffset;\n        cLength = 0;\n        var uncollapsedSpaces = 0;\n        var currentChar;\n        for(i = 0; i < len; i += 1){\n            newLineFlag = false;\n            currentChar = documentData.finalText[i];\n            charCode = currentChar.charCodeAt(0);\n            if (charCode === 13 || charCode === 3) {\n                uncollapsedSpaces = 0;\n                lineWidths.push(lineWidth);\n                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n                lineWidth = -2 * trackingOffset;\n                val = \"\";\n                newLineFlag = true;\n                currentLine += 1;\n            } else {\n                val = currentChar;\n            }\n            if (fontManager.chars) {\n                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\n                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n            } else {\n                // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n                // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n                cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\n            } //\n            if (currentChar === \" \") {\n                uncollapsedSpaces += cLength + trackingOffset;\n            } else {\n                lineWidth += cLength + trackingOffset + uncollapsedSpaces;\n                uncollapsedSpaces = 0;\n            }\n            letters.push({\n                l: cLength,\n                an: cLength,\n                add: currentSize,\n                n: newLineFlag,\n                anIndexes: [],\n                val: val,\n                line: currentLine,\n                animatorJustifyOffset: 0\n            });\n            if (anchorGrouping == 2) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === \"\" || val === \" \" || i === len - 1) {\n                    if (val === \"\" || val === \" \") {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    index += 1;\n                    currentSize = 0;\n                }\n            } else if (anchorGrouping == 3) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === \"\" || i === len - 1) {\n                    if (val === \"\") {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    currentSize = 0;\n                    index += 1;\n                }\n            } else {\n                letters[index].ind = index;\n                letters[index].extra = 0;\n                index += 1;\n            }\n        }\n        documentData.l = letters;\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n        lineWidths.push(lineWidth);\n        if (documentData.sz) {\n            documentData.boxWidth = documentData.sz[0];\n            documentData.justifyOffset = 0;\n        } else {\n            documentData.boxWidth = maxLineWidth;\n            switch(documentData.j){\n                case 1:\n                    documentData.justifyOffset = -documentData.boxWidth;\n                    break;\n                case 2:\n                    documentData.justifyOffset = -documentData.boxWidth / 2;\n                    break;\n                default:\n                    documentData.justifyOffset = 0;\n            }\n        }\n        documentData.lineWidths = lineWidths;\n        var animators = data.a;\n        var animatorData;\n        var letterData;\n        jLen = animators.length;\n        var based;\n        var ind;\n        var indexes = [];\n        for(j = 0; j < jLen; j += 1){\n            animatorData = animators[j];\n            if (animatorData.a.sc) {\n                documentData.strokeColorAnim = true;\n            }\n            if (animatorData.a.sw) {\n                documentData.strokeWidthAnim = true;\n            }\n            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n                documentData.fillColorAnim = true;\n            }\n            ind = 0;\n            based = animatorData.s.b;\n            for(i = 0; i < len; i += 1){\n                letterData = letters[i];\n                letterData.anIndexes[j] = ind;\n                if (based == 1 && letterData.val !== \"\" || based == 2 && letterData.val !== \"\" && letterData.val !== \" \" || based == 3 && (letterData.n || letterData.val == \" \" || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {\n                    // eslint-disable-line eqeqeq\n                    if (animatorData.s.rn === 1) {\n                        indexes.push(ind);\n                    }\n                    ind += 1;\n                }\n            }\n            data.a[j].s.totalChars = ind;\n            var currentInd = -1;\n            var newInd;\n            if (animatorData.s.rn === 1) {\n                for(i = 0; i < len; i += 1){\n                    letterData = letters[i];\n                    if (currentInd != letterData.anIndexes[j]) {\n                        // eslint-disable-line eqeqeq\n                        currentInd = letterData.anIndexes[j];\n                        newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];\n                    }\n                    letterData.anIndexes[j] = newInd;\n                }\n            }\n        }\n        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;\n        documentData.ls = documentData.ls || 0;\n        documentData.ascent = fontData.ascent * documentData.finalSize / 100;\n    };\n    TextProperty.prototype.updateDocumentData = function(newData, index) {\n        index = index === undefined ? this.keysIndex : index;\n        var dData = this.copyData({}, this.data.d.k[index].s);\n        dData = this.copyData(dData, newData);\n        this.data.d.k[index].s = dData;\n        this.recalculate(index);\n        this.setCurrentData(dData);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.recalculate = function(index) {\n        var dData = this.data.d.k[index].s;\n        dData.__complete = false;\n        this.keysIndex = 0;\n        this._isFirstFrame = true;\n        this.getValue(dData);\n    };\n    TextProperty.prototype.canResizeFont = function(_canResize) {\n        this.canResize = _canResize;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {\n        this.minimumFontSize = Math.floor(_fontValue) || 1;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    var TextSelectorProp = function() {\n        var max = Math.max;\n        var min = Math.min;\n        var floor = Math.floor;\n        function TextSelectorPropFactory(elem, data) {\n            this._currentTextLength = -1;\n            this.k = false;\n            this.data = data;\n            this.elem = elem;\n            this.comp = elem.comp;\n            this.finalS = 0;\n            this.finalE = 0;\n            this.initDynamicPropertyContainer(elem);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: 0\n            }, 0, 0, this);\n            if (\"e\" in data) {\n                this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);\n            } else {\n                this.e = {\n                    v: 100\n                };\n            }\n            this.o = PropertyFactory.getProp(elem, data.o || {\n                k: 0\n            }, 0, 0, this);\n            this.xe = PropertyFactory.getProp(elem, data.xe || {\n                k: 0\n            }, 0, 0, this);\n            this.ne = PropertyFactory.getProp(elem, data.ne || {\n                k: 0\n            }, 0, 0, this);\n            this.sm = PropertyFactory.getProp(elem, data.sm || {\n                k: 100\n            }, 0, 0, this);\n            this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);\n            if (!this.dynamicProperties.length) {\n                this.getValue();\n            }\n        }\n        TextSelectorPropFactory.prototype = {\n            getMult: function getMult(ind) {\n                if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n                    this.getValue();\n                }\n                var x1 = 0;\n                var y1 = 0;\n                var x2 = 1;\n                var y2 = 1;\n                if (this.ne.v > 0) {\n                    x1 = this.ne.v / 100.0;\n                } else {\n                    y1 = -this.ne.v / 100.0;\n                }\n                if (this.xe.v > 0) {\n                    x2 = 1.0 - this.xe.v / 100.0;\n                } else {\n                    y2 = 1.0 + this.xe.v / 100.0;\n                }\n                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;\n                var mult = 0;\n                var s = this.finalS;\n                var e = this.finalE;\n                var type = this.data.sh;\n                if (type === 2) {\n                    if (e === s) {\n                        mult = ind >= e ? 1 : 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 3) {\n                    if (e === s) {\n                        mult = ind >= e ? 0 : 1;\n                    } else {\n                        mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 4) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                        if (mult < 0.5) {\n                            mult *= 2;\n                        } else {\n                            mult = 1 - 2 * (mult - 0.5);\n                        }\n                    }\n                    mult = easer(mult);\n                } else if (type === 5) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        var tot = e - s;\n                        /* ind += 0.5;\r\n                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */ ind = min(max(0, ind + 0.5 - s), e - s);\n                        var x = -tot / 2 + ind;\n                        var a = tot / 2;\n                        mult = Math.sqrt(1 - x * x / (a * a));\n                    }\n                    mult = easer(mult);\n                } else if (type === 6) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        ind = min(max(0, ind + 0.5 - s), e - s);\n                        mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line\n                    }\n                    mult = easer(mult);\n                } else {\n                    if (ind >= floor(s)) {\n                        if (ind - s < 0) {\n                            mult = max(0, min(min(e, 1) - (s - ind), 1));\n                        } else {\n                            mult = max(0, min(e - ind, 1));\n                        }\n                    }\n                    mult = easer(mult);\n                } // Smoothness implementation.\n                // The smoothness represents a reduced range of the original [0; 1] range.\n                // if smoothness is 25%, the new range will be [0.375; 0.625]\n                // Steps are:\n                // - find the lower value of the new range (threshold)\n                // - if multiplier is smaller than that value, floor it to 0\n                // - if it is larger,\n                //     - subtract the threshold\n                //     - divide it by the smoothness (this will return the range to [0; 1])\n                // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n                if (this.sm.v !== 100) {\n                    var smoothness = this.sm.v * 0.01;\n                    if (smoothness === 0) {\n                        smoothness = 0.00000001;\n                    }\n                    var threshold = 0.5 - smoothness * 0.5;\n                    if (mult < threshold) {\n                        mult = 0;\n                    } else {\n                        mult = (mult - threshold) / smoothness;\n                        if (mult > 1) {\n                            mult = 1;\n                        }\n                    }\n                }\n                return mult * this.a.v;\n            },\n            getValue: function getValue(newCharsFlag) {\n                this.iterateDynamicProperties();\n                this._mdf = newCharsFlag || this._mdf;\n                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\n                if (newCharsFlag && this.data.r === 2) {\n                    this.e.v = this._currentTextLength;\n                }\n                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\n                var o = this.o.v / divisor;\n                var s = this.s.v / divisor + o;\n                var e = this.e.v / divisor + o;\n                if (s > e) {\n                    var _s = s;\n                    s = e;\n                    e = _s;\n                }\n                this.finalS = s;\n                this.finalE = e;\n            }\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TextSelectorPropFactory);\n        function getTextSelectorProp(elem, data, arr) {\n            return new TextSelectorPropFactory(elem, data, arr);\n        }\n        return {\n            getTextSelectorProp: getTextSelectorProp\n        };\n    }();\n    function TextAnimatorDataProperty(elem, animatorProps, container) {\n        var defaultData = {\n            propType: false\n        };\n        var getProp = PropertyFactory.getProp;\n        var textAnimatorAnimatables = animatorProps.a;\n        this.a = {\n            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData\n        };\n        this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);\n        this.s.t = animatorProps.s.t;\n    }\n    function TextAnimatorProperty(textData, renderType, elem) {\n        this._isFirstFrame = true;\n        this._hasMaskedPath = false;\n        this._frameId = -1;\n        this._textData = textData;\n        this._renderType = renderType;\n        this._elem = elem;\n        this._animatorsData = createSizedArray(this._textData.a.length);\n        this._pathData = {};\n        this._moreOptions = {\n            alignment: {}\n        };\n        this.renderedLetters = [];\n        this.lettersChangedFlag = false;\n        this.initDynamicPropertyContainer(elem);\n    }\n    TextAnimatorProperty.prototype.searchProperties = function() {\n        var i;\n        var len = this._textData.a.length;\n        var animatorProps;\n        var getProp = PropertyFactory.getProp;\n        for(i = 0; i < len; i += 1){\n            animatorProps = this._textData.a[i];\n            this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\n        }\n        if (this._textData.p && \"m\" in this._textData.p) {\n            this._pathData = {\n                a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n                f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n                l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n                r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n                p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\n            };\n            this._hasMaskedPath = true;\n        } else {\n            this._hasMaskedPath = false;\n        }\n        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);\n    };\n    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {\n        this.lettersChangedFlag = lettersChangedFlag;\n        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n            return;\n        }\n        this._isFirstFrame = false;\n        var alignment = this._moreOptions.alignment.v;\n        var animators = this._animatorsData;\n        var textData = this._textData;\n        var matrixHelper = this.mHelper;\n        var renderType = this._renderType;\n        var renderedLettersCount = this.renderedLetters.length;\n        var xPos;\n        var yPos;\n        var i;\n        var len;\n        var letters = documentData.l;\n        var pathInfo;\n        var currentLength;\n        var currentPoint;\n        var segmentLength;\n        var flag;\n        var pointInd;\n        var segmentInd;\n        var prevPoint;\n        var points;\n        var segments;\n        var partialLength;\n        var totalLength;\n        var perc;\n        var tanAngle;\n        var mask;\n        if (this._hasMaskedPath) {\n            mask = this._pathData.m;\n            if (!this._pathData.n || this._pathData._mdf) {\n                var paths = mask.v;\n                if (this._pathData.r.v) {\n                    paths = paths.reverse();\n                } // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n                pathInfo = {\n                    tLength: 0,\n                    segments: []\n                };\n                len = paths._length - 1;\n                var bezierData;\n                totalLength = 0;\n                for(i = 0; i < len; i += 1){\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[i + 1][0] - paths.v[i + 1][0],\n                        paths.i[i + 1][1] - paths.v[i + 1][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                i = len;\n                if (mask.v.c) {\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[0][0] - paths.v[0][0],\n                        paths.i[0][1] - paths.v[0][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                this._pathData.pi = pathInfo;\n            }\n            pathInfo = this._pathData.pi;\n            currentLength = this._pathData.f.v;\n            segmentInd = 0;\n            pointInd = 1;\n            segmentLength = 0;\n            flag = true;\n            segments = pathInfo.segments;\n            if (currentLength < 0 && mask.v.c) {\n                if (pathInfo.tLength < Math.abs(currentLength)) {\n                    currentLength = -Math.abs(currentLength) % pathInfo.tLength;\n                }\n                segmentInd = segments.length - 1;\n                points = segments[segmentInd].points;\n                pointInd = points.length - 1;\n                while(currentLength < 0){\n                    currentLength += points[pointInd].partialLength;\n                    pointInd -= 1;\n                    if (pointInd < 0) {\n                        segmentInd -= 1;\n                        points = segments[segmentInd].points;\n                        pointInd = points.length - 1;\n                    }\n                }\n            }\n            points = segments[segmentInd].points;\n            prevPoint = points[pointInd - 1];\n            currentPoint = points[pointInd];\n            partialLength = currentPoint.partialLength;\n        }\n        len = letters.length;\n        xPos = 0;\n        yPos = 0;\n        var yOff = documentData.finalSize * 1.2 * 0.714;\n        var firstLine = true;\n        var animatorProps;\n        var animatorSelector;\n        var j;\n        var jLen;\n        var letterValue;\n        jLen = animators.length;\n        var mult;\n        var ind = -1;\n        var offf;\n        var xPathPos;\n        var yPathPos;\n        var initPathPos = currentLength;\n        var initSegmentInd = segmentInd;\n        var initPointInd = pointInd;\n        var currentLine = -1;\n        var elemOpacity;\n        var sc;\n        var sw;\n        var fc;\n        var k;\n        var letterSw;\n        var letterSc;\n        var letterFc;\n        var letterM = \"\";\n        var letterP = this.defaultPropsArray;\n        var letterO; //\n        if (documentData.j === 2 || documentData.j === 1) {\n            var animatorJustifyOffset = 0;\n            var animatorFirstCharOffset = 0;\n            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\n            var lastIndex = 0;\n            var isNewLine = true;\n            for(i = 0; i < len; i += 1){\n                if (letters[i].n) {\n                    if (animatorJustifyOffset) {\n                        animatorJustifyOffset += animatorFirstCharOffset;\n                    }\n                    while(lastIndex < i){\n                        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                        lastIndex += 1;\n                    }\n                    animatorJustifyOffset = 0;\n                    isNewLine = true;\n                } else {\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.t.propType) {\n                            if (isNewLine && documentData.j === 2) {\n                                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\n                            }\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;\n                            } else {\n                                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;\n                            }\n                        }\n                    }\n                    isNewLine = false;\n                }\n            }\n            if (animatorJustifyOffset) {\n                animatorJustifyOffset += animatorFirstCharOffset;\n            }\n            while(lastIndex < i){\n                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                lastIndex += 1;\n            }\n        } //\n        for(i = 0; i < len; i += 1){\n            matrixHelper.reset();\n            elemOpacity = 1;\n            if (letters[i].n) {\n                xPos = 0;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                currentLength = initPathPos;\n                firstLine = false;\n                if (this._hasMaskedPath) {\n                    segmentInd = initSegmentInd;\n                    pointInd = initPointInd;\n                    points = segments[segmentInd].points;\n                    prevPoint = points[pointInd - 1];\n                    currentPoint = points[pointInd];\n                    partialLength = currentPoint.partialLength;\n                    segmentLength = 0;\n                }\n                letterM = \"\";\n                letterFc = \"\";\n                letterSw = \"\";\n                letterO = \"\";\n                letterP = this.defaultPropsArray;\n            } else {\n                if (this._hasMaskedPath) {\n                    if (currentLine !== letters[i].line) {\n                        switch(documentData.j){\n                            case 1:\n                                currentLength += totalLength - documentData.lineWidths[letters[i].line];\n                                break;\n                            case 2:\n                                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;\n                                break;\n                            default:\n                                break;\n                        }\n                        currentLine = letters[i].line;\n                    }\n                    if (ind !== letters[i].ind) {\n                        if (letters[ind]) {\n                            currentLength += letters[ind].extra;\n                        }\n                        currentLength += letters[i].an / 2;\n                        ind = letters[i].ind;\n                    }\n                    currentLength += alignment[0] * letters[i].an * 0.005;\n                    var animatorOffset = 0;\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.p.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.p.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.p.v[0] * mult;\n                            }\n                        }\n                        if (animatorProps.a.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.a.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.a.v[0] * mult;\n                            }\n                        }\n                    }\n                    flag = true; // Force alignment only works with a single line for now\n                    if (this._pathData.a.v) {\n                        currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);\n                        currentLength += this._pathData.f.v;\n                    }\n                    while(flag){\n                        if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n                            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\n                            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\n                            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\n                            matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);\n                            flag = false;\n                        } else if (points) {\n                            segmentLength += currentPoint.partialLength;\n                            pointInd += 1;\n                            if (pointInd >= points.length) {\n                                pointInd = 0;\n                                segmentInd += 1;\n                                if (!segments[segmentInd]) {\n                                    if (mask.v.c) {\n                                        pointInd = 0;\n                                        segmentInd = 0;\n                                        points = segments[segmentInd].points;\n                                    } else {\n                                        segmentLength -= currentPoint.partialLength;\n                                        points = null;\n                                    }\n                                } else {\n                                    points = segments[segmentInd].points;\n                                }\n                            }\n                            if (points) {\n                                prevPoint = currentPoint;\n                                currentPoint = points[pointInd];\n                                partialLength = currentPoint.partialLength;\n                            }\n                        }\n                    }\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0);\n                } else {\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0); // Grouping alignment\n                    matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.t.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars); // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n                        if (xPos !== 0 || documentData.j !== 0) {\n                            if (this._hasMaskedPath) {\n                                if (mult.length) {\n                                    currentLength += animatorProps.t.v * mult[0];\n                                } else {\n                                    currentLength += animatorProps.t.v * mult;\n                                }\n                            } else if (mult.length) {\n                                xPos += animatorProps.t.v * mult[0];\n                            } else {\n                                xPos += animatorProps.t.v * mult;\n                            }\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    sw = documentData.sw || 0;\n                }\n                if (documentData.strokeColorAnim) {\n                    if (documentData.sc) {\n                        sc = [\n                            documentData.sc[0],\n                            documentData.sc[1],\n                            documentData.sc[2]\n                        ];\n                    } else {\n                        sc = [\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    fc = [\n                        documentData.fc[0],\n                        documentData.fc[1],\n                        documentData.fc[2]\n                    ];\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.a.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.s.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);\n                        } else {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    animatorSelector = animators[j].s;\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                    if (animatorProps.sk.propType) {\n                        if (mult.length) {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\n                        } else {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\n                        }\n                    }\n                    if (animatorProps.r.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\n                        } else {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult);\n                        }\n                    }\n                    if (animatorProps.ry.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);\n                        } else {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult);\n                        }\n                    }\n                    if (animatorProps.rx.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);\n                        } else {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult);\n                        }\n                    }\n                    if (animatorProps.o.propType) {\n                        if (mult.length) {\n                            elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];\n                        } else {\n                            elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;\n                        }\n                    }\n                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n                        if (mult.length) {\n                            sw += animatorProps.sw.v * mult[0];\n                        } else {\n                            sw += animatorProps.sw.v * mult;\n                        }\n                    }\n                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n                        for(k = 0; k < 3; k += 1){\n                            if (mult.length) {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];\n                            } else {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;\n                            }\n                        }\n                    }\n                    if (documentData.fillColorAnim && documentData.fc) {\n                        if (animatorProps.fc.propType) {\n                            for(k = 0; k < 3; k += 1){\n                                if (mult.length) {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];\n                                } else {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;\n                                }\n                            }\n                        }\n                        if (animatorProps.fh.propType) {\n                            if (mult.length) {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);\n                            } else {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult);\n                            }\n                        }\n                        if (animatorProps.fs.propType) {\n                            if (mult.length) {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);\n                            } else {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);\n                            }\n                        }\n                        if (animatorProps.fb.propType) {\n                            if (mult.length) {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);\n                            } else {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);\n                            }\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.p.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (this._hasMaskedPath) {\n                            if (mult.length) {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\n                            } else {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                            }\n                        } else if (mult.length) {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    letterSw = sw < 0 ? 0 : sw;\n                }\n                if (documentData.strokeColorAnim) {\n                    letterSc = \"rgb(\" + Math.round(sc[0] * 255) + \",\" + Math.round(sc[1] * 255) + \",\" + Math.round(sc[2] * 255) + \")\";\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    letterFc = \"rgb(\" + Math.round(fc[0] * 255) + \",\" + Math.round(fc[1] * 255) + \",\" + Math.round(fc[2] * 255) + \")\";\n                }\n                if (this._hasMaskedPath) {\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);\n                    if (this._pathData.p.v) {\n                        tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\n                        var rot = Math.atan(tanAngle) * 180 / Math.PI;\n                        if (currentPoint.point[0] < prevPoint.point[0]) {\n                            rot += 180;\n                        }\n                        matrixHelper.rotate(-rot * Math.PI / 180);\n                    }\n                    matrixHelper.translate(xPathPos, yPathPos, 0);\n                    currentLength -= alignment[0] * letters[i].an * 0.005;\n                    if (letters[i + 1] && ind !== letters[i + 1].ind) {\n                        currentLength += letters[i].an / 2;\n                        currentLength += documentData.tr * 0.001 * documentData.finalSize;\n                    }\n                } else {\n                    matrixHelper.translate(xPos, yPos, 0);\n                    if (documentData.ps) {\n                        // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n                        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n                    }\n                    switch(documentData.j){\n                        case 1:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);\n                            break;\n                        case 2:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);\n                            break;\n                        default:\n                            break;\n                    }\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(offf, 0, 0);\n                    matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);\n                    xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;\n                }\n                if (renderType === \"html\") {\n                    letterM = matrixHelper.toCSS();\n                } else if (renderType === \"svg\") {\n                    letterM = matrixHelper.to2dCSS();\n                } else {\n                    letterP = [\n                        matrixHelper.props[0],\n                        matrixHelper.props[1],\n                        matrixHelper.props[2],\n                        matrixHelper.props[3],\n                        matrixHelper.props[4],\n                        matrixHelper.props[5],\n                        matrixHelper.props[6],\n                        matrixHelper.props[7],\n                        matrixHelper.props[8],\n                        matrixHelper.props[9],\n                        matrixHelper.props[10],\n                        matrixHelper.props[11],\n                        matrixHelper.props[12],\n                        matrixHelper.props[13],\n                        matrixHelper.props[14],\n                        matrixHelper.props[15]\n                    ];\n                }\n                letterO = elemOpacity;\n            }\n            if (renderedLettersCount <= i) {\n                letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);\n                this.renderedLetters.push(letterValue);\n                renderedLettersCount += 1;\n                this.lettersChangedFlag = true;\n            } else {\n                letterValue = this.renderedLetters[i];\n                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\n            }\n        }\n    };\n    TextAnimatorProperty.prototype.getValue = function() {\n        if (this._elem.globalData.frameId === this._frameId) {\n            return;\n        }\n        this._frameId = this._elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    TextAnimatorProperty.prototype.mHelper = new Matrix();\n    TextAnimatorProperty.prototype.defaultPropsArray = [];\n    extendPrototype([\n        DynamicPropertyContainer\n    ], TextAnimatorProperty);\n    function ITextElement() {}\n    ITextElement.prototype.initElement = function(data, globalData, comp) {\n        this.lettersChangedFlag = true;\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\n        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n        this.initRenderable();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        this.createContent();\n        this.hide();\n        this.textAnimator.searchProperties(this.dynamicProperties);\n    };\n    ITextElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n    };\n    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {\n        var j;\n        var jLen = shapes.length;\n        var pathNodes;\n        var shapeStr = \"\";\n        for(j = 0; j < jLen; j += 1){\n            if (shapes[j].ty === \"sh\") {\n                pathNodes = shapes[j].ks.k;\n                shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\n            }\n        }\n        return shapeStr;\n    };\n    ITextElement.prototype.updateDocumentData = function(newData, index) {\n        this.textProperty.updateDocumentData(newData, index);\n    };\n    ITextElement.prototype.canResizeFont = function(_canResize) {\n        this.textProperty.canResizeFont(_canResize);\n    };\n    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {\n        this.textProperty.setMinimumFontSize(_fontSize);\n    };\n    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {\n        if (documentData.ps) {\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n        }\n        matrixHelper.translate(0, -documentData.ls, 0);\n        switch(documentData.j){\n            case 1:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);\n                break;\n            case 2:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);\n                break;\n            default:\n                break;\n        }\n        matrixHelper.translate(xPos, yPos, 0);\n    };\n    ITextElement.prototype.buildColor = function(colorData) {\n        return \"rgb(\" + Math.round(colorData[0] * 255) + \",\" + Math.round(colorData[1] * 255) + \",\" + Math.round(colorData[2] * 255) + \")\";\n    };\n    ITextElement.prototype.emptyProp = new LetterProps();\n    ITextElement.prototype.destroy = function() {};\n    ITextElement.prototype.validateText = function() {\n        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n            this.buildNewText();\n            this.textProperty._isFirstFrame = false;\n            this.textProperty._mdf = false;\n        }\n    };\n    var emptyShapeData = {\n        shapes: []\n    };\n    function SVGTextLottieElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.renderType = \"svg\";\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], SVGTextLottieElement);\n    SVGTextLottieElement.prototype.createContent = function() {\n        if (this.data.singleShape && !this.globalData.fontManager.chars) {\n            this.textContainer = createNS(\"text\");\n        }\n    };\n    SVGTextLottieElement.prototype.buildTextContents = function(textArray) {\n        var i = 0;\n        var len = textArray.length;\n        var textContents = [];\n        var currentTextContent = \"\";\n        while(i < len){\n            if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n                textContents.push(currentTextContent);\n                currentTextContent = \"\";\n            } else {\n                currentTextContent += textArray[i];\n            }\n            i += 1;\n        }\n        textContents.push(currentTextContent);\n        return textContents;\n    };\n    SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {\n        // data should probably be cloned to apply scale separately to each instance of a text on different layers\n        // but since text internal content gets only rendered once and then it's never rerendered,\n        // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n        // Avoiding cloning is preferred since cloning each character shape data is expensive\n        if (data.shapes && data.shapes.length) {\n            var shape = data.shapes[0];\n            if (shape.it) {\n                var shapeItem = shape.it[shape.it.length - 1];\n                if (shapeItem.s) {\n                    shapeItem.s.k[0] = scale;\n                    shapeItem.s.k[1] = scale;\n                }\n            }\n        }\n        return data;\n    };\n    SVGTextLottieElement.prototype.buildNewText = function() {\n        this.addDynamicProperty(this);\n        var i;\n        var len;\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\n        if (documentData.fc) {\n            this.layerElement.setAttribute(\"fill\", this.buildColor(documentData.fc));\n        } else {\n            this.layerElement.setAttribute(\"fill\", \"rgba(0,0,0,0)\");\n        }\n        if (documentData.sc) {\n            this.layerElement.setAttribute(\"stroke\", this.buildColor(documentData.sc));\n            this.layerElement.setAttribute(\"stroke-width\", documentData.sw);\n        }\n        this.layerElement.setAttribute(\"font-size\", documentData.finalSize);\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (fontData.fClass) {\n            this.layerElement.setAttribute(\"class\", fontData.fClass);\n        } else {\n            this.layerElement.setAttribute(\"font-family\", fontData.fFamily);\n            var fWeight = documentData.fWeight;\n            var fStyle = documentData.fStyle;\n            this.layerElement.setAttribute(\"font-style\", fStyle);\n            this.layerElement.setAttribute(\"font-weight\", fWeight);\n        }\n        this.layerElement.setAttribute(\"aria-label\", documentData.t);\n        var letters = documentData.l || [];\n        var usesGlyphs = !!this.globalData.fontManager.chars;\n        len = letters.length;\n        var tSpan;\n        var matrixHelper = this.mHelper;\n        var shapeStr = \"\";\n        var singleShape = this.data.singleShape;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        if (singleShape && !usesGlyphs && !documentData.sz) {\n            var tElement = this.textContainer;\n            var justify = \"start\";\n            switch(documentData.j){\n                case 1:\n                    justify = \"end\";\n                    break;\n                case 2:\n                    justify = \"middle\";\n                    break;\n                default:\n                    justify = \"start\";\n                    break;\n            }\n            tElement.setAttribute(\"text-anchor\", justify);\n            tElement.setAttribute(\"letter-spacing\", trackingOffset);\n            var textContent = this.buildTextContents(documentData.finalText);\n            len = textContent.length;\n            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\n            for(i = 0; i < len; i += 1){\n                tSpan = this.textSpans[i].span || createNS(\"tspan\");\n                tSpan.textContent = textContent[i];\n                tSpan.setAttribute(\"x\", 0);\n                tSpan.setAttribute(\"y\", yPos);\n                tSpan.style.display = \"inherit\";\n                tElement.appendChild(tSpan);\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        glyph: null\n                    };\n                }\n                this.textSpans[i].span = tSpan;\n                yPos += documentData.finalLineHeight;\n            }\n            this.layerElement.appendChild(tElement);\n        } else {\n            var cachedSpansLength = this.textSpans.length;\n            var charData;\n            for(i = 0; i < len; i += 1){\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        childSpan: null,\n                        glyph: null\n                    };\n                }\n                if (!usesGlyphs || !singleShape || i === 0) {\n                    tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? \"g\" : \"text\");\n                    if (cachedSpansLength <= i) {\n                        tSpan.setAttribute(\"stroke-linecap\", \"butt\");\n                        tSpan.setAttribute(\"stroke-linejoin\", \"round\");\n                        tSpan.setAttribute(\"stroke-miterlimit\", \"4\");\n                        this.textSpans[i].span = tSpan;\n                        if (usesGlyphs) {\n                            var childSpan = createNS(\"g\");\n                            tSpan.appendChild(childSpan);\n                            this.textSpans[i].childSpan = childSpan;\n                        }\n                        this.textSpans[i].span = tSpan;\n                        this.layerElement.appendChild(tSpan);\n                    }\n                    tSpan.style.display = \"inherit\";\n                }\n                matrixHelper.reset();\n                if (singleShape) {\n                    if (letters[i].n) {\n                        xPos = -trackingOffset;\n                        yPos += documentData.yOffset;\n                        yPos += firstLine ? 1 : 0;\n                        firstLine = false;\n                    }\n                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n                    xPos += letters[i].l || 0; // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n                    xPos += trackingOffset;\n                }\n                if (usesGlyphs) {\n                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                    var glyphElement; // t === 1 means the character has been replaced with an animated shaped\n                    if (charData.t === 1) {\n                        glyphElement = new SVGCompElement(charData.data, this.globalData, this);\n                    } else {\n                        var data = emptyShapeData;\n                        if (charData.data && charData.data.shapes) {\n                            data = this.buildShapeData(charData.data, documentData.finalSize);\n                        }\n                        glyphElement = new SVGShapeElement(data, this.globalData, this);\n                    }\n                    if (this.textSpans[i].glyph) {\n                        var glyph = this.textSpans[i].glyph;\n                        this.textSpans[i].childSpan.removeChild(glyph.layerElement);\n                        glyph.destroy();\n                    }\n                    this.textSpans[i].glyph = glyphElement;\n                    glyphElement._debug = true;\n                    glyphElement.prepareFrame(0);\n                    glyphElement.renderFrame();\n                    this.textSpans[i].childSpan.appendChild(glyphElement.layerElement); // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n                    // this might have issues with strokes and might need a different solution\n                    if (charData.t === 1) {\n                        this.textSpans[i].childSpan.setAttribute(\"transform\", \"scale(\" + documentData.finalSize / 100 + \",\" + documentData.finalSize / 100 + \")\");\n                    }\n                } else {\n                    if (singleShape) {\n                        tSpan.setAttribute(\"transform\", \"translate(\" + matrixHelper.props[12] + \",\" + matrixHelper.props[13] + \")\");\n                    }\n                    tSpan.textContent = letters[i].val;\n                    tSpan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n                } //\n            }\n            if (singleShape && tSpan) {\n                tSpan.setAttribute(\"d\", shapeStr);\n            }\n        }\n        while(i < this.textSpans.length){\n            this.textSpans[i].span.style.display = \"none\";\n            i += 1;\n        }\n        this._sizeChanged = true;\n    };\n    SVGTextLottieElement.prototype.sourceRectAtTime = function() {\n        this.prepareFrame(this.comp.renderedFrame - this.data.st);\n        this.renderInnerContent();\n        if (this._sizeChanged) {\n            this._sizeChanged = false;\n            var textBox = this.layerElement.getBBox();\n            this.bbox = {\n                top: textBox.y,\n                left: textBox.x,\n                width: textBox.width,\n                height: textBox.height\n            };\n        }\n        return this.bbox;\n    };\n    SVGTextLottieElement.prototype.getValue = function() {\n        var i;\n        var len = this.textSpans.length;\n        var glyphElement;\n        this.renderedFrame = this.comp.renderedFrame;\n        for(i = 0; i < len; i += 1){\n            glyphElement = this.textSpans[i].glyph;\n            if (glyphElement) {\n                glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);\n                if (glyphElement._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    SVGTextLottieElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        if (!this.data.singleShape || this._mdf) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n                this._sizeChanged = true;\n                var i;\n                var len;\n                var renderedLetters = this.textAnimator.renderedLetters;\n                var letters = this.textProperty.currentData.l;\n                len = letters.length;\n                var renderedLetter;\n                var textSpan;\n                var glyphElement;\n                for(i = 0; i < len; i += 1){\n                    if (!letters[i].n) {\n                        renderedLetter = renderedLetters[i];\n                        textSpan = this.textSpans[i].span;\n                        glyphElement = this.textSpans[i].glyph;\n                        if (glyphElement) {\n                            glyphElement.renderFrame();\n                        }\n                        if (renderedLetter._mdf.m) {\n                            textSpan.setAttribute(\"transform\", renderedLetter.m);\n                        }\n                        if (renderedLetter._mdf.o) {\n                            textSpan.setAttribute(\"opacity\", renderedLetter.o);\n                        }\n                        if (renderedLetter._mdf.sw) {\n                            textSpan.setAttribute(\"stroke-width\", renderedLetter.sw);\n                        }\n                        if (renderedLetter._mdf.sc) {\n                            textSpan.setAttribute(\"stroke\", renderedLetter.sc);\n                        }\n                        if (renderedLetter._mdf.fc) {\n                            textSpan.setAttribute(\"fill\", renderedLetter.fc);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function ISolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        IImageElement\n    ], ISolidElement);\n    ISolidElement.prototype.createContent = function() {\n        var rect = createNS(\"rect\"); /// /rect.style.width = this.data.sw;\n        /// /rect.style.height = this.data.sh;\n        /// /rect.style.fill = this.data.sc;\n        rect.setAttribute(\"width\", this.data.sw);\n        rect.setAttribute(\"height\", this.data.sh);\n        rect.setAttribute(\"fill\", this.data.sc);\n        this.layerElement.appendChild(rect);\n    };\n    function NullElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initFrame();\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n    }\n    NullElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    NullElement.prototype.renderFrame = function() {};\n    NullElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    NullElement.prototype.destroy = function() {};\n    NullElement.prototype.sourceRectAtTime = function() {};\n    NullElement.prototype.hide = function() {};\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement\n    ], NullElement);\n    function SVGRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], SVGRendererBase);\n    SVGRendererBase.prototype.createNull = function(data) {\n        return new NullElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createShape = function(data) {\n        return new SVGShapeElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createText = function(data) {\n        return new SVGTextLottieElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createImage = function(data) {\n        return new IImageElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createSolid = function(data) {\n        return new ISolidElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.configAnimation = function(animData) {\n        this.svgElement.setAttribute(\"xmlns\", \"http://www.w3.org/2000/svg\");\n        this.svgElement.setAttribute(\"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n        if (this.renderConfig.viewBoxSize) {\n            this.svgElement.setAttribute(\"viewBox\", this.renderConfig.viewBoxSize);\n        } else {\n            this.svgElement.setAttribute(\"viewBox\", \"0 0 \" + animData.w + \" \" + animData.h);\n        }\n        if (!this.renderConfig.viewBoxOnly) {\n            this.svgElement.setAttribute(\"width\", animData.w);\n            this.svgElement.setAttribute(\"height\", animData.h);\n            this.svgElement.style.width = \"100%\";\n            this.svgElement.style.height = \"100%\";\n            this.svgElement.style.transform = \"translate3d(0,0,0)\";\n            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;\n        }\n        if (this.renderConfig.width) {\n            this.svgElement.setAttribute(\"width\", this.renderConfig.width);\n        }\n        if (this.renderConfig.height) {\n            this.svgElement.setAttribute(\"height\", this.renderConfig.height);\n        }\n        if (this.renderConfig.className) {\n            this.svgElement.setAttribute(\"class\", this.renderConfig.className);\n        }\n        if (this.renderConfig.id) {\n            this.svgElement.setAttribute(\"id\", this.renderConfig.id);\n        }\n        if (this.renderConfig.focusable !== undefined) {\n            this.svgElement.setAttribute(\"focusable\", this.renderConfig.focusable);\n        }\n        this.svgElement.setAttribute(\"preserveAspectRatio\", this.renderConfig.preserveAspectRatio); // this.layerElement.style.transform = 'translate3d(0,0,0)';\n        // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n        this.animationItem.wrapper.appendChild(this.svgElement); // Mask animation\n        var defs = this.globalData.defs;\n        this.setupGlobalData(animData, defs);\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.data = animData;\n        var maskElement = createNS(\"clipPath\");\n        var rect = createNS(\"rect\");\n        rect.setAttribute(\"width\", animData.w);\n        rect.setAttribute(\"height\", animData.h);\n        rect.setAttribute(\"x\", 0);\n        rect.setAttribute(\"y\", 0);\n        var maskId = createElementID();\n        maskElement.setAttribute(\"id\", maskId);\n        maskElement.appendChild(rect);\n        this.layerElement.setAttribute(\"clip-path\", \"url(\" + getLocationHref() + \"#\" + maskId + \")\");\n        defs.appendChild(maskElement);\n        this.layers = animData.layers;\n        this.elements = createSizedArray(animData.layers.length);\n    };\n    SVGRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        this.layerElement = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    SVGRendererBase.prototype.updateContainerSize = function() {};\n    SVGRendererBase.prototype.findIndexByInd = function(ind) {\n        var i = 0;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ind === ind) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    SVGRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        elements[pos] = true;\n        var element = this.createItem(this.layers[pos]);\n        elements[pos] = element;\n        if (getExpressionsPlugin()) {\n            if (this.layers[pos].ty === 0) {\n                this.globalData.projectInterface.registerComposition(element);\n            }\n            element.initExpressions();\n        }\n        this.appendElementInPos(element, pos);\n        if (this.layers[pos].tt) {\n            var elementIndex = \"tp\" in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;\n            if (elementIndex === -1) {\n                return;\n            }\n            if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {\n                this.buildItem(elementIndex);\n                this.addPendingElement(element);\n            } else {\n                var matteElement = elements[elementIndex];\n                var matteMask = matteElement.getMatte(this.layers[pos].tt);\n                element.setMatte(matteMask);\n            }\n        }\n    };\n    SVGRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n            if (element.data.tt) {\n                var i = 0;\n                var len = this.elements.length;\n                while(i < len){\n                    if (this.elements[i] === element) {\n                        var elementIndex = \"tp\" in element.data ? this.findIndexByInd(element.data.tp) : i - 1;\n                        var matteElement = this.elements[elementIndex];\n                        var matteMask = matteElement.getMatte(this.layers[i].tt);\n                        element.setMatte(matteMask);\n                        break;\n                    }\n                    i += 1;\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.renderFrame = function(num) {\n        if (this.renderedFrame === num || this.destroyed) {\n            return;\n        }\n        if (num === null) {\n            num = this.renderedFrame;\n        } else {\n            this.renderedFrame = num;\n        } // console.log('-------');\n        // console.log('FRAME ',num);\n        this.globalData.frameNum = num;\n        this.globalData.frameId += 1;\n        this.globalData.projectInterface.currentFrame = num;\n        this.globalData._mdf = false;\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            for(i = 0; i < len; i += 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newElement = element.getBaseElement();\n        if (!newElement) {\n            return;\n        }\n        var i = 0;\n        var nextElement;\n        while(i < pos){\n            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n                nextElement = this.elements[i].getBaseElement();\n            }\n            i += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(newElement, nextElement);\n        } else {\n            this.layerElement.appendChild(newElement);\n        }\n    };\n    SVGRendererBase.prototype.hide = function() {\n        this.layerElement.style.display = \"none\";\n    };\n    SVGRendererBase.prototype.show = function() {\n        this.layerElement.style.display = \"block\";\n    };\n    function ICompElement() {}\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], ICompElement);\n    ICompElement.prototype.initElement = function(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initTransform(data, globalData, comp);\n        this.initRenderable();\n        this.initHierarchy();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        if (this.data.xt || !globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n        this.hide();\n    };\n    /* ICompElement.prototype.hide = function(){\r\n      if(!this.hidden){\r\n          this.hideElement();\r\n          var i,len = this.elements.length;\r\n          for( i = 0; i < len; i+=1 ){\r\n              if(this.elements[i]){\r\n                  this.elements[i].hide();\r\n              }\r\n          }\r\n      }\r\n  }; */ ICompElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n        if (!this.isInRange && !this.data.xt) {\n            return;\n        }\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            if (timeRemapped === this.data.op) {\n                timeRemapped = this.data.op - 1;\n            }\n            this.renderedFrame = timeRemapped;\n        } else {\n            this.renderedFrame = num / this.data.sr;\n        }\n        var i;\n        var len = this.elements.length;\n        if (!this.completeLayers) {\n            this.checkLayers(this.renderedFrame);\n        } // This iteration needs to be backwards because of how expressions connect between each other\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\n                if (this.elements[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    ICompElement.prototype.renderInnerContent = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    ICompElement.prototype.setElements = function(elems) {\n        this.elements = elems;\n    };\n    ICompElement.prototype.getElements = function() {\n        return this.elements;\n    };\n    ICompElement.prototype.destroyElements = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n    };\n    ICompElement.prototype.destroy = function() {\n        this.destroyElements();\n        this.destroyBaseElement();\n    };\n    function SVGCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = true;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        SVGRendererBase,\n        ICompElement,\n        SVGBaseElement\n    ], SVGCompElement);\n    SVGCompElement.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function SVGRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.svgElement = createNS(\"svg\");\n        var ariaLabel = \"\";\n        if (config && config.title) {\n            var titleElement = createNS(\"title\");\n            var titleId = createElementID();\n            titleElement.setAttribute(\"id\", titleId);\n            titleElement.textContent = config.title;\n            this.svgElement.appendChild(titleElement);\n            ariaLabel += titleId;\n        }\n        if (config && config.description) {\n            var descElement = createNS(\"desc\");\n            var descId = createElementID();\n            descElement.setAttribute(\"id\", descId);\n            descElement.textContent = config.description;\n            this.svgElement.appendChild(descElement);\n            ariaLabel += \" \" + descId;\n        }\n        if (ariaLabel) {\n            this.svgElement.setAttribute(\"aria-labelledby\", ariaLabel);\n        }\n        var defs = createNS(\"defs\");\n        this.svgElement.appendChild(defs);\n        var maskElement = createNS(\"g\");\n        this.svgElement.appendChild(maskElement);\n        this.layerElement = maskElement;\n        this.renderConfig = {\n            preserveAspectRatio: config && config.preserveAspectRatio || \"xMidYMid meet\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            contentVisibility: config && config.contentVisibility || \"visible\",\n            progressiveLoad: config && config.progressiveLoad || false,\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            viewBoxOnly: config && config.viewBoxOnly || false,\n            viewBoxSize: config && config.viewBoxSize || false,\n            className: config && config.className || \"\",\n            id: config && config.id || \"\",\n            focusable: config && config.focusable,\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"100%\",\n                height: config && config.filterSize && config.filterSize.height || \"100%\",\n                x: config && config.filterSize && config.filterSize.x || \"0%\",\n                y: config && config.filterSize && config.filterSize.y || \"0%\"\n            },\n            width: config && config.width,\n            height: config && config.height,\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            defs: defs,\n            renderConfig: this.renderConfig\n        };\n        this.elements = [];\n        this.pendingElements = [];\n        this.destroyed = false;\n        this.rendererType = \"svg\";\n    }\n    extendPrototype([\n        SVGRendererBase\n    ], SVGRenderer);\n    SVGRenderer.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function ShapeTransformManager() {\n        this.sequences = {};\n        this.sequenceList = [];\n        this.transform_key_count = 0;\n    }\n    ShapeTransformManager.prototype = {\n        addTransformSequence: function addTransformSequence(transforms) {\n            var i;\n            var len = transforms.length;\n            var key = \"_\";\n            for(i = 0; i < len; i += 1){\n                key += transforms[i].transform.key + \"_\";\n            }\n            var sequence = this.sequences[key];\n            if (!sequence) {\n                sequence = {\n                    transforms: [].concat(transforms),\n                    finalTransform: new Matrix(),\n                    _mdf: false\n                };\n                this.sequences[key] = sequence;\n                this.sequenceList.push(sequence);\n            }\n            return sequence;\n        },\n        processSequence: function processSequence(sequence, isFirstFrame) {\n            var i = 0;\n            var len = sequence.transforms.length;\n            var _mdf = isFirstFrame;\n            while(i < len && !isFirstFrame){\n                if (sequence.transforms[i].transform.mProps._mdf) {\n                    _mdf = true;\n                    break;\n                }\n                i += 1;\n            }\n            if (_mdf) {\n                sequence.finalTransform.reset();\n                for(i = len - 1; i >= 0; i -= 1){\n                    sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);\n                }\n            }\n            sequence._mdf = _mdf;\n        },\n        processSequences: function processSequences(isFirstFrame) {\n            var i;\n            var len = this.sequenceList.length;\n            for(i = 0; i < len; i += 1){\n                this.processSequence(this.sequenceList[i], isFirstFrame);\n            }\n        },\n        getNewKey: function getNewKey() {\n            this.transform_key_count += 1;\n            return \"_\" + this.transform_key_count;\n        }\n    };\n    var lumaLoader = function lumaLoader() {\n        var id = \"__lottie_element_luma_buffer\";\n        var lumaBuffer = null;\n        var lumaBufferCtx = null;\n        var svg = null; // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.\n        // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.\n        // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.\n        // Naming it solution 2 to mark the extra comment lines.\n        /*\r\n    var svgString = [\r\n      '<svg xmlns=\"http://www.w3.org/2000/svg\">',\r\n      '<filter id=\"' + id + '\">',\r\n      '<feColorMatrix type=\"matrix\" color-interpolation-filters=\"sRGB\" values=\"',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0, ',\r\n      '0.3, 0.3, 0.3, 0, 0',\r\n      '\"/>',\r\n      '</filter>',\r\n      '</svg>',\r\n    ].join('');\r\n    var blob = new Blob([svgString], { type: 'image/svg+xml' });\r\n    var url = URL.createObjectURL(blob);\r\n    */ function createLumaSvgFilter() {\n            var _svg = createNS(\"svg\");\n            var fil = createNS(\"filter\");\n            var matrix = createNS(\"feColorMatrix\");\n            fil.setAttribute(\"id\", id);\n            matrix.setAttribute(\"type\", \"matrix\");\n            matrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            matrix.setAttribute(\"values\", \"0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0\");\n            fil.appendChild(matrix);\n            _svg.appendChild(fil);\n            _svg.setAttribute(\"id\", id + \"_svg\");\n            if (featureSupport.svgLumaHidden) {\n                _svg.style.display = \"none\";\n            }\n            return _svg;\n        }\n        function loadLuma() {\n            if (!lumaBuffer) {\n                svg = createLumaSvgFilter();\n                document.body.appendChild(svg);\n                lumaBuffer = createTag(\"canvas\");\n                lumaBufferCtx = lumaBuffer.getContext(\"2d\"); // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n                lumaBufferCtx.filter = \"url(#\" + id + \")\";\n                lumaBufferCtx.fillStyle = \"rgba(0,0,0,0)\";\n                lumaBufferCtx.fillRect(0, 0, 1, 1);\n            }\n        }\n        function getLuma(canvas) {\n            if (!lumaBuffer) {\n                loadLuma();\n            }\n            lumaBuffer.width = canvas.width;\n            lumaBuffer.height = canvas.height; // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n            lumaBufferCtx.filter = \"url(#\" + id + \")\";\n            return lumaBuffer;\n        }\n        return {\n            load: loadLuma,\n            get: getLuma\n        };\n    };\n    function createCanvas(width, height) {\n        if (featureSupport.offscreenCanvas) {\n            return new OffscreenCanvas(width, height);\n        }\n        var canvas = createTag(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n    var assetLoader = function() {\n        return {\n            loadLumaCanvas: lumaLoader.load,\n            getLumaCanvas: lumaLoader.get,\n            createCanvas: createCanvas\n        };\n    }();\n    var registeredEffects = {};\n    function CVEffects(elem) {\n        var i;\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects[type]) {\n                var Effect = registeredEffects[type].effect;\n                filterManager = new Effect(elem.effectsManager.effectElements[i], elem);\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    CVEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    CVEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect(id, effect) {\n        registeredEffects[id] = {\n            effect: effect\n        };\n    }\n    function CVMaskElement(data, element) {\n        this.data = data;\n        this.element = element;\n        this.masksProperties = this.data.masksProperties || [];\n        this.viewData = createSizedArray(this.masksProperties.length);\n        var i;\n        var len = this.masksProperties.length;\n        var hasMasks = false;\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== \"n\") {\n                hasMasks = true;\n            }\n            this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);\n        }\n        this.hasMasks = hasMasks;\n        if (hasMasks) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    CVMaskElement.prototype.renderFrame = function() {\n        if (!this.hasMasks) {\n            return;\n        }\n        var transform = this.element.finalTransform.mat;\n        var ctx = this.element.canvasContext;\n        var i;\n        var len = this.masksProperties.length;\n        var pt;\n        var pts;\n        var data;\n        ctx.beginPath();\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== \"n\") {\n                if (this.masksProperties[i].inv) {\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, 0);\n                }\n                data = this.viewData[i].v;\n                pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);\n                ctx.moveTo(pt[0], pt[1]);\n                var j;\n                var jLen = data._length;\n                for(j = 1; j < jLen; j += 1){\n                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\n                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n                }\n                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\n                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n            }\n        }\n        this.element.globalData.renderer.save(true);\n        ctx.clip();\n    };\n    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\n    CVMaskElement.prototype.destroy = function() {\n        this.element = null;\n    };\n    function CVBaseElement() {}\n    var operationsMap = {\n        1: \"source-in\",\n        2: \"source-out\",\n        3: \"source-in\",\n        4: \"source-out\"\n    };\n    CVBaseElement.prototype = {\n        createElements: function createElements() {},\n        initRendererElement: function initRendererElement() {},\n        createContainerElements: function createContainerElements() {\n            // If the layer is masked we will use two buffers to store each different states of the drawing\n            // This solution is not ideal for several reason. But unfortunately, because of the recursive\n            // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.\n            // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer\n            // It might be challenging because the layer most likely is transformed in some way\n            if (this.data.tt >= 1) {\n                this.buffers = [];\n                var canvasContext = this.globalData.canvasContext;\n                var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas);\n                var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas2);\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    assetLoader.loadLumaCanvas();\n                }\n            }\n            this.canvasContext = this.globalData.canvasContext;\n            this.transformCanvas = this.globalData.transformCanvas;\n            this.renderableEffectsManager = new CVEffects(this);\n            this.searchEffectTransforms();\n        },\n        createContent: function createContent() {},\n        setBlendMode: function setBlendMode() {\n            var globalData = this.globalData;\n            if (globalData.blendMode !== this.data.bm) {\n                globalData.blendMode = this.data.bm;\n                var blendModeValue = getBlendMode(this.data.bm);\n                globalData.canvasContext.globalCompositeOperation = blendModeValue;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new CVMaskElement(this.data, this);\n            this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n        },\n        hideElement: function hideElement() {\n            if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                this.hidden = true;\n            }\n        },\n        showElement: function showElement() {\n            if (this.isInRange && !this.isTransparent) {\n                this.hidden = false;\n                this._isFirstFrame = true;\n                this.maskManager._isFirstFrame = true;\n            }\n        },\n        clearCanvas: function clearCanvas(canvasContext) {\n            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);\n        },\n        prepareLayer: function prepareLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[0];\n                var bufferCtx = buffer.getContext(\"2d\");\n                this.clearCanvas(bufferCtx); // on the first buffer we store the current state of the global drawing\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // The next four lines are to clear the canvas\n                // TODO: Check if there is a way to clear the canvas without resetting the transform\n                this.currentTransform = this.canvasContext.getTransform();\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform);\n            }\n        },\n        exitLayer: function exitLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[1]; // On the second buffer we store the current state of the global drawing\n                // that only contains the content of this layer\n                // (if it is a composition, it also includes the nested layers)\n                var bufferCtx = buffer.getContext(\"2d\");\n                this.clearCanvas(bufferCtx);\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0); // We clear the canvas again\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform); // We draw the mask\n                var mask = this.comp.getElementById(\"tp\" in this.data ? this.data.tp : this.data.ind - 1);\n                mask.renderFrame(true); // We draw the second buffer (that contains the content of this layer)\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0); // If the mask is a Luma matte, we need to do two extra painting operations\n                // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    // We copy the painted mask to a buffer that has a color matrix filter applied to it\n                    // that applies the rgb values to the alpha channel\n                    var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);\n                    var lumaBufferCtx = lumaBuffer.getContext(\"2d\");\n                    lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n                    this.clearCanvas(this.canvasContext); // we repaint the context with the mask applied to it\n                    this.canvasContext.drawImage(lumaBuffer, 0, 0);\n                }\n                this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];\n                this.canvasContext.drawImage(buffer, 0, 0); // We finally draw the first buffer (that contains the content of the global drawing)\n                // We use destination-over to draw the global drawing below the current layer\n                this.canvasContext.globalCompositeOperation = \"destination-over\";\n                this.canvasContext.drawImage(this.buffers[0], 0, 0);\n                this.canvasContext.setTransform(this.currentTransform); // We reset the globalCompositeOperation to source-over, the standard type of operation\n                this.canvasContext.globalCompositeOperation = \"source-over\";\n            }\n        },\n        renderFrame: function renderFrame(forceRender) {\n            if (this.hidden || this.data.hd) {\n                return;\n            }\n            if (this.data.td === 1 && !forceRender) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderLocalTransform();\n            this.setBlendMode();\n            var forceRealStack = this.data.ty === 0;\n            this.prepareLayer();\n            this.globalData.renderer.save(forceRealStack);\n            this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);\n            this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);\n            this.renderInnerContent();\n            this.globalData.renderer.restore(forceRealStack);\n            this.exitLayer();\n            if (this.maskManager.hasMasks) {\n                this.globalData.renderer.restore(true);\n            }\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.canvasContext = null;\n            this.data = null;\n            this.globalData = null;\n            this.maskManager.destroy();\n        },\n        mHelper: new Matrix()\n    };\n    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\n    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\n    function CVShapeData(element, data, styles, transformsManager) {\n        this.styledShapes = [];\n        this.tr = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        var ty = 4;\n        if (data.ty === \"rc\") {\n            ty = 5;\n        } else if (data.ty === \"el\") {\n            ty = 6;\n        } else if (data.ty === \"sr\") {\n            ty = 7;\n        }\n        this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);\n        var i;\n        var len = styles.length;\n        var styledShape;\n        for(i = 0; i < len; i += 1){\n            if (!styles[i].closed) {\n                styledShape = {\n                    transforms: transformsManager.addTransformSequence(styles[i].transforms),\n                    trNodes: []\n                };\n                this.styledShapes.push(styledShape);\n                styles[i].elements.push(styledShape);\n            }\n        }\n    }\n    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\n    function CVShapeElement(data, globalData, comp) {\n        this.shapes = [];\n        this.shapesData = data.shapes;\n        this.stylesList = [];\n        this.itemsData = [];\n        this.prevViewData = [];\n        this.shapeModifiers = [];\n        this.processedElements = [];\n        this.transformsManager = new ShapeTransformManager();\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVShapeElement);\n    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\n    CVShapeElement.prototype.transformHelper = {\n        opacity: 1,\n        _opMdf: false\n    };\n    CVShapeElement.prototype.dashResetter = [];\n    CVShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n    };\n    CVShapeElement.prototype.createStyleElement = function(data, transforms) {\n        var styleElem = {\n            data: data,\n            type: data.ty,\n            preTransforms: this.transformsManager.addTransformSequence(transforms),\n            transforms: [],\n            elements: [],\n            closed: data.hd === true\n        };\n        var elementData = {};\n        if (data.ty === \"fl\" || data.ty === \"st\") {\n            elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);\n            if (!elementData.c.k) {\n                styleElem.co = \"rgb(\" + bmFloor(elementData.c.v[0]) + \",\" + bmFloor(elementData.c.v[1]) + \",\" + bmFloor(elementData.c.v[2]) + \")\";\n            }\n        } else if (data.ty === \"gf\" || data.ty === \"gs\") {\n            elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);\n            elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);\n            elementData.h = PropertyFactory.getProp(this, data.h || {\n                k: 0\n            }, 0, 0.01, this);\n            elementData.a = PropertyFactory.getProp(this, data.a || {\n                k: 0\n            }, 0, degToRads, this);\n            elementData.g = new GradientProperty(this, data.g, this);\n        }\n        elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);\n        if (data.ty === \"st\" || data.ty === \"gs\") {\n            styleElem.lc = lineCapEnum[data.lc || 2];\n            styleElem.lj = lineJoinEnum[data.lj || 2];\n            if (data.lj == 1) {\n                // eslint-disable-line eqeqeq\n                styleElem.ml = data.ml;\n            }\n            elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);\n            if (!elementData.w.k) {\n                styleElem.wi = elementData.w.v;\n            }\n            if (data.d) {\n                var d = new DashProperty(this, data.d, \"canvas\", this);\n                elementData.d = d;\n                if (!elementData.d.k) {\n                    styleElem.da = elementData.d.dashArray;\n                    styleElem[\"do\"] = elementData.d.dashoffset[0];\n                }\n            }\n        } else {\n            styleElem.r = data.r === 2 ? \"evenodd\" : \"nonzero\";\n        }\n        this.stylesList.push(styleElem);\n        elementData.style = styleElem;\n        return elementData;\n    };\n    CVShapeElement.prototype.createGroupElement = function() {\n        var elementData = {\n            it: [],\n            prevViewData: []\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createTransformElement = function(data) {\n        var elementData = {\n            transform: {\n                opacity: 1,\n                _opMdf: false,\n                key: this.transformsManager.getNewKey(),\n                op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n                mProps: TransformPropertyFactory.getTransformProperty(this, data, this)\n            }\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createShapeElement = function(data) {\n        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        return elementData;\n    };\n    CVShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n    };\n    CVShapeElement.prototype.addTransformToStyleList = function(transform) {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.push(transform);\n            }\n        }\n    };\n    CVShapeElement.prototype.removeTransformFromStyleList = function() {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.pop();\n            }\n        }\n    };\n    CVShapeElement.prototype.closeStyles = function(styles) {\n        var i;\n        var len = styles.length;\n        for(i = 0; i < len; i += 1){\n            styles[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var processedPos;\n        var modifier;\n        var currentTransform;\n        var ownTransforms = [].concat(transforms);\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._shouldRender = shouldRender;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === \"fl\" || arr[i].ty === \"st\" || arr[i].ty === \"gf\" || arr[i].ty === \"gs\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\n                } else {\n                    itemsData[i].style.closed = false;\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === \"gr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);\n            } else if (arr[i].ty === \"tr\") {\n                if (!processedPos) {\n                    currentTransform = this.createTransformElement(arr[i]);\n                    itemsData[i] = currentTransform;\n                }\n                ownTransforms.push(itemsData[i]);\n                this.addTransformToStyleList(itemsData[i]);\n            } else if (arr[i].ty === \"sh\" || arr[i].ty === \"rc\" || arr[i].ty === \"el\" || arr[i].ty === \"sr\") {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i]);\n                }\n            } else if (arr[i].ty === \"tm\" || arr[i].ty === \"rd\" || arr[i].ty === \"pb\" || arr[i].ty === \"zz\" || arr[i].ty === \"op\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === \"rp\") {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    shouldRender = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        this.removeTransformFromStyleList();\n        this.closeStyles(ownStyles);\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.renderInnerContent = function() {\n        this.transformHelper.opacity = 1;\n        this.transformHelper._opMdf = false;\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);\n    };\n    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {\n        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n            groupTransform.opacity = parentTransform.opacity;\n            groupTransform.opacity *= groupTransform.op.v;\n            groupTransform._opMdf = true;\n        }\n    };\n    CVShapeElement.prototype.drawLayer = function() {\n        var i;\n        var len = this.stylesList.length;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var elems;\n        var nodes;\n        var renderer = this.globalData.renderer;\n        var ctx = this.globalData.canvasContext;\n        var type;\n        var currentStyle;\n        for(i = 0; i < len; i += 1){\n            currentStyle = this.stylesList[i];\n            type = currentStyle.type; // Skipping style when\n            // Stroke width equals 0\n            // style should not be rendered (extra unused repeaters)\n            // current opacity equals 0\n            // global opacity equals 0\n            if (!((type === \"st\" || type === \"gs\") && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {\n                renderer.save();\n                elems = currentStyle.elements;\n                if (type === \"st\" || type === \"gs\") {\n                    renderer.ctxStrokeStyle(type === \"st\" ? currentStyle.co : currentStyle.grd); // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\n                    renderer.ctxLineWidth(currentStyle.wi); // ctx.lineWidth = currentStyle.wi;\n                    renderer.ctxLineCap(currentStyle.lc); // ctx.lineCap = currentStyle.lc;\n                    renderer.ctxLineJoin(currentStyle.lj); // ctx.lineJoin = currentStyle.lj;\n                    renderer.ctxMiterLimit(currentStyle.ml || 0); // ctx.miterLimit = currentStyle.ml || 0;\n                } else {\n                    renderer.ctxFillStyle(type === \"fl\" ? currentStyle.co : currentStyle.grd); // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\n                }\n                renderer.ctxOpacity(currentStyle.coOp);\n                if (type !== \"st\" && type !== \"gs\") {\n                    ctx.beginPath();\n                }\n                renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\n                jLen = elems.length;\n                for(j = 0; j < jLen; j += 1){\n                    if (type === \"st\" || type === \"gs\") {\n                        ctx.beginPath();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(currentStyle.da);\n                            ctx.lineDashOffset = currentStyle[\"do\"];\n                        }\n                    }\n                    nodes = elems[j].trNodes;\n                    kLen = nodes.length;\n                    for(k = 0; k < kLen; k += 1){\n                        if (nodes[k].t === \"m\") {\n                            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);\n                        } else if (nodes[k].t === \"c\") {\n                            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);\n                        } else {\n                            ctx.closePath();\n                        }\n                    }\n                    if (type === \"st\" || type === \"gs\") {\n                        // ctx.stroke();\n                        renderer.ctxStroke();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(this.dashResetter);\n                        }\n                    }\n                }\n                if (type !== \"st\" && type !== \"gs\") {\n                    // ctx.fill(currentStyle.r);\n                    this.globalData.renderer.ctxFill(currentStyle.r);\n                }\n                renderer.restore();\n            }\n        }\n    };\n    CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {\n        var i;\n        var len = items.length - 1;\n        var groupTransform;\n        groupTransform = parentTransform;\n        for(i = len; i >= 0; i -= 1){\n            if (items[i].ty === \"tr\") {\n                groupTransform = data[i].transform;\n                this.renderShapeTransform(parentTransform, groupTransform);\n            } else if (items[i].ty === \"sh\" || items[i].ty === \"el\" || items[i].ty === \"rc\" || items[i].ty === \"sr\") {\n                this.renderPath(items[i], data[i]);\n            } else if (items[i].ty === \"fl\") {\n                this.renderFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"st\") {\n                this.renderStroke(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"gf\" || items[i].ty === \"gs\") {\n                this.renderGradientFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === \"gr\") {\n                this.renderShape(groupTransform, items[i].it, data[i].it);\n            } else if (items[i].ty === \"tm\") {}\n        }\n        if (isMain) {\n            this.drawLayer();\n        }\n    };\n    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {\n        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n            var shapeNodes = styledShape.trNodes;\n            var paths = shape.paths;\n            var i;\n            var len;\n            var j;\n            var jLen = paths._length;\n            shapeNodes.length = 0;\n            var groupTransformMat = styledShape.transforms.finalTransform;\n            for(j = 0; j < jLen; j += 1){\n                var pathNodes = paths.shapes[j];\n                if (pathNodes && pathNodes.v) {\n                    len = pathNodes._length;\n                    for(i = 1; i < len; i += 1){\n                        if (i === 1) {\n                            shapeNodes.push({\n                                t: \"m\",\n                                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                            });\n                        }\n                        shapeNodes.push({\n                            t: \"c\",\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\n                        });\n                    }\n                    if (len === 1) {\n                        shapeNodes.push({\n                            t: \"m\",\n                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                        });\n                    }\n                    if (pathNodes.c && len) {\n                        shapeNodes.push({\n                            t: \"c\",\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\n                        });\n                        shapeNodes.push({\n                            t: \"z\"\n                        });\n                    }\n                }\n            }\n            styledShape.trNodes = shapeNodes;\n        }\n    };\n    CVShapeElement.prototype.renderPath = function(pathData, itemData) {\n        if (pathData.hd !== true && pathData._shouldRender) {\n            var i;\n            var len = itemData.styledShapes.length;\n            for(i = 0; i < len; i += 1){\n                this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\n            }\n        }\n    };\n    CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\";\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n    };\n    CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var grd;\n        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {\n            var ctx = this.globalData.canvasContext;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (styleData.t === 1) {\n                grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\n            } else {\n                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                var percent = itemData.h.v;\n                if (percent >= 1) {\n                    percent = 0.99;\n                } else if (percent <= -1) {\n                    percent = -0.99;\n                }\n                var dist = rad * percent;\n                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\n            }\n            var i;\n            var len = styleData.g.p;\n            var cValues = itemData.g.c;\n            var opacity = 1;\n            for(i = 0; i < len; i += 1){\n                if (itemData.g._hasOpacity && itemData.g._collapsable) {\n                    opacity = itemData.g.o[i * 2 + 1];\n                }\n                grd.addColorStop(cValues[i * 4] / 100, \"rgba(\" + cValues[i * 4 + 1] + \",\" + cValues[i * 4 + 2] + \",\" + cValues[i * 4 + 3] + \",\" + opacity + \")\");\n            }\n            styleElem.grd = grd;\n        }\n        styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    };\n    CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var d = itemData.d;\n        if (d && (d._mdf || this._isFirstFrame)) {\n            styleElem.da = d.dashArray;\n            styleElem[\"do\"] = d.dashoffset[0];\n        }\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = \"rgb(\" + bmFloor(itemData.c.v[0]) + \",\" + bmFloor(itemData.c.v[1]) + \",\" + bmFloor(itemData.c.v[2]) + \")\";\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n        if (itemData.w._mdf || this._isFirstFrame) {\n            styleElem.wi = itemData.w.v;\n        }\n    };\n    CVShapeElement.prototype.destroy = function() {\n        this.shapesData = null;\n        this.globalData = null;\n        this.canvasContext = null;\n        this.stylesList.length = 0;\n        this.itemsData.length = 0;\n    };\n    function CVTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.yOffset = 0;\n        this.fillColorAnim = false;\n        this.strokeColorAnim = false;\n        this.strokeWidthAnim = false;\n        this.stroke = false;\n        this.fill = false;\n        this.justifyOffset = 0;\n        this.currentRender = null;\n        this.renderType = \"canvas\";\n        this.values = {\n            fill: \"rgba(0,0,0,0)\",\n            stroke: \"rgba(0,0,0,0)\",\n            sWidth: 0,\n            fValue: \"\"\n        };\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement,\n        ITextElement\n    ], CVTextElement);\n    CVTextElement.prototype.tHelper = createTag(\"canvas\").getContext(\"2d\");\n    CVTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var hasFill = false;\n        if (documentData.fc) {\n            hasFill = true;\n            this.values.fill = this.buildColor(documentData.fc);\n        } else {\n            this.values.fill = \"rgba(0,0,0,0)\";\n        }\n        this.fill = hasFill;\n        var hasStroke = false;\n        if (documentData.sc) {\n            hasStroke = true;\n            this.values.stroke = this.buildColor(documentData.sc);\n            this.values.sWidth = documentData.sw;\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        var i;\n        var len;\n        var letters = documentData.l;\n        var matrixHelper = this.mHelper;\n        this.stroke = hasStroke;\n        this.values.fValue = documentData.finalSize + \"px \" + this.globalData.fontManager.getFontByName(documentData.f).fFamily;\n        len = documentData.finalText.length; // this.tHelper.font = this.values.fValue;\n        var charData;\n        var shapeData;\n        var k;\n        var kLen;\n        var shapes;\n        var j;\n        var jLen;\n        var pathNodes;\n        var commands;\n        var pathArr;\n        var singleShape = this.data.singleShape;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n            shapeData = charData && charData.data || {};\n            matrixHelper.reset();\n            if (singleShape && letters[i].n) {\n                xPos = -trackingOffset;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                firstLine = false;\n            }\n            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\n            jLen = shapes.length;\n            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n            if (singleShape) {\n                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n            }\n            commands = createSizedArray(jLen - 1);\n            var commandsCounter = 0;\n            for(j = 0; j < jLen; j += 1){\n                if (shapes[j].ty === \"sh\") {\n                    kLen = shapes[j].ks.k.i.length;\n                    pathNodes = shapes[j].ks.k;\n                    pathArr = [];\n                    for(k = 1; k < kLen; k += 1){\n                        if (k === 1) {\n                            pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                        }\n                        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));\n                    }\n                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                    commands[commandsCounter] = pathArr;\n                    commandsCounter += 1;\n                }\n            }\n            if (singleShape) {\n                xPos += letters[i].l;\n                xPos += trackingOffset;\n            }\n            if (this.textSpans[cnt]) {\n                this.textSpans[cnt].elem = commands;\n            } else {\n                this.textSpans[cnt] = {\n                    elem: commands\n                };\n            }\n            cnt += 1;\n        }\n    };\n    CVTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var ctx = this.canvasContext;\n        ctx.font = this.values.fValue;\n        this.globalData.renderer.ctxLineCap(\"butt\"); // ctx.lineCap = 'butt';\n        this.globalData.renderer.ctxLineJoin(\"miter\"); // ctx.lineJoin = 'miter';\n        this.globalData.renderer.ctxMiterLimit(4); // ctx.miterLimit = 4;\n        if (!this.data.singleShape) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        }\n        var i;\n        var len;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var lastFill = null;\n        var lastStroke = null;\n        var lastStrokeW = null;\n        var commands;\n        var pathArr;\n        var renderer = this.globalData.renderer;\n        for(i = 0; i < len; i += 1){\n            if (!letters[i].n) {\n                renderedLetter = renderedLetters[i];\n                if (renderedLetter) {\n                    renderer.save();\n                    renderer.ctxTransform(renderedLetter.p);\n                    renderer.ctxOpacity(renderedLetter.o);\n                }\n                if (this.fill) {\n                    if (renderedLetter && renderedLetter.fc) {\n                        if (lastFill !== renderedLetter.fc) {\n                            renderer.ctxFillStyle(renderedLetter.fc);\n                            lastFill = renderedLetter.fc; // ctx.fillStyle = renderedLetter.fc;\n                        }\n                    } else if (lastFill !== this.values.fill) {\n                        lastFill = this.values.fill;\n                        renderer.ctxFillStyle(this.values.fill); // ctx.fillStyle = this.values.fill;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxFill(); // this.globalData.canvasContext.fill();\n                /// ctx.fillText(this.textSpans[i].val,0,0);\n                }\n                if (this.stroke) {\n                    if (renderedLetter && renderedLetter.sw) {\n                        if (lastStrokeW !== renderedLetter.sw) {\n                            lastStrokeW = renderedLetter.sw;\n                            renderer.ctxLineWidth(renderedLetter.sw); // ctx.lineWidth = renderedLetter.sw;\n                        }\n                    } else if (lastStrokeW !== this.values.sWidth) {\n                        lastStrokeW = this.values.sWidth;\n                        renderer.ctxLineWidth(this.values.sWidth); // ctx.lineWidth = this.values.sWidth;\n                    }\n                    if (renderedLetter && renderedLetter.sc) {\n                        if (lastStroke !== renderedLetter.sc) {\n                            lastStroke = renderedLetter.sc;\n                            renderer.ctxStrokeStyle(renderedLetter.sc); // ctx.strokeStyle = renderedLetter.sc;\n                        }\n                    } else if (lastStroke !== this.values.stroke) {\n                        lastStroke = this.values.stroke;\n                        renderer.ctxStrokeStyle(this.values.stroke); // ctx.strokeStyle = this.values.stroke;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxStroke(); // this.globalData.canvasContext.stroke();\n                /// ctx.strokeText(letters[i].val,0,0);\n                }\n                if (renderedLetter) {\n                    this.globalData.renderer.restore();\n                }\n            }\n        }\n    };\n    function CVImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.img = globalData.imageLoader.getAsset(this.assetData);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVImageElement);\n    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVImageElement.prototype.createContent = function() {\n        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n            var canvas = createTag(\"canvas\");\n            canvas.width = this.assetData.w;\n            canvas.height = this.assetData.h;\n            var ctx = canvas.getContext(\"2d\");\n            var imgW = this.img.width;\n            var imgH = this.img.height;\n            var imgRel = imgW / imgH;\n            var canvasRel = this.assetData.w / this.assetData.h;\n            var widthCrop;\n            var heightCrop;\n            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\n            if (imgRel > canvasRel && par === \"xMidYMid slice\" || imgRel < canvasRel && par !== \"xMidYMid slice\") {\n                heightCrop = imgH;\n                widthCrop = heightCrop * canvasRel;\n            } else {\n                widthCrop = imgW;\n                heightCrop = widthCrop / canvasRel;\n            }\n            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);\n            this.img = canvas;\n        }\n    };\n    CVImageElement.prototype.renderInnerContent = function() {\n        this.canvasContext.drawImage(this.img, 0, 0);\n    };\n    CVImageElement.prototype.destroy = function() {\n        this.img = null;\n    };\n    function CVSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVSolidElement);\n    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVSolidElement.prototype.renderInnerContent = function() {\n        // var ctx = this.canvasContext;\n        this.globalData.renderer.ctxFillStyle(this.data.sc); // ctx.fillStyle = this.data.sc;\n        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh); // ctx.fillRect(0, 0, this.data.sw, this.data.sh);\n    //\n    };\n    function CanvasRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], CanvasRendererBase);\n    CanvasRendererBase.prototype.createShape = function(data) {\n        return new CVShapeElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createText = function(data) {\n        return new CVTextElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createImage = function(data) {\n        return new CVImageElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createSolid = function(data) {\n        return new CVSolidElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    CanvasRendererBase.prototype.ctxTransform = function(props) {\n        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n            return;\n        }\n        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);\n    };\n    CanvasRendererBase.prototype.ctxOpacity = function(op) {\n        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\n    };\n    CanvasRendererBase.prototype.ctxFillStyle = function(value) {\n        this.canvasContext.fillStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxStrokeStyle = function(value) {\n        this.canvasContext.strokeStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxLineWidth = function(value) {\n        this.canvasContext.lineWidth = value;\n    };\n    CanvasRendererBase.prototype.ctxLineCap = function(value) {\n        this.canvasContext.lineCap = value;\n    };\n    CanvasRendererBase.prototype.ctxLineJoin = function(value) {\n        this.canvasContext.lineJoin = value;\n    };\n    CanvasRendererBase.prototype.ctxMiterLimit = function(value) {\n        this.canvasContext.miterLimit = value;\n    };\n    CanvasRendererBase.prototype.ctxFill = function(rule) {\n        this.canvasContext.fill(rule);\n    };\n    CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {\n        this.canvasContext.fillRect(x, y, w, h);\n    };\n    CanvasRendererBase.prototype.ctxStroke = function() {\n        this.canvasContext.stroke();\n    };\n    CanvasRendererBase.prototype.reset = function() {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        this.contextData.reset();\n    };\n    CanvasRendererBase.prototype.save = function() {\n        this.canvasContext.save();\n    };\n    CanvasRendererBase.prototype.restore = function(actionFlag) {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        if (actionFlag) {\n            this.globalData.blendMode = \"source-over\";\n        }\n        this.contextData.restore(actionFlag);\n    };\n    CanvasRendererBase.prototype.configAnimation = function(animData) {\n        if (this.animationItem.wrapper) {\n            this.animationItem.container = createTag(\"canvas\");\n            var containerStyle = this.animationItem.container.style;\n            containerStyle.width = \"100%\";\n            containerStyle.height = \"100%\";\n            var origin = \"0px 0px 0px\";\n            containerStyle.transformOrigin = origin;\n            containerStyle.mozTransformOrigin = origin;\n            containerStyle.webkitTransformOrigin = origin;\n            containerStyle[\"-webkit-transform\"] = origin;\n            containerStyle.contentVisibility = this.renderConfig.contentVisibility;\n            this.animationItem.wrapper.appendChild(this.animationItem.container);\n            this.canvasContext = this.animationItem.container.getContext(\"2d\");\n            if (this.renderConfig.className) {\n                this.animationItem.container.setAttribute(\"class\", this.renderConfig.className);\n            }\n            if (this.renderConfig.id) {\n                this.animationItem.container.setAttribute(\"id\", this.renderConfig.id);\n            }\n        } else {\n            this.canvasContext = this.renderConfig.context;\n        }\n        this.contextData.setContext(this.canvasContext);\n        this.data = animData;\n        this.layers = animData.layers;\n        this.transformCanvas = {\n            w: animData.w,\n            h: animData.h,\n            sx: 0,\n            sy: 0,\n            tx: 0,\n            ty: 0\n        };\n        this.setupGlobalData(animData, document.body);\n        this.globalData.canvasContext = this.canvasContext;\n        this.globalData.renderer = this;\n        this.globalData.isDashed = false;\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.globalData.transformCanvas = this.transformCanvas;\n        this.elements = createSizedArray(animData.layers.length);\n        this.updateContainerSize();\n    };\n    CanvasRendererBase.prototype.updateContainerSize = function(width, height) {\n        this.reset();\n        var elementWidth;\n        var elementHeight;\n        if (width) {\n            elementWidth = width;\n            elementHeight = height;\n            this.canvasContext.canvas.width = elementWidth;\n            this.canvasContext.canvas.height = elementHeight;\n        } else {\n            if (this.animationItem.wrapper && this.animationItem.container) {\n                elementWidth = this.animationItem.wrapper.offsetWidth;\n                elementHeight = this.animationItem.wrapper.offsetHeight;\n            } else {\n                elementWidth = this.canvasContext.canvas.width;\n                elementHeight = this.canvasContext.canvas.height;\n            }\n            this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;\n            this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;\n        }\n        var elementRel;\n        var animationRel;\n        if (this.renderConfig.preserveAspectRatio.indexOf(\"meet\") !== -1 || this.renderConfig.preserveAspectRatio.indexOf(\"slice\") !== -1) {\n            var par = this.renderConfig.preserveAspectRatio.split(\" \");\n            var fillType = par[1] || \"meet\";\n            var pos = par[0] || \"xMidYMid\";\n            var xPos = pos.substr(0, 4);\n            var yPos = pos.substr(4);\n            elementRel = elementWidth / elementHeight;\n            animationRel = this.transformCanvas.w / this.transformCanvas.h;\n            if (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\") {\n                this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            } else {\n                this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            }\n            if (xPos === \"xMid\" && (animationRel < elementRel && fillType === \"meet\" || animationRel > elementRel && fillType === \"slice\")) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;\n            } else if (xPos === \"xMax\" && (animationRel < elementRel && fillType === \"meet\" || animationRel > elementRel && fillType === \"slice\")) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.tx = 0;\n            }\n            if (yPos === \"YMid\" && (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\")) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;\n            } else if (yPos === \"YMax\" && (animationRel > elementRel && fillType === \"meet\" || animationRel < elementRel && fillType === \"slice\")) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.ty = 0;\n            }\n        } else if (this.renderConfig.preserveAspectRatio === \"none\") {\n            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        } else {\n            this.transformCanvas.sx = this.renderConfig.dpr;\n            this.transformCanvas.sy = this.renderConfig.dpr;\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        }\n        this.transformCanvas.props = [\n            this.transformCanvas.sx,\n            0,\n            0,\n            0,\n            0,\n            this.transformCanvas.sy,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            this.transformCanvas.tx,\n            this.transformCanvas.ty,\n            0,\n            1\n        ];\n        /* var i, len = this.elements.length;\r\n      for(i=0;i<len;i+=1){\r\n          if(this.elements[i] && this.elements[i].data.ty === 0){\r\n              this.elements[i].resize(this.globalData.transformCanvas);\r\n          }\r\n      } */ this.ctxTransform(this.transformCanvas.props);\n        this.canvasContext.beginPath();\n        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n        this.canvasContext.closePath();\n        this.canvasContext.clip();\n        this.renderFrame(this.renderedFrame, true);\n    };\n    CanvasRendererBase.prototype.destroy = function() {\n        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.globalData.canvasContext = null;\n        this.animationItem.container = null;\n        this.destroyed = true;\n    };\n    CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {\n        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {\n            return;\n        }\n        this.renderedFrame = num;\n        this.globalData.frameNum = num - this.animationItem._isFirstFrame;\n        this.globalData.frameId += 1;\n        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;\n        this.globalData.projectInterface.currentFrame = num; // console.log('--------');\n        // console.log('NEW: ',num);\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            if (this.renderConfig.clearCanvas === true) {\n                this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n            } else {\n                this.save();\n            }\n            for(i = len - 1; i >= 0; i -= 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n            if (this.renderConfig.clearCanvas !== true) {\n                this.restore();\n            }\n        }\n    };\n    CanvasRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        var element = this.createItem(this.layers[pos], this, this.globalData);\n        elements[pos] = element;\n        element.initExpressions();\n    /* if(this.layers[pos].ty === 0){\r\n          element.resize(this.globalData.transformCanvas);\r\n      } */ };\n    CanvasRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    CanvasRendererBase.prototype.hide = function() {\n        this.animationItem.container.style.display = \"none\";\n    };\n    CanvasRendererBase.prototype.show = function() {\n        this.animationItem.container.style.display = \"block\";\n    };\n    function CanvasContext() {\n        this.opacity = -1;\n        this.transform = createTypedArray(\"float32\", 16);\n        this.fillStyle = \"\";\n        this.strokeStyle = \"\";\n        this.lineWidth = \"\";\n        this.lineCap = \"\";\n        this.lineJoin = \"\";\n        this.miterLimit = \"\";\n        this.id = Math.random();\n    }\n    function CVContextData() {\n        this.stack = [];\n        this.cArrPos = 0;\n        this.cTr = new Matrix();\n        var i;\n        var len = 15;\n        for(i = 0; i < len; i += 1){\n            var canvasContext = new CanvasContext();\n            this.stack[i] = canvasContext;\n        }\n        this._length = len;\n        this.nativeContext = null;\n        this.transformMat = new Matrix();\n        this.currentOpacity = 1; //\n        this.currentFillStyle = \"\";\n        this.appliedFillStyle = \"\"; //\n        this.currentStrokeStyle = \"\";\n        this.appliedStrokeStyle = \"\"; //\n        this.currentLineWidth = \"\";\n        this.appliedLineWidth = \"\"; //\n        this.currentLineCap = \"\";\n        this.appliedLineCap = \"\"; //\n        this.currentLineJoin = \"\";\n        this.appliedLineJoin = \"\"; //\n        this.appliedMiterLimit = \"\";\n        this.currentMiterLimit = \"\";\n    }\n    CVContextData.prototype.duplicate = function() {\n        var newLength = this._length * 2;\n        var i = 0;\n        for(i = this._length; i < newLength; i += 1){\n            this.stack[i] = new CanvasContext();\n        }\n        this._length = newLength;\n    };\n    CVContextData.prototype.reset = function() {\n        this.cArrPos = 0;\n        this.cTr.reset();\n        this.stack[this.cArrPos].opacity = 1;\n    };\n    CVContextData.prototype.restore = function(forceRestore) {\n        this.cArrPos -= 1;\n        var currentContext = this.stack[this.cArrPos];\n        var transform = currentContext.transform;\n        var i;\n        var arr = this.cTr.props;\n        for(i = 0; i < 16; i += 1){\n            arr[i] = transform[i];\n        }\n        if (forceRestore) {\n            this.nativeContext.restore();\n            var prevStack = this.stack[this.cArrPos + 1];\n            this.appliedFillStyle = prevStack.fillStyle;\n            this.appliedStrokeStyle = prevStack.strokeStyle;\n            this.appliedLineWidth = prevStack.lineWidth;\n            this.appliedLineCap = prevStack.lineCap;\n            this.appliedLineJoin = prevStack.lineJoin;\n            this.appliedMiterLimit = prevStack.miterLimit;\n        }\n        this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);\n        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {\n            this.nativeContext.globalAlpha = currentContext.opacity;\n            this.currentOpacity = currentContext.opacity;\n        }\n        this.currentFillStyle = currentContext.fillStyle;\n        this.currentStrokeStyle = currentContext.strokeStyle;\n        this.currentLineWidth = currentContext.lineWidth;\n        this.currentLineCap = currentContext.lineCap;\n        this.currentLineJoin = currentContext.lineJoin;\n        this.currentMiterLimit = currentContext.miterLimit;\n    };\n    CVContextData.prototype.save = function(saveOnNativeFlag) {\n        if (saveOnNativeFlag) {\n            this.nativeContext.save();\n        }\n        var props = this.cTr.props;\n        if (this._length <= this.cArrPos) {\n            this.duplicate();\n        }\n        var currentStack = this.stack[this.cArrPos];\n        var i;\n        for(i = 0; i < 16; i += 1){\n            currentStack.transform[i] = props[i];\n        }\n        this.cArrPos += 1;\n        var newStack = this.stack[this.cArrPos];\n        newStack.opacity = currentStack.opacity;\n        newStack.fillStyle = currentStack.fillStyle;\n        newStack.strokeStyle = currentStack.strokeStyle;\n        newStack.lineWidth = currentStack.lineWidth;\n        newStack.lineCap = currentStack.lineCap;\n        newStack.lineJoin = currentStack.lineJoin;\n        newStack.miterLimit = currentStack.miterLimit;\n    };\n    CVContextData.prototype.setOpacity = function(value) {\n        this.stack[this.cArrPos].opacity = value;\n    };\n    CVContextData.prototype.setContext = function(value) {\n        this.nativeContext = value;\n    };\n    CVContextData.prototype.fillStyle = function(value) {\n        if (this.stack[this.cArrPos].fillStyle !== value) {\n            this.currentFillStyle = value;\n            this.stack[this.cArrPos].fillStyle = value;\n        }\n    };\n    CVContextData.prototype.strokeStyle = function(value) {\n        if (this.stack[this.cArrPos].strokeStyle !== value) {\n            this.currentStrokeStyle = value;\n            this.stack[this.cArrPos].strokeStyle = value;\n        }\n    };\n    CVContextData.prototype.lineWidth = function(value) {\n        if (this.stack[this.cArrPos].lineWidth !== value) {\n            this.currentLineWidth = value;\n            this.stack[this.cArrPos].lineWidth = value;\n        }\n    };\n    CVContextData.prototype.lineCap = function(value) {\n        if (this.stack[this.cArrPos].lineCap !== value) {\n            this.currentLineCap = value;\n            this.stack[this.cArrPos].lineCap = value;\n        }\n    };\n    CVContextData.prototype.lineJoin = function(value) {\n        if (this.stack[this.cArrPos].lineJoin !== value) {\n            this.currentLineJoin = value;\n            this.stack[this.cArrPos].lineJoin = value;\n        }\n    };\n    CVContextData.prototype.miterLimit = function(value) {\n        if (this.stack[this.cArrPos].miterLimit !== value) {\n            this.currentMiterLimit = value;\n            this.stack[this.cArrPos].miterLimit = value;\n        }\n    };\n    CVContextData.prototype.transform = function(props) {\n        this.transformMat.cloneFromProps(props); // Taking the last transform value from the stored stack of transforms\n        var currentTransform = this.cTr; // Applying the last transform value after the new transform to respect the order of transformations\n        this.transformMat.multiply(currentTransform); // Storing the new transformed value in the stored transform\n        currentTransform.cloneFromProps(this.transformMat.props);\n        var trProps = currentTransform.props; // Applying the new transform to the canvas\n        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);\n    };\n    CVContextData.prototype.opacity = function(op) {\n        var currentOpacity = this.stack[this.cArrPos].opacity;\n        currentOpacity *= op < 0 ? 0 : op;\n        if (this.stack[this.cArrPos].opacity !== currentOpacity) {\n            if (this.currentOpacity !== op) {\n                this.nativeContext.globalAlpha = op;\n                this.currentOpacity = op;\n            }\n            this.stack[this.cArrPos].opacity = currentOpacity;\n        }\n    };\n    CVContextData.prototype.fill = function(rule) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fill(rule);\n    };\n    CVContextData.prototype.fillRect = function(x, y, w, h) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fillRect(x, y, w, h);\n    };\n    CVContextData.prototype.stroke = function() {\n        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {\n            this.appliedStrokeStyle = this.currentStrokeStyle;\n            this.nativeContext.strokeStyle = this.appliedStrokeStyle;\n        }\n        if (this.appliedLineWidth !== this.currentLineWidth) {\n            this.appliedLineWidth = this.currentLineWidth;\n            this.nativeContext.lineWidth = this.appliedLineWidth;\n        }\n        if (this.appliedLineCap !== this.currentLineCap) {\n            this.appliedLineCap = this.currentLineCap;\n            this.nativeContext.lineCap = this.appliedLineCap;\n        }\n        if (this.appliedLineJoin !== this.currentLineJoin) {\n            this.appliedLineJoin = this.currentLineJoin;\n            this.nativeContext.lineJoin = this.appliedLineJoin;\n        }\n        if (this.appliedMiterLimit !== this.currentMiterLimit) {\n            this.appliedMiterLimit = this.currentMiterLimit;\n            this.nativeContext.miterLimit = this.appliedMiterLimit;\n        }\n        this.nativeContext.stroke();\n    };\n    function CVCompElement(data, globalData, comp) {\n        this.completeLayers = false;\n        this.layers = data.layers;\n        this.pendingElements = [];\n        this.elements = createSizedArray(this.layers.length);\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        CanvasRendererBase,\n        ICompElement,\n        CVBaseElement\n    ], CVCompElement);\n    CVCompElement.prototype.renderInnerContent = function() {\n        var ctx = this.canvasContext;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(this.data.w, 0);\n        ctx.lineTo(this.data.w, this.data.h);\n        ctx.lineTo(0, this.data.h);\n        ctx.lineTo(0, 0);\n        ctx.clip();\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    CVCompElement.prototype.destroy = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n        this.layers = null;\n        this.elements = null;\n    };\n    CVCompElement.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function CanvasRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.renderConfig = {\n            clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n            context: config && config.context || null,\n            progressiveLoad: config && config.progressiveLoad || false,\n            preserveAspectRatio: config && config.preserveAspectRatio || \"xMidYMid meet\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            contentVisibility: config && config.contentVisibility || \"visible\",\n            className: config && config.className || \"\",\n            id: config && config.id || \"\",\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.renderConfig.dpr = config && config.dpr || 1;\n        if (this.animationItem.wrapper) {\n            this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;\n        }\n        this.renderedFrame = -1;\n        this.globalData = {\n            frameNum: -1,\n            _mdf: false,\n            renderConfig: this.renderConfig,\n            currentGlobalAlpha: -1\n        };\n        this.contextData = new CVContextData();\n        this.elements = [];\n        this.pendingElements = [];\n        this.transformMat = new Matrix();\n        this.completeLayers = false;\n        this.rendererType = \"canvas\";\n        if (this.renderConfig.clearCanvas) {\n            this.ctxTransform = this.contextData.transform.bind(this.contextData);\n            this.ctxOpacity = this.contextData.opacity.bind(this.contextData);\n            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);\n            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);\n            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);\n            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);\n            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);\n            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);\n            this.ctxFill = this.contextData.fill.bind(this.contextData);\n            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);\n            this.ctxStroke = this.contextData.stroke.bind(this.contextData);\n            this.save = this.contextData.save.bind(this.contextData);\n        }\n    }\n    extendPrototype([\n        CanvasRendererBase\n    ], CanvasRenderer);\n    CanvasRenderer.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function HBaseElement() {}\n    HBaseElement.prototype = {\n        checkBlendMode: function checkBlendMode() {},\n        initRendererElement: function initRendererElement() {\n            this.baseElement = createTag(this.data.tg || \"div\");\n            if (this.data.hasMask) {\n                this.svgElement = createNS(\"svg\");\n                this.layerElement = createNS(\"g\");\n                this.maskedElement = this.layerElement;\n                this.svgElement.appendChild(this.layerElement);\n                this.baseElement.appendChild(this.svgElement);\n            } else {\n                this.layerElement = this.baseElement;\n            }\n            styleDiv(this.baseElement);\n        },\n        createContainerElements: function createContainerElements() {\n            this.renderableEffectsManager = new CVEffects(this);\n            this.transformedElement = this.baseElement;\n            this.maskedElement = this.layerElement;\n            if (this.data.ln) {\n                this.layerElement.setAttribute(\"id\", this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute(\"class\", this.data.cl);\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};\n            if (this.finalTransform._matMdf) {\n                var matrixValue = this.finalTransform.mat.toCSS();\n                transformedElementStyle.transform = matrixValue;\n                transformedElementStyle.webkitTransform = matrixValue;\n            }\n            if (this.finalTransform._opMdf) {\n                transformedElementStyle.opacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderFrame: function renderFrame() {\n            // If it is exported as hidden (data.hd === true) no need to render\n            // If it is not visible no need to render\n            if (this.data.hd || this.hidden) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderElement();\n            this.renderInnerContent();\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.layerElement = null;\n            this.transformedElement = null;\n            if (this.matteElement) {\n                this.matteElement = null;\n            }\n            if (this.maskManager) {\n                this.maskManager.destroy();\n                this.maskManager = null;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n        },\n        addEffects: function addEffects() {},\n        setMatte: function setMatte() {}\n    };\n    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\n    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\n    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;\n    function HSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], HSolidElement);\n    HSolidElement.prototype.createContent = function() {\n        var rect;\n        if (this.data.hasMask) {\n            rect = createNS(\"rect\");\n            rect.setAttribute(\"width\", this.data.sw);\n            rect.setAttribute(\"height\", this.data.sh);\n            rect.setAttribute(\"fill\", this.data.sc);\n            this.svgElement.setAttribute(\"width\", this.data.sw);\n            this.svgElement.setAttribute(\"height\", this.data.sh);\n        } else {\n            rect = createTag(\"div\");\n            rect.style.width = this.data.sw + \"px\";\n            rect.style.height = this.data.sh + \"px\";\n            rect.style.backgroundColor = this.data.sc;\n        }\n        this.layerElement.appendChild(rect);\n    };\n    function HShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = []; // Full shape data\n        this.shapesData = data.shapes; // List of styles that will be applied to shapes\n        this.stylesList = []; // List of modifiers that will be applied to shapes\n        this.shapeModifiers = []; // List of items in shape tree\n        this.itemsData = []; // List of items in previous shape tree\n        this.processedElements = []; // List of animated components\n        this.animatedContents = [];\n        this.shapesContainer = createNS(\"g\");\n        this.initElement(data, globalData, comp); // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HSolidElement,\n        SVGShapeElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HShapeElement);\n    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\n    HShapeElement.prototype.createContent = function() {\n        var cont;\n        this.baseElement.style.fontSize = 0;\n        if (this.data.hasMask) {\n            this.layerElement.appendChild(this.shapesContainer);\n            cont = this.svgElement;\n        } else {\n            cont = createNS(\"svg\");\n            var size = this.comp.data ? this.comp.data : this.globalData.compSize;\n            cont.setAttribute(\"width\", size.w);\n            cont.setAttribute(\"height\", size.h);\n            cont.appendChild(this.shapesContainer);\n            this.layerElement.appendChild(cont);\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);\n        this.filterUniqueShapes();\n        this.shapeCont = cont;\n    };\n    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {\n        var i;\n        var len = transformers.length;\n        for(i = 0; i < len; i += 1){\n            point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\n        }\n        return point;\n    };\n    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {\n        var shape = item.sh.v;\n        var transformers = item.transformers;\n        var i;\n        var len = shape._length;\n        var vPoint;\n        var oPoint;\n        var nextIPoint;\n        var nextVPoint;\n        if (len <= 1) {\n            return;\n        }\n        for(i = 0; i < len - 1; i += 1){\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n        if (shape.c) {\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n    };\n    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\n        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\n        var bounds = this.shapeBoundingBox;\n        boundingBox.x = bmMin(bounds.left, boundingBox.x);\n        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);\n        boundingBox.y = bmMin(bounds.top, boundingBox.y);\n        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);\n    };\n    HShapeElement.prototype.shapeBoundingBox = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    HShapeElement.prototype.tempBoundingBox = {\n        x: 0,\n        xMax: 0,\n        y: 0,\n        yMax: 0,\n        width: 0,\n        height: 0\n    };\n    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {\n        var bounds = [\n            [\n                p0[0],\n                p3[0]\n            ],\n            [\n                p0[1],\n                p3[1]\n            ]\n        ];\n        for(var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i){\n            // eslint-disable-line no-plusplus\n            b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n            a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n            c = 3 * p1[i] - 3 * p0[i];\n            b |= 0; // eslint-disable-line no-bitwise\n            a |= 0; // eslint-disable-line no-bitwise\n            c |= 0; // eslint-disable-line no-bitwise\n            if (a === 0 && b === 0) {} else if (a === 0) {\n                t = -c / b;\n                if (t > 0 && t < 1) {\n                    bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));\n                }\n            } else {\n                b2ac = b * b - 4 * c * a;\n                if (b2ac >= 0) {\n                    t1 = (-b + bmSqrt(b2ac)) / (2 * a);\n                    if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));\n                    t2 = (-b - bmSqrt(b2ac)) / (2 * a);\n                    if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));\n                }\n            }\n        }\n        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);\n        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);\n        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);\n        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);\n    };\n    HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {\n        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];\n    };\n    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {\n        var i;\n        var len = itemsData.length;\n        for(i = 0; i < len; i += 1){\n            if (itemsData[i] && itemsData[i].sh) {\n                this.calculateShapeBoundingBox(itemsData[i], boundingBox);\n            } else if (itemsData[i] && itemsData[i].it) {\n                this.calculateBoundingBox(itemsData[i].it, boundingBox);\n            } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {\n                this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);\n            }\n        }\n    };\n    HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {\n        var width = 0;\n        if (widthProperty.keyframes) {\n            for(var i = 0; i < widthProperty.keyframes.length; i += 1){\n                var kfw = widthProperty.keyframes[i].s;\n                if (kfw > width) {\n                    width = kfw;\n                }\n            }\n            width *= widthProperty.mult;\n        } else {\n            width = widthProperty.v * widthProperty.mult;\n        }\n        boundingBox.x -= width;\n        boundingBox.xMax += width;\n        boundingBox.y -= width;\n        boundingBox.yMax += width;\n    };\n    HShapeElement.prototype.currentBoxContains = function(box) {\n        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;\n    };\n    HShapeElement.prototype.renderInnerContent = function() {\n        this._renderShapeFrame();\n        if (!this.hidden && (this._isFirstFrame || this._mdf)) {\n            var tempBoundingBox = this.tempBoundingBox;\n            var max = 999999;\n            tempBoundingBox.x = max;\n            tempBoundingBox.xMax = -max;\n            tempBoundingBox.y = max;\n            tempBoundingBox.yMax = -max;\n            this.calculateBoundingBox(this.itemsData, tempBoundingBox);\n            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\n            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y; // var tempBoundingBox = this.shapeCont.getBBox();\n            if (this.currentBoxContains(tempBoundingBox)) {\n                return;\n            }\n            var changed = false;\n            if (this.currentBBox.w !== tempBoundingBox.width) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.shapeCont.setAttribute(\"width\", tempBoundingBox.width);\n                changed = true;\n            }\n            if (this.currentBBox.h !== tempBoundingBox.height) {\n                this.currentBBox.h = tempBoundingBox.height;\n                this.shapeCont.setAttribute(\"height\", tempBoundingBox.height);\n                changed = true;\n            }\n            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.currentBBox.h = tempBoundingBox.height;\n                this.currentBBox.x = tempBoundingBox.x;\n                this.currentBBox.y = tempBoundingBox.y;\n                this.shapeCont.setAttribute(\"viewBox\", this.currentBBox.x + \" \" + this.currentBBox.y + \" \" + this.currentBBox.w + \" \" + this.currentBBox.h);\n                var shapeStyle = this.shapeCont.style;\n                var shapeTransform = \"translate(\" + this.currentBBox.x + \"px,\" + this.currentBBox.y + \"px)\";\n                shapeStyle.transform = shapeTransform;\n                shapeStyle.webkitTransform = shapeTransform;\n            }\n        }\n    };\n    function HTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.textPaths = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n        this.renderType = \"svg\";\n        this.isMasked = false;\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], HTextElement);\n    HTextElement.prototype.createContent = function() {\n        this.isMasked = this.checkMasks();\n        if (this.isMasked) {\n            this.renderType = \"svg\";\n            this.compW = this.comp.data.w;\n            this.compH = this.comp.data.h;\n            this.svgElement.setAttribute(\"width\", this.compW);\n            this.svgElement.setAttribute(\"height\", this.compH);\n            var g = createNS(\"g\");\n            this.maskedElement.appendChild(g);\n            this.innerElem = g;\n        } else {\n            this.renderType = \"html\";\n            this.innerElem = this.layerElement;\n        }\n        this.checkParenting();\n    };\n    HTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var innerElemStyle = this.innerElem.style;\n        var textColor = documentData.fc ? this.buildColor(documentData.fc) : \"rgba(0,0,0,0)\";\n        innerElemStyle.fill = textColor;\n        innerElemStyle.color = textColor;\n        if (documentData.sc) {\n            innerElemStyle.stroke = this.buildColor(documentData.sc);\n            innerElemStyle.strokeWidth = documentData.sw + \"px\";\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (!this.globalData.fontManager.chars) {\n            innerElemStyle.fontSize = documentData.finalSize + \"px\";\n            innerElemStyle.lineHeight = documentData.finalSize + \"px\";\n            if (fontData.fClass) {\n                this.innerElem.className = fontData.fClass;\n            } else {\n                innerElemStyle.fontFamily = fontData.fFamily;\n                var fWeight = documentData.fWeight;\n                var fStyle = documentData.fStyle;\n                innerElemStyle.fontStyle = fStyle;\n                innerElemStyle.fontWeight = fWeight;\n            }\n        }\n        var i;\n        var len;\n        var letters = documentData.l;\n        len = letters.length;\n        var tSpan;\n        var tParent;\n        var tCont;\n        var matrixHelper = this.mHelper;\n        var shapes;\n        var shapeStr = \"\";\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            if (this.globalData.fontManager.chars) {\n                if (!this.textPaths[cnt]) {\n                    tSpan = createNS(\"path\");\n                    tSpan.setAttribute(\"stroke-linecap\", lineCapEnum[1]);\n                    tSpan.setAttribute(\"stroke-linejoin\", lineJoinEnum[2]);\n                    tSpan.setAttribute(\"stroke-miterlimit\", \"4\");\n                } else {\n                    tSpan = this.textPaths[cnt];\n                }\n                if (!this.isMasked) {\n                    if (this.textSpans[cnt]) {\n                        tParent = this.textSpans[cnt];\n                        tCont = tParent.children[0];\n                    } else {\n                        tParent = createTag(\"div\");\n                        tParent.style.lineHeight = 0;\n                        tCont = createNS(\"svg\");\n                        tCont.appendChild(tSpan);\n                        styleDiv(tParent);\n                    }\n                }\n            } else if (!this.isMasked) {\n                if (this.textSpans[cnt]) {\n                    tParent = this.textSpans[cnt];\n                    tSpan = this.textPaths[cnt];\n                } else {\n                    tParent = createTag(\"span\");\n                    styleDiv(tParent);\n                    tSpan = createTag(\"span\");\n                    styleDiv(tSpan);\n                    tParent.appendChild(tSpan);\n                }\n            } else {\n                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS(\"text\");\n            } // tSpan.setAttribute('visibility', 'hidden');\n            if (this.globalData.fontManager.chars) {\n                var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                var shapeData;\n                if (charData) {\n                    shapeData = charData.data;\n                } else {\n                    shapeData = null;\n                }\n                matrixHelper.reset();\n                if (shapeData && shapeData.shapes && shapeData.shapes.length) {\n                    shapes = shapeData.shapes[0].it;\n                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n                    shapeStr = this.createPathShape(matrixHelper, shapes);\n                    tSpan.setAttribute(\"d\", shapeStr);\n                }\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent);\n                    if (shapeData && shapeData.shapes) {\n                        // document.body.appendChild is needed to get exact measure of shape\n                        document.body.appendChild(tCont);\n                        var boundingBox = tCont.getBBox();\n                        tCont.setAttribute(\"width\", boundingBox.width + 2);\n                        tCont.setAttribute(\"height\", boundingBox.height + 2);\n                        tCont.setAttribute(\"viewBox\", boundingBox.x - 1 + \" \" + (boundingBox.y - 1) + \" \" + (boundingBox.width + 2) + \" \" + (boundingBox.height + 2));\n                        var tContStyle = tCont.style;\n                        var tContTranslation = \"translate(\" + (boundingBox.x - 1) + \"px,\" + (boundingBox.y - 1) + \"px)\";\n                        tContStyle.transform = tContTranslation;\n                        tContStyle.webkitTransform = tContTranslation;\n                        letters[i].yOffset = boundingBox.y - 1;\n                    } else {\n                        tCont.setAttribute(\"width\", 1);\n                        tCont.setAttribute(\"height\", 1);\n                    }\n                    tParent.appendChild(tCont);\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            } else {\n                tSpan.textContent = letters[i].val;\n                tSpan.setAttributeNS(\"http://www.w3.org/XML/1998/namespace\", \"xml:space\", \"preserve\");\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent); //\n                    var tStyle = tSpan.style;\n                    var tSpanTranslation = \"translate3d(0,\" + -documentData.finalSize / 1.2 + \"px,0)\";\n                    tStyle.transform = tSpanTranslation;\n                    tStyle.webkitTransform = tSpanTranslation;\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            } //\n            if (!this.isMasked) {\n                this.textSpans[cnt] = tParent;\n            } else {\n                this.textSpans[cnt] = tSpan;\n            }\n            this.textSpans[cnt].style.display = \"block\";\n            this.textPaths[cnt] = tSpan;\n            cnt += 1;\n        }\n        while(cnt < this.textSpans.length){\n            this.textSpans[cnt].style.display = \"none\";\n            cnt += 1;\n        }\n    };\n    HTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var svgStyle;\n        if (this.data.singleShape) {\n            if (!this._isFirstFrame && !this.lettersChangedFlag) {\n                return;\n            }\n            if (this.isMasked && this.finalTransform._matMdf) {\n                // Todo Benchmark if using this is better than getBBox\n                this.svgElement.setAttribute(\"viewBox\", -this.finalTransform.mProp.p.v[0] + \" \" + -this.finalTransform.mProp.p.v[1] + \" \" + this.compW + \" \" + this.compH);\n                svgStyle = this.svgElement.style;\n                var translation = \"translate(\" + -this.finalTransform.mProp.p.v[0] + \"px,\" + -this.finalTransform.mProp.p.v[1] + \"px)\";\n                svgStyle.transform = translation;\n                svgStyle.webkitTransform = translation;\n            }\n        }\n        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {\n            return;\n        }\n        var i;\n        var len;\n        var count = 0;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var textSpan;\n        var textPath;\n        for(i = 0; i < len; i += 1){\n            if (letters[i].n) {\n                count += 1;\n            } else {\n                textSpan = this.textSpans[i];\n                textPath = this.textPaths[i];\n                renderedLetter = renderedLetters[count];\n                count += 1;\n                if (renderedLetter._mdf.m) {\n                    if (!this.isMasked) {\n                        textSpan.style.webkitTransform = renderedLetter.m;\n                        textSpan.style.transform = renderedLetter.m;\n                    } else {\n                        textSpan.setAttribute(\"transform\", renderedLetter.m);\n                    }\n                } /// /textSpan.setAttribute('opacity',renderedLetter.o);\n                textSpan.style.opacity = renderedLetter.o;\n                if (renderedLetter.sw && renderedLetter._mdf.sw) {\n                    textPath.setAttribute(\"stroke-width\", renderedLetter.sw);\n                }\n                if (renderedLetter.sc && renderedLetter._mdf.sc) {\n                    textPath.setAttribute(\"stroke\", renderedLetter.sc);\n                }\n                if (renderedLetter.fc && renderedLetter._mdf.fc) {\n                    textPath.setAttribute(\"fill\", renderedLetter.fc);\n                    textPath.style.color = renderedLetter.fc;\n                }\n            }\n        }\n        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {\n            var boundingBox = this.innerElem.getBBox();\n            if (this.currentBBox.w !== boundingBox.width) {\n                this.currentBBox.w = boundingBox.width;\n                this.svgElement.setAttribute(\"width\", boundingBox.width);\n            }\n            if (this.currentBBox.h !== boundingBox.height) {\n                this.currentBBox.h = boundingBox.height;\n                this.svgElement.setAttribute(\"height\", boundingBox.height);\n            }\n            var margin = 1;\n            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {\n                this.currentBBox.w = boundingBox.width + margin * 2;\n                this.currentBBox.h = boundingBox.height + margin * 2;\n                this.currentBBox.x = boundingBox.x - margin;\n                this.currentBBox.y = boundingBox.y - margin;\n                this.svgElement.setAttribute(\"viewBox\", this.currentBBox.x + \" \" + this.currentBBox.y + \" \" + this.currentBBox.w + \" \" + this.currentBBox.h);\n                svgStyle = this.svgElement.style;\n                var svgTransform = \"translate(\" + this.currentBBox.x + \"px,\" + this.currentBBox.y + \"px)\";\n                svgStyle.transform = svgTransform;\n                svgStyle.webkitTransform = svgTransform;\n            }\n        }\n    };\n    function HCameraElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initHierarchy();\n        var getProp = PropertyFactory.getProp;\n        this.pe = getProp(this, data.pe, 0, 0, this);\n        if (data.ks.p.s) {\n            this.px = getProp(this, data.ks.p.x, 1, 0, this);\n            this.py = getProp(this, data.ks.p.y, 1, 0, this);\n            this.pz = getProp(this, data.ks.p.z, 1, 0, this);\n        } else {\n            this.p = getProp(this, data.ks.p, 1, 0, this);\n        }\n        if (data.ks.a) {\n            this.a = getProp(this, data.ks.a, 1, 0, this);\n        }\n        if (data.ks.or.k.length && data.ks.or.k[0].to) {\n            var i;\n            var len = data.ks.or.k.length;\n            for(i = 0; i < len; i += 1){\n                data.ks.or.k[i].to = null;\n                data.ks.or.k[i].ti = null;\n            }\n        }\n        this.or = getProp(this, data.ks.or, 1, degToRads, this);\n        this.or.sh = true;\n        this.rx = getProp(this, data.ks.rx, 0, degToRads, this);\n        this.ry = getProp(this, data.ks.ry, 0, degToRads, this);\n        this.rz = getProp(this, data.ks.rz, 0, degToRads, this);\n        this.mat = new Matrix();\n        this._prevMat = new Matrix();\n        this._isFirstFrame = true; // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.\n        this.finalTransform = {\n            mProp: this\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        FrameElement,\n        HierarchyElement\n    ], HCameraElement);\n    HCameraElement.prototype.setup = function() {\n        var i;\n        var len = this.comp.threeDElements.length;\n        var comp;\n        var perspectiveStyle;\n        var containerStyle;\n        for(i = 0; i < len; i += 1){\n            // [perspectiveElem,container]\n            comp = this.comp.threeDElements[i];\n            if (comp.type === \"3d\") {\n                perspectiveStyle = comp.perspectiveElem.style;\n                containerStyle = comp.container.style;\n                var perspective = this.pe.v + \"px\";\n                var origin = \"0px 0px 0px\";\n                var matrix = \"matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\";\n                perspectiveStyle.perspective = perspective;\n                perspectiveStyle.webkitPerspective = perspective;\n                containerStyle.transformOrigin = origin;\n                containerStyle.mozTransformOrigin = origin;\n                containerStyle.webkitTransformOrigin = origin;\n                perspectiveStyle.transform = matrix;\n                perspectiveStyle.webkitTransform = matrix;\n            }\n        }\n    };\n    HCameraElement.prototype.createElements = function() {};\n    HCameraElement.prototype.hide = function() {};\n    HCameraElement.prototype.renderFrame = function() {\n        var _mdf = this._isFirstFrame;\n        var i;\n        var len;\n        if (this.hierarchy) {\n            len = this.hierarchy.length;\n            for(i = 0; i < len; i += 1){\n                _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\n            }\n        }\n        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {\n            this.mat.reset();\n            if (this.hierarchy) {\n                len = this.hierarchy.length - 1;\n                for(i = len; i >= 0; i -= 1){\n                    var mTransf = this.hierarchy[i].finalTransform.mProp;\n                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);\n                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\n                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\n                    this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);\n                    this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);\n                }\n            }\n            if (this.p) {\n                this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);\n            } else {\n                this.mat.translate(-this.px.v, -this.py.v, this.pz.v);\n            }\n            if (this.a) {\n                var diffVector;\n                if (this.p) {\n                    diffVector = [\n                        this.p.v[0] - this.a.v[0],\n                        this.p.v[1] - this.a.v[1],\n                        this.p.v[2] - this.a.v[2]\n                    ];\n                } else {\n                    diffVector = [\n                        this.px.v - this.a.v[0],\n                        this.py.v - this.a.v[1],\n                        this.pz.v - this.a.v[2]\n                    ];\n                }\n                var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2)); // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\n                var lookDir = [\n                    diffVector[0] / mag,\n                    diffVector[1] / mag,\n                    diffVector[2] / mag\n                ];\n                var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);\n                var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);\n                var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);\n                this.mat.rotateY(mRotationY).rotateX(-mRotationX);\n            }\n            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\n            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\n            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);\n            this.mat.translate(0, 0, this.pe.v);\n            var hasMatrixChanged = !this._prevMat.equals(this.mat);\n            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\n                len = this.comp.threeDElements.length;\n                var comp;\n                var perspectiveStyle;\n                var containerStyle;\n                for(i = 0; i < len; i += 1){\n                    comp = this.comp.threeDElements[i];\n                    if (comp.type === \"3d\") {\n                        if (hasMatrixChanged) {\n                            var matValue = this.mat.toCSS();\n                            containerStyle = comp.container.style;\n                            containerStyle.transform = matValue;\n                            containerStyle.webkitTransform = matValue;\n                        }\n                        if (this.pe._mdf) {\n                            perspectiveStyle = comp.perspectiveElem.style;\n                            perspectiveStyle.perspective = this.pe.v + \"px\";\n                            perspectiveStyle.webkitPerspective = this.pe.v + \"px\";\n                        }\n                    }\n                }\n                this.mat.clone(this._prevMat);\n            }\n        }\n        this._isFirstFrame = false;\n    };\n    HCameraElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    HCameraElement.prototype.destroy = function() {};\n    HCameraElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    function HImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HSolidElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HImageElement);\n    HImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        var img = new Image();\n        if (this.data.hasMask) {\n            this.imageElem = createNS(\"image\");\n            this.imageElem.setAttribute(\"width\", this.assetData.w + \"px\");\n            this.imageElem.setAttribute(\"height\", this.assetData.h + \"px\");\n            this.imageElem.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", assetPath);\n            this.layerElement.appendChild(this.imageElem);\n            this.baseElement.setAttribute(\"width\", this.assetData.w);\n            this.baseElement.setAttribute(\"height\", this.assetData.h);\n        } else {\n            this.layerElement.appendChild(img);\n        }\n        img.crossOrigin = \"anonymous\";\n        img.src = assetPath;\n        if (this.data.ln) {\n            this.baseElement.setAttribute(\"id\", this.data.ln);\n        }\n    };\n    function HybridRendererBase(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || \"\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"400%\",\n                height: config && config.filterSize && config.filterSize.height || \"400%\",\n                x: config && config.filterSize && config.filterSize.x || \"-100%\",\n                y: config && config.filterSize && config.filterSize.y || \"-100%\"\n            }\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = \"html\";\n    }\n    extendPrototype([\n        BaseRenderer\n    ], HybridRendererBase);\n    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;\n    HybridRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    HybridRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newDOMElement = element.getBaseElement();\n        if (!newDOMElement) {\n            return;\n        }\n        var layer = this.layers[pos];\n        if (!layer.ddd || !this.supports3d) {\n            if (this.threeDElements) {\n                this.addTo3dContainer(newDOMElement, pos);\n            } else {\n                var i = 0;\n                var nextDOMElement;\n                var nextLayer;\n                var tmpDOMElement;\n                while(i < pos){\n                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {\n                        nextLayer = this.elements[i];\n                        tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\n                        nextDOMElement = tmpDOMElement || nextDOMElement;\n                    }\n                    i += 1;\n                }\n                if (nextDOMElement) {\n                    if (!layer.ddd || !this.supports3d) {\n                        this.layerElement.insertBefore(newDOMElement, nextDOMElement);\n                    }\n                } else if (!layer.ddd || !this.supports3d) {\n                    this.layerElement.appendChild(newDOMElement);\n                }\n            }\n        } else {\n            this.addTo3dContainer(newDOMElement, pos);\n        }\n    };\n    HybridRendererBase.prototype.createShape = function(data) {\n        if (!this.supports3d) {\n            return new SVGShapeElement(data, this.globalData, this);\n        }\n        return new HShapeElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createText = function(data) {\n        if (!this.supports3d) {\n            return new SVGTextLottieElement(data, this.globalData, this);\n        }\n        return new HTextElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createCamera = function(data) {\n        this.camera = new HCameraElement(data, this.globalData, this);\n        return this.camera;\n    };\n    HybridRendererBase.prototype.createImage = function(data) {\n        if (!this.supports3d) {\n            return new IImageElement(data, this.globalData, this);\n        }\n        return new HImageElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createSolid = function(data) {\n        if (!this.supports3d) {\n            return new ISolidElement(data, this.globalData, this);\n        }\n        return new HSolidElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\n                return this.threeDElements[i].perspectiveElem;\n            }\n            i += 1;\n        }\n        return null;\n    };\n    HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {\n        var perspectiveElem = createTag(\"div\");\n        var style;\n        var containerStyle;\n        styleDiv(perspectiveElem);\n        var container = createTag(\"div\");\n        styleDiv(container);\n        if (type === \"3d\") {\n            style = perspectiveElem.style;\n            style.width = this.globalData.compSize.w + \"px\";\n            style.height = this.globalData.compSize.h + \"px\";\n            var center = \"50% 50%\";\n            style.webkitTransformOrigin = center;\n            style.mozTransformOrigin = center;\n            style.transformOrigin = center;\n            containerStyle = container.style;\n            var matrix = \"matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)\";\n            containerStyle.transform = matrix;\n            containerStyle.webkitTransform = matrix;\n        }\n        perspectiveElem.appendChild(container); // this.resizerElem.appendChild(perspectiveElem);\n        var threeDContainerData = {\n            container: container,\n            perspectiveElem: perspectiveElem,\n            startPos: pos,\n            endPos: pos,\n            type: type\n        };\n        this.threeDElements.push(threeDContainerData);\n        return threeDContainerData;\n    };\n    HybridRendererBase.prototype.build3dContainers = function() {\n        var i;\n        var len = this.layers.length;\n        var lastThreeDContainerData;\n        var currentContainer = \"\";\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ddd && this.layers[i].ty !== 3) {\n                if (currentContainer !== \"3d\") {\n                    currentContainer = \"3d\";\n                    lastThreeDContainerData = this.createThreeDContainer(i, \"3d\");\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            } else {\n                if (currentContainer !== \"2d\") {\n                    currentContainer = \"2d\";\n                    lastThreeDContainerData = this.createThreeDContainer(i, \"2d\");\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            }\n        }\n        len = this.threeDElements.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\n        }\n    };\n    HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (pos <= this.threeDElements[i].endPos) {\n                var j = this.threeDElements[i].startPos;\n                var nextElement;\n                while(j < pos){\n                    if (this.elements[j] && this.elements[j].getBaseElement) {\n                        nextElement = this.elements[j].getBaseElement();\n                    }\n                    j += 1;\n                }\n                if (nextElement) {\n                    this.threeDElements[i].container.insertBefore(elem, nextElement);\n                } else {\n                    this.threeDElements[i].container.appendChild(elem);\n                }\n                break;\n            }\n            i += 1;\n        }\n    };\n    HybridRendererBase.prototype.configAnimation = function(animData) {\n        var resizerElem = createTag(\"div\");\n        var wrapper = this.animationItem.wrapper;\n        var style = resizerElem.style;\n        style.width = animData.w + \"px\";\n        style.height = animData.h + \"px\";\n        this.resizerElem = resizerElem;\n        styleDiv(resizerElem);\n        style.transformStyle = \"flat\";\n        style.mozTransformStyle = \"flat\";\n        style.webkitTransformStyle = \"flat\";\n        if (this.renderConfig.className) {\n            resizerElem.setAttribute(\"class\", this.renderConfig.className);\n        }\n        wrapper.appendChild(resizerElem);\n        style.overflow = \"hidden\";\n        var svg = createNS(\"svg\");\n        svg.setAttribute(\"width\", \"1\");\n        svg.setAttribute(\"height\", \"1\");\n        styleDiv(svg);\n        this.resizerElem.appendChild(svg);\n        var defs = createNS(\"defs\");\n        svg.appendChild(defs);\n        this.data = animData; // Mask animation\n        this.setupGlobalData(animData, svg);\n        this.globalData.defs = defs;\n        this.layers = animData.layers;\n        this.layerElement = this.resizerElem;\n        this.build3dContainers();\n        this.updateContainerSize();\n    };\n    HybridRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = \"\";\n        }\n        this.animationItem.container = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    HybridRendererBase.prototype.updateContainerSize = function() {\n        var elementWidth = this.animationItem.wrapper.offsetWidth;\n        var elementHeight = this.animationItem.wrapper.offsetHeight;\n        var elementRel = elementWidth / elementHeight;\n        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;\n        var sx;\n        var sy;\n        var tx;\n        var ty;\n        if (animationRel > elementRel) {\n            sx = elementWidth / this.globalData.compSize.w;\n            sy = elementWidth / this.globalData.compSize.w;\n            tx = 0;\n            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;\n        } else {\n            sx = elementHeight / this.globalData.compSize.h;\n            sy = elementHeight / this.globalData.compSize.h;\n            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;\n            ty = 0;\n        }\n        var style = this.resizerElem.style;\n        style.webkitTransform = \"matrix3d(\" + sx + \",0,0,0,0,\" + sy + \",0,0,0,0,1,0,\" + tx + \",\" + ty + \",0,1)\";\n        style.transform = style.webkitTransform;\n    };\n    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\n    HybridRendererBase.prototype.hide = function() {\n        this.resizerElem.style.display = \"none\";\n    };\n    HybridRendererBase.prototype.show = function() {\n        this.resizerElem.style.display = \"block\";\n    };\n    HybridRendererBase.prototype.initItems = function() {\n        this.buildAllItems();\n        if (this.camera) {\n            this.camera.setup();\n        } else {\n            var cWidth = this.globalData.compSize.w;\n            var cHeight = this.globalData.compSize.h;\n            var i;\n            var len = this.threeDElements.length;\n            for(i = 0; i < len; i += 1){\n                var style = this.threeDElements[i].perspectiveElem.style;\n                style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + \"px\";\n                style.perspective = style.webkitPerspective;\n            }\n        }\n    };\n    HybridRendererBase.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        var floatingContainer = createTag(\"div\");\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    function HCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = !data.hasMask;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        HybridRendererBase,\n        ICompElement,\n        HBaseElement\n    ], HCompElement);\n    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\n    HCompElement.prototype.createContainerElements = function() {\n        this._createBaseContainerElements(); // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\n        if (this.data.hasMask) {\n            this.svgElement.setAttribute(\"width\", this.data.w);\n            this.svgElement.setAttribute(\"height\", this.data.h);\n            this.transformedElement = this.baseElement;\n        } else {\n            this.transformedElement = this.layerElement;\n        }\n    };\n    HCompElement.prototype.addTo3dContainer = function(elem, pos) {\n        var j = 0;\n        var nextElement;\n        while(j < pos){\n            if (this.elements[j] && this.elements[j].getBaseElement) {\n                nextElement = this.elements[j].getBaseElement();\n            }\n            j += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(elem, nextElement);\n        } else {\n            this.layerElement.appendChild(elem);\n        }\n    };\n    HCompElement.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    function HybridRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || \"\",\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || \"xMidYMid slice\",\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || \"400%\",\n                height: config && config.filterSize && config.filterSize.height || \"400%\",\n                x: config && config.filterSize && config.filterSize.x || \"-100%\",\n                y: config && config.filterSize && config.filterSize.y || \"-100%\"\n            },\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = \"html\";\n    }\n    extendPrototype([\n        HybridRendererBase\n    ], HybridRenderer);\n    HybridRenderer.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    var CompExpressionInterface = function() {\n        return function(comp) {\n            function _thisLayerFunction(name) {\n                var i = 0;\n                var len = comp.layers.length;\n                while(i < len){\n                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n                        return comp.elements[i].layerInterface;\n                    }\n                    i += 1;\n                }\n                return null; // return {active:false};\n            }\n            Object.defineProperty(_thisLayerFunction, \"_name\", {\n                value: comp.data.nm\n            });\n            _thisLayerFunction.layer = _thisLayerFunction;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\n            _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;\n            _thisLayerFunction.displayStartTime = 0;\n            _thisLayerFunction.numLayers = comp.layers.length;\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof$2(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$2 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$2 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$2(obj);\n    }\n    /* eslint-disable */ /*\r\n   Copyright 2014 David Bau.\r\n\r\n   Permission is hereby granted, free of charge, to any person obtaining\r\n   a copy of this software and associated documentation files (the\r\n   \"Software\"), to deal in the Software without restriction, including\r\n   without limitation the rights to use, copy, modify, merge, publish,\r\n   distribute, sublicense, and/or sell copies of the Software, and to\r\n   permit persons to whom the Software is furnished to do so, subject to\r\n   the following conditions:\r\n\r\n   The above copyright notice and this permission notice shall be\r\n   included in all copies or substantial portions of the Software.\r\n\r\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n   */ function seedRandom(pool, math) {\n        //\n        // The following constants are related to IEEE 754 limits.\n        //\n        var global = this, width = 256, // each RC4 output is 0 <= x < 256\n        chunks = 6, // at least six RC4 outputs for each double\n        digits = 52, // there are 52 significant digits in a double\n        rngname = \"random\", // rngname: name for Math.random and Math.seedrandom\n        startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.\n        //\n        // seedrandom()\n        // This is the seedrandom function described above.\n        //\n        function seedrandom(seed, options, callback) {\n            var key = [];\n            options = options === true ? {\n                entropy: true\n            } : options || {}; // Flatten the seed string or build one from local entropy if needed.\n            var shortseed = mixkey(flatten(options.entropy ? [\n                seed,\n                tostring(pool)\n            ] : seed === null ? autoseed() : seed, 3), key); // Use the seed to initialize an ARC4 generator.\n            var arc4 = new ARC4(key); // This function returns a random double in [0, 1) that contains\n            // randomness in every bit of the mantissa of the IEEE 754 value.\n            var prng = function prng() {\n                var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48\n                d = startdenom, //   and denominator d = 2 ^ 48.\n                x = 0; //   and no 'extra last byte'.\n                while(n < significance){\n                    // Fill up all significant digits by\n                    n = (n + x) * width; //   shifting numerator and\n                    d *= width; //   denominator and generating a\n                    x = arc4.g(1); //   new least-significant-byte.\n                }\n                while(n >= overflow){\n                    // To avoid rounding up, before adding\n                    n /= 2; //   last byte, shift everything\n                    d /= 2; //   right using integer math until\n                    x >>>= 1; //   we have exactly the desired bits.\n                }\n                return (n + x) / d; // Form the number within [0, 1).\n            };\n            prng.int32 = function() {\n                return arc4.g(4) | 0;\n            };\n            prng.quick = function() {\n                return arc4.g(4) / 0x100000000;\n            };\n            prng[\"double\"] = prng; // Mix the randomness into accumulated entropy.\n            mixkey(tostring(arc4.S), pool); // Calling convention: what to return as a function of prng, seed, is_math.\n            return (options.pass || callback || function(prng, seed, is_math_call, state) {\n                if (state) {\n                    // Load the arc4 state from the given state if it has an S array.\n                    if (state.S) {\n                        copy(state, arc4);\n                    } // Only provide the .state method if requested via options.state.\n                    prng.state = function() {\n                        return copy(arc4, {});\n                    };\n                } // If called as a method of Math (Math.seedrandom()), mutate\n                // Math.random because that is how seedrandom.js has worked since v1.0.\n                if (is_math_call) {\n                    math[rngname] = prng;\n                    return seed;\n                } else return prng;\n            })(prng, shortseed, \"global\" in options ? options.global : this == math, options.state);\n        }\n        math[\"seed\" + rngname] = seedrandom; //\n        // ARC4\n        //\n        // An ARC4 implementation.  The constructor takes a key in the form of\n        // an array of at most (width) integers that should be 0 <= x < (width).\n        //\n        // The g(count) method returns a pseudorandom integer that concatenates\n        // the next (count) outputs from ARC4.  Its return value is a number x\n        // that is in the range 0 <= x < (width ^ count).\n        //\n        function ARC4(key) {\n            var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = []; // The empty key [] is treated as [0].\n            if (!keylen) {\n                key = [\n                    keylen++\n                ];\n            } // Set up S using the standard key scheduling algorithm.\n            while(i < width){\n                s[i] = i++;\n            }\n            for(i = 0; i < width; i++){\n                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n                s[j] = t;\n            } // The \"g\" method returns the next (count) outputs as one number.\n            me.g = function(count) {\n                // Using instance members instead of closure state nearly doubles speed.\n                var t, r = 0, i = me.i, j = me.j, s = me.S;\n                while(count--){\n                    t = s[i = mask & i + 1];\n                    r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n                }\n                me.i = i;\n                me.j = j;\n                return r; // For robust unpredictability, the function call below automatically\n            // discards an initial batch of values.  This is called RC4-drop[256].\n            // See http://google.com/search?q=rsa+fluhrer+response&btnI\n            };\n        } //\n        // copy()\n        // Copies internal state of ARC4 to or from a plain object.\n        //\n        function copy(f, t) {\n            t.i = f.i;\n            t.j = f.j;\n            t.S = f.S.slice();\n            return t;\n        } //\n        // flatten()\n        // Converts an object tree to nested arrays of strings.\n        //\n        function flatten(obj, depth) {\n            var result = [], typ = _typeof$2(obj), prop;\n            if (depth && typ == \"object\") {\n                for(prop in obj){\n                    try {\n                        result.push(flatten(obj[prop], depth - 1));\n                    } catch (e) {}\n                }\n            }\n            return result.length ? result : typ == \"string\" ? obj : obj + \"\\x00\";\n        } //\n        // mixkey()\n        // Mixes a string seed into a key that is an array of integers, and\n        // returns a shortened string seed that is equivalent to the result key.\n        //\n        function mixkey(seed, key) {\n            var stringseed = seed + \"\", smear, j = 0;\n            while(j < stringseed.length){\n                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n            }\n            return tostring(key);\n        } //\n        // autoseed()\n        // Returns an object for autoseeding, using window.crypto and Node crypto\n        // module if available.\n        //\n        function autoseed() {\n            try {\n                if (nodecrypto) {\n                    return tostring(nodecrypto.randomBytes(width));\n                }\n                var out = new Uint8Array(width);\n                (global.crypto || global.msCrypto).getRandomValues(out);\n                return tostring(out);\n            } catch (e) {\n                var browser = global.navigator, plugins = browser && browser.plugins;\n                return [\n                    +new Date(),\n                    global,\n                    plugins,\n                    global.screen,\n                    tostring(pool)\n                ];\n            }\n        } //\n        // tostring()\n        // Converts an array of charcodes to a string\n        //\n        function tostring(a) {\n            return String.fromCharCode.apply(0, a);\n        } //\n        // When seedrandom.js is loaded, we immediately mix a few bits\n        // from the built-in RNG into the entropy pool.  Because we do\n        // not want to interfere with deterministic PRNG state later,\n        // seedrandom will not call math.random on its own again after\n        // initialization.\n        //\n        mixkey(math.random(), pool); //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    // End anonymous scope, and pass initial values.\n    }\n    ;\n    function initialize$2(BMMath) {\n        seedRandom([], BMMath);\n    }\n    var propTypes = {\n        SHAPE: \"shape\"\n    };\n    function _typeof$1(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof$1 = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof$1 = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof$1(obj);\n    }\n    var ExpressionManager = function() {\n        \"use strict\";\n        var ob = {};\n        var Math = BMMath;\n        var window = null;\n        var document = null;\n        var XMLHttpRequest = null;\n        var fetch = null;\n        var frames = null;\n        var _lottieGlobal = {};\n        initialize$2(BMMath);\n        function resetFrame() {\n            _lottieGlobal = {};\n        }\n        function $bm_isInstanceOfArray(arr) {\n            return arr.constructor === Array || arr.constructor === Float32Array;\n        }\n        function isNumerable(tOfV, v) {\n            return tOfV === \"number\" || v instanceof Number || tOfV === \"boolean\" || tOfV === \"string\";\n        }\n        function $bm_neg(a) {\n            var tOfA = _typeof$1(a);\n            if (tOfA === \"number\" || a instanceof Number || tOfA === \"boolean\") {\n                return -a;\n            }\n            if ($bm_isInstanceOfArray(a)) {\n                var i;\n                var lenA = a.length;\n                var retArr = [];\n                for(i = 0; i < lenA; i += 1){\n                    retArr[i] = -a[i];\n                }\n                return retArr;\n            }\n            if (a.propType) {\n                return a.v;\n            }\n            return -a;\n        }\n        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, \"easeIn\").get;\n        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, \"easeOut\").get;\n        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, \"easeInOut\").get;\n        function sum(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === \"string\" || tOfB === \"string\") {\n                return a + b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] += b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a + b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === \"number\" || a[i] instanceof Number) && (typeof b[i] === \"number\" || b[i] instanceof Number)) {\n                        retArr[i] = a[i] + b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        var add = sum;\n        function sub(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                if (tOfA === \"string\") {\n                    a = parseInt(a, 10);\n                }\n                if (tOfB === \"string\") {\n                    b = parseInt(b, 10);\n                }\n                return a - b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] -= b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a - b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === \"number\" || a[i] instanceof Number) && (typeof b[i] === \"number\" || b[i] instanceof Number)) {\n                        retArr[i] = a[i] - b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        function mul(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a * b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] * b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a * b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function div(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a / b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] / b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray(\"float32\", len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a / b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function mod(a, b) {\n            if (typeof a === \"string\") {\n                a = parseInt(a, 10);\n            }\n            if (typeof b === \"string\") {\n                b = parseInt(b, 10);\n            }\n            return a % b;\n        }\n        var $bm_sum = sum;\n        var $bm_sub = sub;\n        var $bm_mul = mul;\n        var $bm_div = div;\n        var $bm_mod = mod;\n        function clamp(num, min, max) {\n            if (min > max) {\n                var mm = max;\n                max = min;\n                min = mm;\n            }\n            return Math.min(Math.max(num, min), max);\n        }\n        function radiansToDegrees(val) {\n            return val / degToRads;\n        }\n        var radians_to_degrees = radiansToDegrees;\n        function degreesToRadians(val) {\n            return val * degToRads;\n        }\n        var degrees_to_radians = radiansToDegrees;\n        var helperLengthArray = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        function length(arr1, arr2) {\n            if (typeof arr1 === \"number\" || arr1 instanceof Number) {\n                arr2 = arr2 || 0;\n                return Math.abs(arr1 - arr2);\n            }\n            if (!arr2) {\n                arr2 = helperLengthArray;\n            }\n            var i;\n            var len = Math.min(arr1.length, arr2.length);\n            var addedLength = 0;\n            for(i = 0; i < len; i += 1){\n                addedLength += Math.pow(arr2[i] - arr1[i], 2);\n            }\n            return Math.sqrt(addedLength);\n        }\n        function normalize(vec) {\n            return div(vec, length(vec));\n        }\n        function rgbToHsl(val) {\n            var r = val[0];\n            var g = val[1];\n            var b = val[2];\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var h;\n            var s;\n            var l = (max + min) / 2;\n            if (max === min) {\n                h = 0; // achromatic\n                s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                    default:\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                h,\n                s,\n                l,\n                val[3]\n            ];\n        }\n        function hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        function hslToRgb(val) {\n            var h = val[0];\n            var s = val[1];\n            var l = val[2];\n            var r;\n            var g;\n            var b;\n            if (s === 0) {\n                r = l; // achromatic\n                b = l; // achromatic\n                g = l; // achromatic\n            } else {\n                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                var p = 2 * l - q;\n                r = hue2rgb(p, q, h + 1 / 3);\n                g = hue2rgb(p, q, h);\n                b = hue2rgb(p, q, h - 1 / 3);\n            }\n            return [\n                r,\n                g,\n                b,\n                val[3]\n            ];\n        }\n        function linear(t, tMin, tMax, value1, value2) {\n            if (value1 === undefined || value2 === undefined) {\n                value1 = tMin;\n                value2 = tMax;\n                tMin = 0;\n                tMax = 1;\n            }\n            if (tMax < tMin) {\n                var _tMin = tMax;\n                tMax = tMin;\n                tMin = _tMin;\n            }\n            if (t <= tMin) {\n                return value1;\n            }\n            if (t >= tMax) {\n                return value2;\n            }\n            var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);\n            if (!value1.length) {\n                return value1 + (value2 - value1) * perc;\n            }\n            var i;\n            var len = value1.length;\n            var arr = createTypedArray(\"float32\", len);\n            for(i = 0; i < len; i += 1){\n                arr[i] = value1[i] + (value2[i] - value1[i]) * perc;\n            }\n            return arr;\n        }\n        function random(min, max) {\n            if (max === undefined) {\n                if (min === undefined) {\n                    min = 0;\n                    max = 1;\n                } else {\n                    max = min;\n                    min = undefined;\n                }\n            }\n            if (max.length) {\n                var i;\n                var len = max.length;\n                if (!min) {\n                    min = createTypedArray(\"float32\", len);\n                }\n                var arr = createTypedArray(\"float32\", len);\n                var rnd = BMMath.random();\n                for(i = 0; i < len; i += 1){\n                    arr[i] = min[i] + rnd * (max[i] - min[i]);\n                }\n                return arr;\n            }\n            if (min === undefined) {\n                min = 0;\n            }\n            var rndm = BMMath.random();\n            return min + rndm * (max - min);\n        }\n        function createPath(points, inTangents, outTangents, closed) {\n            var i;\n            var len = points.length;\n            var path = shapePool.newElement();\n            path.setPathData(!!closed, len);\n            var arrPlaceholder = [\n                0,\n                0\n            ];\n            var inVertexPoint;\n            var outVertexPoint;\n            for(i = 0; i < len; i += 1){\n                inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;\n                outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;\n                path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);\n            }\n            return path;\n        }\n        function initiateExpression(elem, data, property) {\n            // Bail out if we don't want expressions\n            function noOp(_value) {\n                return _value;\n            }\n            if (!elem.globalData.renderConfig.runExpressions) {\n                return noOp;\n            }\n            var val = data.x;\n            var needsVelocity = /velocity(?![\\w\\d])/.test(val);\n            var _needsRandom = val.indexOf(\"random\") !== -1;\n            var elemType = elem.data.ty;\n            var transform;\n            var $bm_transform;\n            var content;\n            var effect;\n            var thisProperty = property;\n            thisProperty.valueAtTime = thisProperty.getValueAtTime;\n            Object.defineProperty(thisProperty, \"value\", {\n                get: function get() {\n                    return thisProperty.v;\n                }\n            });\n            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;\n            elem.comp.displayStartTime = 0;\n            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            var outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            var width = elem.data.sw ? elem.data.sw : 0;\n            var height = elem.data.sh ? elem.data.sh : 0;\n            var name = elem.data.nm;\n            var loopIn;\n            var loop_in;\n            var loopOut;\n            var loop_out;\n            var smooth;\n            var toWorld;\n            var fromWorld;\n            var fromComp;\n            var toComp;\n            var fromCompToSurface;\n            var position;\n            var rotation;\n            var anchorPoint;\n            var scale;\n            var thisLayer;\n            var thisComp;\n            var mask;\n            var valueAtTime;\n            var velocityAtTime;\n            var scoped_bm_rt; // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n            var expression_function = eval(\"[function _expression_function(){\" + val + \";scoped_bm_rt=$bm_rt}]\")[0]; // eslint-disable-line no-eval\n            var numKeys = property.kf ? data.k.length : 0;\n            var active = !this.data || this.data.hd !== true;\n            var wiggle = (function wiggle(freq, amp) {\n                var iWiggle;\n                var j;\n                var lenWiggle = this.pv.length ? this.pv.length : 1;\n                var addedAmps = createTypedArray(\"float32\", lenWiggle);\n                freq = 5;\n                var iterations = Math.floor(time * freq);\n                iWiggle = 0;\n                j = 0;\n                while(iWiggle < iterations){\n                    // var rnd = BMMath.random();\n                    for(j = 0; j < lenWiggle; j += 1){\n                        addedAmps[j] += -amp + amp * 2 * BMMath.random(); // addedAmps[j] += -amp + amp*2*rnd;\n                    }\n                    iWiggle += 1;\n                } // var rnd2 = BMMath.random();\n                var periods = time * freq;\n                var perc = periods - Math.floor(periods);\n                var arr = createTypedArray(\"float32\", lenWiggle);\n                if (lenWiggle > 1) {\n                    for(j = 0; j < lenWiggle; j += 1){\n                        arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc; // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n                    // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n                    }\n                    return arr;\n                }\n                return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;\n            }).bind(this);\n            if (thisProperty.loopIn) {\n                loopIn = thisProperty.loopIn.bind(thisProperty);\n                loop_in = loopIn;\n            }\n            if (thisProperty.loopOut) {\n                loopOut = thisProperty.loopOut.bind(thisProperty);\n                loop_out = loopOut;\n            }\n            if (thisProperty.smooth) {\n                smooth = thisProperty.smooth.bind(thisProperty);\n            }\n            function loopInDuration(type, duration) {\n                return loopIn(type, duration, true);\n            }\n            function loopOutDuration(type, duration) {\n                return loopOut(type, duration, true);\n            }\n            if (this.getValueAtTime) {\n                valueAtTime = this.getValueAtTime.bind(this);\n            }\n            if (this.getVelocityAtTime) {\n                velocityAtTime = this.getVelocityAtTime.bind(this);\n            }\n            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\n            function lookAt(elem1, elem2) {\n                var fVec = [\n                    elem2[0] - elem1[0],\n                    elem2[1] - elem1[1],\n                    elem2[2] - elem1[2]\n                ];\n                var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;\n                var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;\n                return [\n                    yaw,\n                    pitch,\n                    0\n                ];\n            }\n            function easeOut(t, tMin, tMax, val1, val2) {\n                return applyEase(easeOutBez, t, tMin, tMax, val1, val2);\n            }\n            function easeIn(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInBez, t, tMin, tMax, val1, val2);\n            }\n            function ease(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);\n            }\n            function applyEase(fn, t, tMin, tMax, val1, val2) {\n                if (val1 === undefined) {\n                    val1 = tMin;\n                    val2 = tMax;\n                } else {\n                    t = (t - tMin) / (tMax - tMin);\n                }\n                if (t > 1) {\n                    t = 1;\n                } else if (t < 0) {\n                    t = 0;\n                }\n                var mult = fn(t);\n                if ($bm_isInstanceOfArray(val1)) {\n                    var iKey;\n                    var lenKey = val1.length;\n                    var arr = createTypedArray(\"float32\", lenKey);\n                    for(iKey = 0; iKey < lenKey; iKey += 1){\n                        arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];\n                    }\n                    return arr;\n                }\n                return (val2 - val1) * mult + val1;\n            }\n            function nearestKey(time) {\n                var iKey;\n                var lenKey = data.k.length;\n                var index;\n                var keyTime;\n                if (!data.k.length || typeof data.k[0] === \"number\") {\n                    index = 0;\n                    keyTime = 0;\n                } else {\n                    index = -1;\n                    time *= elem.comp.globalData.frameRate;\n                    if (time < data.k[0].t) {\n                        index = 1;\n                        keyTime = data.k[0].t;\n                    } else {\n                        for(iKey = 0; iKey < lenKey - 1; iKey += 1){\n                            if (time === data.k[iKey].t) {\n                                index = iKey + 1;\n                                keyTime = data.k[iKey].t;\n                                break;\n                            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                                    index = iKey + 2;\n                                    keyTime = data.k[iKey + 1].t;\n                                } else {\n                                    index = iKey + 1;\n                                    keyTime = data.k[iKey].t;\n                                }\n                                break;\n                            }\n                        }\n                        if (index === -1) {\n                            index = iKey + 1;\n                            keyTime = data.k[iKey].t;\n                        }\n                    }\n                }\n                var obKey = {};\n                obKey.index = index;\n                obKey.time = keyTime / elem.comp.globalData.frameRate;\n                return obKey;\n            }\n            function key(ind) {\n                var obKey;\n                var iKey;\n                var lenKey;\n                if (!data.k.length || typeof data.k[0] === \"number\") {\n                    throw new Error(\"The property has no keyframe at index \" + ind);\n                }\n                ind -= 1;\n                obKey = {\n                    time: data.k[ind].t / elem.comp.globalData.frameRate,\n                    value: []\n                };\n                var arr = Object.prototype.hasOwnProperty.call(data.k[ind], \"s\") ? data.k[ind].s : data.k[ind - 1].e;\n                lenKey = arr.length;\n                for(iKey = 0; iKey < lenKey; iKey += 1){\n                    obKey[iKey] = arr[iKey];\n                    obKey.value[iKey] = arr[iKey];\n                }\n                return obKey;\n            }\n            function framesToTime(fr, fps) {\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return fr / fps;\n            }\n            function timeToFrames(t, fps) {\n                if (!t && t !== 0) {\n                    t = time;\n                }\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return t * fps;\n            }\n            function seedRandom(seed) {\n                BMMath.seedrandom(randSeed + seed);\n            }\n            function sourceRectAtTime() {\n                return elem.sourceRectAtTime();\n            }\n            function substring(init, end) {\n                if (typeof value === \"string\") {\n                    if (end === undefined) {\n                        return value.substring(init);\n                    }\n                    return value.substring(init, end);\n                }\n                return \"\";\n            }\n            function substr(init, end) {\n                if (typeof value === \"string\") {\n                    if (end === undefined) {\n                        return value.substr(init);\n                    }\n                    return value.substr(init, end);\n                }\n                return \"\";\n            }\n            function posterizeTime(framesPerSecond) {\n                time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;\n                value = valueAtTime(time);\n            }\n            var time;\n            var velocity;\n            var value;\n            var text;\n            var textIndex;\n            var textTotal;\n            var selectorValue;\n            var index = elem.data.ind;\n            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n            var parent;\n            var randSeed = Math.floor(Math.random() * 1000000);\n            var globalData = elem.globalData;\n            function executeExpression(_value) {\n                // globalData.pushExpression();\n                value = _value;\n                if (this.frameExpressionId === elem.globalData.frameId && this.propType !== \"textSelector\") {\n                    return value;\n                }\n                if (this.propType === \"textSelector\") {\n                    textIndex = this.textIndex;\n                    textTotal = this.textTotal;\n                    selectorValue = this.selectorValue;\n                }\n                if (!thisLayer) {\n                    text = elem.layerInterface.text;\n                    thisLayer = elem.layerInterface;\n                    thisComp = elem.comp.compInterface;\n                    toWorld = thisLayer.toWorld.bind(thisLayer);\n                    fromWorld = thisLayer.fromWorld.bind(thisLayer);\n                    fromComp = thisLayer.fromComp.bind(thisLayer);\n                    toComp = thisLayer.toComp.bind(thisLayer);\n                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\n                    fromCompToSurface = fromComp;\n                }\n                if (!transform) {\n                    transform = elem.layerInterface(\"ADBE Transform Group\");\n                    $bm_transform = transform;\n                    if (transform) {\n                        anchorPoint = transform.anchorPoint;\n                    /* position = transform.position;\r\n                      rotation = transform.rotation;\r\n                      scale = transform.scale; */ }\n                }\n                if (elemType === 4 && !content) {\n                    content = thisLayer(\"ADBE Root Vectors Group\");\n                }\n                if (!effect) {\n                    effect = thisLayer(4);\n                }\n                hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n                if (hasParent && !parent) {\n                    parent = elem.hierarchy[0].layerInterface;\n                }\n                time = this.comp.renderedFrame / this.comp.globalData.frameRate;\n                if (_needsRandom) {\n                    seedRandom(randSeed + time);\n                }\n                if (needsVelocity) {\n                    velocity = velocityAtTime(time);\n                }\n                expression_function();\n                this.frameExpressionId = elem.globalData.frameId; // TODO: Check if it's possible to return on ShapeInterface the .v value\n                // Changed this to a ternary operation because Rollup failed compiling it correctly\n                scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;\n                return scoped_bm_rt;\n            } // Bundlers will see these as dead code and unless we reference them\n            executeExpression.__preventDeadCodeRemoval = [\n                $bm_transform,\n                anchorPoint,\n                time,\n                velocity,\n                inPoint,\n                outPoint,\n                width,\n                height,\n                name,\n                loop_in,\n                loop_out,\n                smooth,\n                toComp,\n                fromCompToSurface,\n                toWorld,\n                fromWorld,\n                mask,\n                position,\n                rotation,\n                scale,\n                thisComp,\n                numKeys,\n                active,\n                wiggle,\n                loopInDuration,\n                loopOutDuration,\n                comp,\n                lookAt,\n                easeOut,\n                easeIn,\n                ease,\n                nearestKey,\n                key,\n                text,\n                textIndex,\n                textTotal,\n                selectorValue,\n                framesToTime,\n                timeToFrames,\n                sourceRectAtTime,\n                substring,\n                substr,\n                posterizeTime,\n                index,\n                globalData\n            ];\n            return executeExpression;\n        }\n        ob.initiateExpression = initiateExpression;\n        ob.__preventDeadCodeRemoval = [\n            window,\n            document,\n            XMLHttpRequest,\n            fetch,\n            frames,\n            $bm_neg,\n            add,\n            $bm_sum,\n            $bm_sub,\n            $bm_mul,\n            $bm_div,\n            $bm_mod,\n            clamp,\n            radians_to_degrees,\n            degreesToRadians,\n            degrees_to_radians,\n            normalize,\n            rgbToHsl,\n            hslToRgb,\n            linear,\n            random,\n            createPath,\n            _lottieGlobal\n        ];\n        ob.resetFrame = resetFrame;\n        return ob;\n    }();\n    var Expressions = function() {\n        var ob = {};\n        ob.initExpressions = initExpressions;\n        ob.resetFrame = ExpressionManager.resetFrame;\n        function initExpressions(animation) {\n            var stackCount = 0;\n            var registers = [];\n            function pushExpression() {\n                stackCount += 1;\n            }\n            function popExpression() {\n                stackCount -= 1;\n                if (stackCount === 0) {\n                    releaseInstances();\n                }\n            }\n            function registerExpressionProperty(expression) {\n                if (registers.indexOf(expression) === -1) {\n                    registers.push(expression);\n                }\n            }\n            function releaseInstances() {\n                var i;\n                var len = registers.length;\n                for(i = 0; i < len; i += 1){\n                    registers[i].release();\n                }\n                registers.length = 0;\n            }\n            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\n            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\n            animation.renderer.globalData.pushExpression = pushExpression;\n            animation.renderer.globalData.popExpression = popExpression;\n            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;\n        }\n        return ob;\n    }();\n    var MaskManagerInterface = function() {\n        function MaskInterface(mask, data) {\n            this._mask = mask;\n            this._data = data;\n        }\n        Object.defineProperty(MaskInterface.prototype, \"maskPath\", {\n            get: function get() {\n                if (this._mask.prop.k) {\n                    this._mask.prop.getValue();\n                }\n                return this._mask.prop;\n            }\n        });\n        Object.defineProperty(MaskInterface.prototype, \"maskOpacity\", {\n            get: function get() {\n                if (this._mask.op.k) {\n                    this._mask.op.getValue();\n                }\n                return this._mask.op.v * 100;\n            }\n        });\n        var MaskManager = function MaskManager(maskManager) {\n            var _masksInterfaces = createSizedArray(maskManager.viewData.length);\n            var i;\n            var len = maskManager.viewData.length;\n            for(i = 0; i < len; i += 1){\n                _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\n            }\n            var maskFunction = function maskFunction(name) {\n                i = 0;\n                while(i < len){\n                    if (maskManager.masksProperties[i].nm === name) {\n                        return _masksInterfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            };\n            return maskFunction;\n        };\n        return MaskManager;\n    }();\n    var ExpressionPropertyInterface = function() {\n        var defaultUnidimensionalValue = {\n            pv: 0,\n            v: 0,\n            mult: 1\n        };\n        var defaultMultidimensionalValue = {\n            pv: [\n                0,\n                0,\n                0\n            ],\n            v: [\n                0,\n                0,\n                0\n            ],\n            mult: 1\n        };\n        function completeProperty(expressionValue, property, type) {\n            Object.defineProperty(expressionValue, \"velocity\", {\n                get: function get() {\n                    return property.getVelocityAtTime(property.comp.currentFrame);\n                }\n            });\n            expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;\n            expressionValue.key = function(pos) {\n                if (!expressionValue.numKeys) {\n                    return 0;\n                }\n                var value = \"\";\n                if (\"s\" in property.keyframes[pos - 1]) {\n                    value = property.keyframes[pos - 1].s;\n                } else if (\"e\" in property.keyframes[pos - 2]) {\n                    value = property.keyframes[pos - 2].e;\n                } else {\n                    value = property.keyframes[pos - 2].s;\n                }\n                var valueProp = type === \"unidimensional\" ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers\n                valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;\n                valueProp.value = type === \"unidimensional\" ? value[0] : value;\n                return valueProp;\n            };\n            expressionValue.valueAtTime = property.getValueAtTime;\n            expressionValue.speedAtTime = property.getSpeedAtTime;\n            expressionValue.velocityAtTime = property.getVelocityAtTime;\n            expressionValue.propertyGroup = property.propertyGroup;\n        }\n        function UnidimensionalPropertyInterface(property) {\n            if (!property || !(\"pv\" in property)) {\n                property = defaultUnidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var val = property.pv * mult;\n            var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n            expressionValue.value = val;\n            completeProperty(expressionValue, property, \"unidimensional\");\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                val = property.v * mult;\n                if (expressionValue.value !== val) {\n                    expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n                    expressionValue.value = val;\n                    completeProperty(expressionValue, property, \"unidimensional\");\n                }\n                return expressionValue;\n            };\n        }\n        function MultidimensionalPropertyInterface(property) {\n            if (!property || !(\"pv\" in property)) {\n                property = defaultMultidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var len = property.data && property.data.l || property.pv.length;\n            var expressionValue = createTypedArray(\"float32\", len);\n            var arrValue = createTypedArray(\"float32\", len);\n            expressionValue.value = arrValue;\n            completeProperty(expressionValue, property, \"multidimensional\");\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                for(var i = 0; i < len; i += 1){\n                    arrValue[i] = property.v[i] * mult;\n                    expressionValue[i] = arrValue[i];\n                }\n                return expressionValue;\n            };\n        } // TODO: try to avoid using this getter\n        function defaultGetter() {\n            return defaultUnidimensionalValue;\n        }\n        return function(property) {\n            if (!property) {\n                return defaultGetter;\n            }\n            if (property.propType === \"unidimensional\") {\n                return UnidimensionalPropertyInterface(property);\n            }\n            return MultidimensionalPropertyInterface(property);\n        };\n    }();\n    var TransformExpressionInterface = function() {\n        return function(transform) {\n            function _thisFunction(name) {\n                switch(name){\n                    case \"scale\":\n                    case \"Scale\":\n                    case \"ADBE Scale\":\n                    case 6:\n                        return _thisFunction.scale;\n                    case \"rotation\":\n                    case \"Rotation\":\n                    case \"ADBE Rotation\":\n                    case \"ADBE Rotate Z\":\n                    case 10:\n                        return _thisFunction.rotation;\n                    case \"ADBE Rotate X\":\n                        return _thisFunction.xRotation;\n                    case \"ADBE Rotate Y\":\n                        return _thisFunction.yRotation;\n                    case \"position\":\n                    case \"Position\":\n                    case \"ADBE Position\":\n                    case 2:\n                        return _thisFunction.position;\n                    case \"ADBE Position_0\":\n                        return _thisFunction.xPosition;\n                    case \"ADBE Position_1\":\n                        return _thisFunction.yPosition;\n                    case \"ADBE Position_2\":\n                        return _thisFunction.zPosition;\n                    case \"anchorPoint\":\n                    case \"AnchorPoint\":\n                    case \"Anchor Point\":\n                    case \"ADBE AnchorPoint\":\n                    case 1:\n                        return _thisFunction.anchorPoint;\n                    case \"opacity\":\n                    case \"Opacity\":\n                    case 11:\n                        return _thisFunction.opacity;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisFunction, \"rotation\", {\n                get: ExpressionPropertyInterface(transform.r || transform.rz)\n            });\n            Object.defineProperty(_thisFunction, \"zRotation\", {\n                get: ExpressionPropertyInterface(transform.rz || transform.r)\n            });\n            Object.defineProperty(_thisFunction, \"xRotation\", {\n                get: ExpressionPropertyInterface(transform.rx)\n            });\n            Object.defineProperty(_thisFunction, \"yRotation\", {\n                get: ExpressionPropertyInterface(transform.ry)\n            });\n            Object.defineProperty(_thisFunction, \"scale\", {\n                get: ExpressionPropertyInterface(transform.s)\n            });\n            var _px;\n            var _py;\n            var _pz;\n            var _transformFactory;\n            if (transform.p) {\n                _transformFactory = ExpressionPropertyInterface(transform.p);\n            } else {\n                _px = ExpressionPropertyInterface(transform.px);\n                _py = ExpressionPropertyInterface(transform.py);\n                if (transform.pz) {\n                    _pz = ExpressionPropertyInterface(transform.pz);\n                }\n            }\n            Object.defineProperty(_thisFunction, \"position\", {\n                get: function get() {\n                    if (transform.p) {\n                        return _transformFactory();\n                    }\n                    return [\n                        _px(),\n                        _py(),\n                        _pz ? _pz() : 0\n                    ];\n                }\n            });\n            Object.defineProperty(_thisFunction, \"xPosition\", {\n                get: ExpressionPropertyInterface(transform.px)\n            });\n            Object.defineProperty(_thisFunction, \"yPosition\", {\n                get: ExpressionPropertyInterface(transform.py)\n            });\n            Object.defineProperty(_thisFunction, \"zPosition\", {\n                get: ExpressionPropertyInterface(transform.pz)\n            });\n            Object.defineProperty(_thisFunction, \"anchorPoint\", {\n                get: ExpressionPropertyInterface(transform.a)\n            });\n            Object.defineProperty(_thisFunction, \"opacity\", {\n                get: ExpressionPropertyInterface(transform.o)\n            });\n            Object.defineProperty(_thisFunction, \"skew\", {\n                get: ExpressionPropertyInterface(transform.sk)\n            });\n            Object.defineProperty(_thisFunction, \"skewAxis\", {\n                get: ExpressionPropertyInterface(transform.sa)\n            });\n            Object.defineProperty(_thisFunction, \"orientation\", {\n                get: ExpressionPropertyInterface(transform.or)\n            });\n            return _thisFunction;\n        };\n    }();\n    var LayerExpressionInterface = function() {\n        function getMatrix(time) {\n            var toWorldMat = new Matrix();\n            if (time !== undefined) {\n                var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);\n                propMatrix.clone(toWorldMat);\n            } else {\n                var transformMat = this._elem.finalTransform.mProp;\n                transformMat.applyToMatrix(toWorldMat);\n            }\n            return toWorldMat;\n        }\n        function toWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function toWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function fromWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function fromWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function applyPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);\n        }\n        function invertPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.inversePoint(arr);\n        }\n        function fromComp(arr) {\n            var toWorldMat = new Matrix();\n            toWorldMat.reset();\n            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\n                }\n                return toWorldMat.inversePoint(arr);\n            }\n            return toWorldMat.inversePoint(arr);\n        }\n        function sampleImage() {\n            return [\n                1,\n                1,\n                1,\n                1\n            ];\n        }\n        return function(elem) {\n            var transformInterface;\n            function _registerMaskInterface(maskManager) {\n                _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\n            }\n            function _registerEffectsInterface(effects) {\n                _thisLayerFunction.effect = effects;\n            }\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case \"ADBE Root Vectors Group\":\n                    case \"Contents\":\n                    case 2:\n                        return _thisLayerFunction.shapeInterface;\n                    case 1:\n                    case 6:\n                    case \"Transform\":\n                    case \"transform\":\n                    case \"ADBE Transform Group\":\n                        return transformInterface;\n                    case 4:\n                    case \"ADBE Effect Parade\":\n                    case \"effects\":\n                    case \"Effects\":\n                        return _thisLayerFunction.effect;\n                    case \"ADBE Text Properties\":\n                        return _thisLayerFunction.textInterface;\n                    default:\n                        return null;\n                }\n            }\n            _thisLayerFunction.getMatrix = getMatrix;\n            _thisLayerFunction.invertPoint = invertPoint;\n            _thisLayerFunction.applyPoint = applyPoint;\n            _thisLayerFunction.toWorld = toWorld;\n            _thisLayerFunction.toWorldVec = toWorldVec;\n            _thisLayerFunction.fromWorld = fromWorld;\n            _thisLayerFunction.fromWorldVec = fromWorldVec;\n            _thisLayerFunction.toComp = toWorld;\n            _thisLayerFunction.fromComp = fromComp;\n            _thisLayerFunction.sampleImage = sampleImage;\n            _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\n            _thisLayerFunction._elem = elem;\n            transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\n            var anchorPointDescriptor = getDescriptor(transformInterface, \"anchorPoint\");\n            Object.defineProperties(_thisLayerFunction, {\n                hasParent: {\n                    get: function get() {\n                        return elem.hierarchy.length;\n                    }\n                },\n                parent: {\n                    get: function get() {\n                        return elem.hierarchy[0].layerInterface;\n                    }\n                },\n                rotation: getDescriptor(transformInterface, \"rotation\"),\n                scale: getDescriptor(transformInterface, \"scale\"),\n                position: getDescriptor(transformInterface, \"position\"),\n                opacity: getDescriptor(transformInterface, \"opacity\"),\n                anchorPoint: anchorPointDescriptor,\n                anchor_point: anchorPointDescriptor,\n                transform: {\n                    get: function get() {\n                        return transformInterface;\n                    }\n                },\n                active: {\n                    get: function get() {\n                        return elem.isInRange;\n                    }\n                }\n            });\n            _thisLayerFunction.startTime = elem.data.st;\n            _thisLayerFunction.index = elem.data.ind;\n            _thisLayerFunction.source = elem.data.refId;\n            _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\n            _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\n            _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            _thisLayerFunction._name = elem.data.nm;\n            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\n            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\n            return _thisLayerFunction;\n        };\n    }();\n    var propertyGroupFactory = function() {\n        return function(interfaceFunction, parentPropertyGroup) {\n            return function(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return parentPropertyGroup(val - 1);\n            };\n        };\n    }();\n    var PropertyInterface = function() {\n        return function(propertyName, propertyGroup) {\n            var interfaceFunction = {\n                _name: propertyName\n            };\n            function _propertyGroup(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return propertyGroup(val - 1);\n            }\n            return _propertyGroup;\n        };\n    }();\n    var EffectsExpressionInterface = function() {\n        var ob = {\n            createEffectsInterface: createEffectsInterface\n        };\n        function createEffectsInterface(elem, propertyGroup) {\n            if (elem.effectsManager) {\n                var effectElements = [];\n                var effectsData = elem.data.ef;\n                var i;\n                var len = elem.effectsManager.effectElements.length;\n                for(i = 0; i < len; i += 1){\n                    effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));\n                }\n                var effects = elem.data.ef || [];\n                var groupInterface = function groupInterface(name) {\n                    i = 0;\n                    len = effects.length;\n                    while(i < len){\n                        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                            return effectElements[i];\n                        }\n                        i += 1;\n                    }\n                    return null;\n                };\n                Object.defineProperty(groupInterface, \"numProperties\", {\n                    get: function get() {\n                        return effects.length;\n                    }\n                });\n                return groupInterface;\n            }\n            return null;\n        }\n        function createGroupInterface(data, elements, propertyGroup, elem) {\n            function groupInterface(name) {\n                var effects = data.ef;\n                var i = 0;\n                var len = effects.length;\n                while(i < len){\n                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                        if (effects[i].ty === 5) {\n                            return effectElements[i];\n                        }\n                        return effectElements[i]();\n                    }\n                    i += 1;\n                }\n                throw new Error();\n            }\n            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);\n            var effectElements = [];\n            var i;\n            var len = data.ef.length;\n            for(i = 0; i < len; i += 1){\n                if (data.ef[i].ty === 5) {\n                    effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));\n                } else {\n                    effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));\n                }\n            }\n            if (data.mn === \"ADBE Color Control\") {\n                Object.defineProperty(groupInterface, \"color\", {\n                    get: function get() {\n                        return effectElements[0]();\n                    }\n                });\n            }\n            Object.defineProperties(groupInterface, {\n                numProperties: {\n                    get: function get() {\n                        return data.np;\n                    }\n                },\n                _name: {\n                    value: data.nm\n                },\n                propertyGroup: {\n                    value: _propertyGroup\n                }\n            });\n            groupInterface.enabled = data.en !== 0;\n            groupInterface.active = groupInterface.enabled;\n            return groupInterface;\n        }\n        function createValueInterface(element, type, elem, propertyGroup) {\n            var expressionProperty = ExpressionPropertyInterface(element.p);\n            function interfaceFunction() {\n                if (type === 10) {\n                    return elem.comp.compInterface(element.p.v);\n                }\n                return expressionProperty();\n            }\n            if (element.p.setGroupProperty) {\n                element.p.setGroupProperty(PropertyInterface(\"\", propertyGroup));\n            }\n            return interfaceFunction;\n        }\n        return ob;\n    }();\n    var ShapePathInterface = function() {\n        return function pathInterfaceFactory(shape, view, propertyGroup) {\n            var prop = view.sh;\n            function interfaceFunction(val) {\n                if (val === \"Shape\" || val === \"shape\" || val === \"Path\" || val === \"path\" || val === \"ADBE Vector Shape\" || val === 2) {\n                    return interfaceFunction.path;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            prop.setGroupProperty(PropertyInterface(\"Path\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                path: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                shape: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                ix: {\n                    value: shape.ix\n                },\n                propertyIndex: {\n                    value: shape.ix\n                },\n                mn: {\n                    value: shape.mn\n                },\n                propertyGroup: {\n                    value: propertyGroup\n                }\n            });\n            return interfaceFunction;\n        };\n    }();\n    var ShapeExpressionInterface = function() {\n        function iterateElements(shapes, view, propertyGroup) {\n            var arr = [];\n            var i;\n            var len = shapes ? shapes.length : 0;\n            for(i = 0; i < len; i += 1){\n                if (shapes[i].ty === \"gr\") {\n                    arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"fl\") {\n                    arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"st\") {\n                    arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"tm\") {\n                    arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"tr\") {} else if (shapes[i].ty === \"el\") {\n                    arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"sr\") {\n                    arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"sh\") {\n                    arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rc\") {\n                    arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rd\") {\n                    arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"rp\") {\n                    arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === \"gf\") {\n                    arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else {\n                    arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));\n                }\n            }\n            return arr;\n        }\n        function contentsInterfaceFactory(shape, view, propertyGroup) {\n            var interfaces;\n            var interfaceFunction = function _interfaceFunction(value) {\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                if (typeof value === \"number\") {\n                    return interfaces[value - 1];\n                }\n                return null;\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\n            interfaceFunction.numProperties = interfaces.length;\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.transform = transformInterface;\n            interfaceFunction.propertyIndex = shape.cix;\n            interfaceFunction._name = shape.nm;\n            return interfaceFunction;\n        }\n        function groupInterfaceFactory(shape, view, propertyGroup) {\n            var interfaceFunction = function _interfaceFunction(value) {\n                switch(value){\n                    case \"ADBE Vectors Group\":\n                    case \"Contents\":\n                    case 2:\n                        return interfaceFunction.content;\n                    // Not necessary for now. Keeping them here in case a new case appears\n                    // case 'ADBE Vector Transform Group':\n                    // case 3:\n                    default:\n                        return interfaceFunction.transform;\n                }\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.content = content;\n            interfaceFunction.transform = transformInterface;\n            Object.defineProperty(interfaceFunction, \"_name\", {\n                get: function get() {\n                    return shape.nm;\n                }\n            }); // interfaceFunction.content = interfaceFunction;\n            interfaceFunction.numProperties = shape.np;\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.nm = shape.nm;\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function fillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === \"Color\" || val === \"color\") {\n                    return interfaceFunction.color;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface(\"Color\", propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", propertyGroup));\n            return interfaceFunction;\n        }\n        function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === \"Start Point\" || val === \"start point\") {\n                    return interfaceFunction.startPoint;\n                }\n                if (val === \"End Point\" || val === \"end point\") {\n                    return interfaceFunction.endPoint;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                startPoint: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                endPoint: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                type: {\n                    get: function get() {\n                        return \"a\";\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.s.setGroupProperty(PropertyInterface(\"Start Point\", propertyGroup));\n            view.e.setGroupProperty(PropertyInterface(\"End Point\", propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", propertyGroup));\n            return interfaceFunction;\n        }\n        function defaultInterfaceFactory() {\n            function interfaceFunction() {\n                return null;\n            }\n            return interfaceFunction;\n        }\n        function strokeInterfaceFactory(shape, view, propertyGroup) {\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);\n            function addPropertyToDashOb(i) {\n                Object.defineProperty(dashOb, shape.d[i].nm, {\n                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)\n                });\n            }\n            var i;\n            var len = shape.d ? shape.d.length : 0;\n            var dashOb = {};\n            for(i = 0; i < len; i += 1){\n                addPropertyToDashOb(i);\n                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\n            }\n            function interfaceFunction(val) {\n                if (val === \"Color\" || val === \"color\") {\n                    return interfaceFunction.color;\n                }\n                if (val === \"Opacity\" || val === \"opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                if (val === \"Stroke Width\" || val === \"stroke width\") {\n                    return interfaceFunction.strokeWidth;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                strokeWidth: {\n                    get: ExpressionPropertyInterface(view.w)\n                },\n                dash: {\n                    get: function get() {\n                        return dashOb;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface(\"Color\", _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            view.w.setGroupProperty(PropertyInterface(\"Stroke Width\", _propertyGroup));\n            return interfaceFunction;\n        }\n        function trimInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === shape.e.ix || val === \"End\" || val === \"end\") {\n                    return interfaceFunction.end;\n                }\n                if (val === shape.s.ix) {\n                    return interfaceFunction.start;\n                }\n                if (val === shape.o.ix) {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            view.s.setGroupProperty(PropertyInterface(\"Start\", _propertyGroup));\n            view.e.setGroupProperty(PropertyInterface(\"End\", _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface(\"Offset\", _propertyGroup));\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.propertyGroup = propertyGroup;\n            Object.defineProperties(interfaceFunction, {\n                start: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                end: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function transformInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.a.ix === value || value === \"Anchor Point\") {\n                    return interfaceFunction.anchorPoint;\n                }\n                if (shape.o.ix === value || value === \"Opacity\") {\n                    return interfaceFunction.opacity;\n                }\n                if (shape.p.ix === value || value === \"Position\") {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value || value === \"Rotation\" || value === \"ADBE Vector Rotation\") {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.s.ix === value || value === \"Scale\") {\n                    return interfaceFunction.scale;\n                }\n                if (shape.sk && shape.sk.ix === value || value === \"Skew\") {\n                    return interfaceFunction.skew;\n                }\n                if (shape.sa && shape.sa.ix === value || value === \"Skew Axis\") {\n                    return interfaceFunction.skewAxis;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            view.transform.mProps.o.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            view.transform.mProps.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            view.transform.mProps.a.setGroupProperty(PropertyInterface(\"Anchor Point\", _propertyGroup));\n            view.transform.mProps.s.setGroupProperty(PropertyInterface(\"Scale\", _propertyGroup));\n            view.transform.mProps.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            if (view.transform.mProps.sk) {\n                view.transform.mProps.sk.setGroupProperty(PropertyInterface(\"Skew\", _propertyGroup));\n                view.transform.mProps.sa.setGroupProperty(PropertyInterface(\"Skew Angle\", _propertyGroup));\n            }\n            view.transform.op.setGroupProperty(PropertyInterface(\"Opacity\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                opacity: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.o)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.p)\n                },\n                anchorPoint: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.a)\n                },\n                scale: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.s)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.r)\n                },\n                skew: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sk)\n                },\n                skewAxis: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sa)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.ty = \"tr\";\n            interfaceFunction.mn = shape.mn;\n            interfaceFunction.propertyGroup = propertyGroup;\n            return interfaceFunction;\n        }\n        function ellipseInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.s.ix === value) {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            prop.s.setGroupProperty(PropertyInterface(\"Size\", _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function starInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.pt.ix === value) {\n                    return interfaceFunction.points;\n                }\n                if (shape.or.ix === value || value === \"ADBE Vector Star Outer Radius\") {\n                    return interfaceFunction.outerRadius;\n                }\n                if (shape.os.ix === value) {\n                    return interfaceFunction.outerRoundness;\n                }\n                if (shape.ir && (shape.ir.ix === value || value === \"ADBE Vector Star Inner Radius\")) {\n                    return interfaceFunction.innerRadius;\n                }\n                if (shape.is && shape.is.ix === value) {\n                    return interfaceFunction.innerRoundness;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.or.setGroupProperty(PropertyInterface(\"Outer Radius\", _propertyGroup));\n            prop.os.setGroupProperty(PropertyInterface(\"Outer Roundness\", _propertyGroup));\n            prop.pt.setGroupProperty(PropertyInterface(\"Points\", _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            if (shape.ir) {\n                prop.ir.setGroupProperty(PropertyInterface(\"Inner Radius\", _propertyGroup));\n                prop.is.setGroupProperty(PropertyInterface(\"Inner Roundness\", _propertyGroup));\n            }\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                points: {\n                    get: ExpressionPropertyInterface(prop.pt)\n                },\n                outerRadius: {\n                    get: ExpressionPropertyInterface(prop.or)\n                },\n                outerRoundness: {\n                    get: ExpressionPropertyInterface(prop.os)\n                },\n                innerRadius: {\n                    get: ExpressionPropertyInterface(prop.ir)\n                },\n                innerRoundness: {\n                    get: ExpressionPropertyInterface(prop.is)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function rectInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.roundness;\n                }\n                if (shape.s.ix === value || value === \"Size\" || value === \"ADBE Vector Rect Size\") {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === \"tm\" ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.p.setGroupProperty(PropertyInterface(\"Position\", _propertyGroup));\n            prop.s.setGroupProperty(PropertyInterface(\"Size\", _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface(\"Rotation\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                roundness: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function roundedInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.r.ix === value || value === \"Round Corners 1\") {\n                    return interfaceFunction.radius;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.rd.setGroupProperty(PropertyInterface(\"Radius\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                radius: {\n                    get: ExpressionPropertyInterface(prop.rd)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function repeaterInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.c.ix === value || value === \"Copies\") {\n                    return interfaceFunction.copies;\n                }\n                if (shape.o.ix === value || value === \"Offset\") {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.c.setGroupProperty(PropertyInterface(\"Copies\", _propertyGroup));\n            prop.o.setGroupProperty(PropertyInterface(\"Offset\", _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                copies: {\n                    get: ExpressionPropertyInterface(prop.c)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(prop.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        return function(shapes, view, propertyGroup) {\n            var interfaces;\n            function _interfaceFunction(value) {\n                if (typeof value === \"number\") {\n                    value = value === undefined ? 1 : value;\n                    if (value === 0) {\n                        return propertyGroup;\n                    }\n                    return interfaces[value - 1];\n                }\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            function parentGroupWrapper() {\n                return propertyGroup;\n            }\n            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);\n            interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);\n            _interfaceFunction.numProperties = interfaces.length;\n            _interfaceFunction._name = \"Contents\";\n            return _interfaceFunction;\n        };\n    }();\n    var TextExpressionInterface = function() {\n        return function(elem) {\n            var _sourceText;\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case \"ADBE Text Document\":\n                        return _thisLayerFunction.sourceText;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisLayerFunction, \"sourceText\", {\n                get: function get() {\n                    elem.textProperty.getValue();\n                    var stringValue = elem.textProperty.currentData.t;\n                    if (!_sourceText || stringValue !== _sourceText.value) {\n                        _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers\n                        // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n                        _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers\n                        Object.defineProperty(_sourceText, \"style\", {\n                            get: function get() {\n                                return {\n                                    fillColor: elem.textProperty.currentData.fc\n                                };\n                            }\n                        });\n                    }\n                    return _sourceText;\n                }\n            });\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n        if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n            _typeof = function _typeof(obj) {\n                return typeof obj;\n            };\n        } else {\n            _typeof = function _typeof(obj) {\n                return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n            };\n        }\n        return _typeof(obj);\n    }\n    var FootageInterface = function() {\n        var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {\n            var currentPropertyName = \"\";\n            var currentProperty = elem.getFootageData();\n            function init() {\n                currentPropertyName = \"\";\n                currentProperty = elem.getFootageData();\n                return searchProperty;\n            }\n            function searchProperty(value) {\n                if (currentProperty[value]) {\n                    currentPropertyName = value;\n                    currentProperty = currentProperty[value];\n                    if (_typeof(currentProperty) === \"object\") {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                var propertyNameIndex = value.indexOf(currentPropertyName);\n                if (propertyNameIndex !== -1) {\n                    var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);\n                    currentProperty = currentProperty[index];\n                    if (_typeof(currentProperty) === \"object\") {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                return \"\";\n            }\n            return init;\n        };\n        var dataInterfaceFactory = function dataInterfaceFactory(elem) {\n            function interfaceFunction(value) {\n                if (value === \"Outline\") {\n                    return interfaceFunction.outlineInterface();\n                }\n                return null;\n            }\n            interfaceFunction._name = \"Outline\";\n            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);\n            return interfaceFunction;\n        };\n        return function(elem) {\n            function _interfaceFunction(value) {\n                if (value === \"Data\") {\n                    return _interfaceFunction.dataInterface;\n                }\n                return null;\n            }\n            _interfaceFunction._name = \"Data\";\n            _interfaceFunction.dataInterface = dataInterfaceFactory(elem);\n            return _interfaceFunction;\n        };\n    }();\n    var interfaces = {\n        layer: LayerExpressionInterface,\n        effects: EffectsExpressionInterface,\n        comp: CompExpressionInterface,\n        shape: ShapeExpressionInterface,\n        text: TextExpressionInterface,\n        footage: FootageInterface\n    };\n    function getInterface(type) {\n        return interfaces[type] || null;\n    }\n    var expressionHelpers = function() {\n        function searchExpressions(elem, data, prop) {\n            if (data.x) {\n                prop.k = true;\n                prop.x = true;\n                prop.initiateExpression = ExpressionManager.initiateExpression;\n                prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));\n            }\n        }\n        function getValueAtTime(frameNum) {\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastFrame) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\n                this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\n                this._cachingAtTime.lastFrame = frameNum;\n            }\n            return this._cachingAtTime.value;\n        }\n        function getSpeedAtTime(frameNum) {\n            var delta = -0.01;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var speed = 0;\n            if (v1.length) {\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    speed += Math.pow(v2[i] - v1[i], 2);\n                }\n                speed = Math.sqrt(speed) * 100;\n            } else {\n                speed = 0;\n            }\n            return speed;\n        }\n        function getVelocityAtTime(frameNum) {\n            if (this.vel !== undefined) {\n                return this.vel;\n            }\n            var delta = -0.001; // frameNum += this.elem.data.st;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var velocity;\n            if (v1.length) {\n                velocity = createTypedArray(\"float32\", v1.length);\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    // removing frameRate\n                    // if needed, don't add it here\n                    // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n                    velocity[i] = (v2[i] - v1[i]) / delta;\n                }\n            } else {\n                velocity = (v2 - v1) / delta;\n            }\n            return velocity;\n        }\n        function getStaticValueAtTime() {\n            return this.pv;\n        }\n        function setGroupProperty(propertyGroup) {\n            this.propertyGroup = propertyGroup;\n        }\n        return {\n            searchExpressions: searchExpressions,\n            getSpeedAtTime: getSpeedAtTime,\n            getVelocityAtTime: getVelocityAtTime,\n            getValueAtTime: getValueAtTime,\n            getStaticValueAtTime: getStaticValueAtTime,\n            setGroupProperty: setGroupProperty\n        };\n    }();\n    function addPropertyDecorator() {\n        function loopOut(type, duration, durationFlag) {\n            if (!this.k || !this.keyframes) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : \"\";\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var lastKeyFrame = keyframes[keyframes.length - 1].t;\n            if (currentFrame <= lastKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var firstKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);\n                } else {\n                    cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);\n                }\n                firstKeyFrame = lastKeyFrame - cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === \"pingpong\") {\n                var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (iterations % 2 !== 0) {\n                    return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === \"offset\") {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = (endV[i] - initV[i]) * repeats + current[i];\n                    }\n                    return ret;\n                }\n                return (endV - initV) * repeats + current;\n            } else if (type === \"continue\") {\n                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(lastValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line\n                    }\n                    return ret;\n                }\n                return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);\n            }\n            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function loopIn(type, duration, durationFlag) {\n            if (!this.k) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : \"\";\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var firstKeyFrame = keyframes[0].t;\n            if (currentFrame >= firstKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var lastKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                lastKeyFrame = keyframes[duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);\n                } else {\n                    cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);\n                }\n                lastKeyFrame = firstKeyFrame + cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === \"pingpong\") {\n                var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);\n                if (iterations % 2 === 0) {\n                    return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === \"offset\") {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);\n                var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = current[i] - (endV[i] - initV[i]) * repeats;\n                    }\n                    return ret;\n                }\n                return current - (endV - initV) * repeats;\n            } else if (type === \"continue\") {\n                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(firstValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;\n                    }\n                    return ret;\n                }\n                return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;\n            }\n            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function smooth(width, samples) {\n            if (!this.k) {\n                return this.pv;\n            }\n            width = (width || 0.4) * 0.5;\n            samples = Math.floor(samples || 5);\n            if (samples <= 1) {\n                return this.pv;\n            }\n            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;\n            var initFrame = currentTime - width;\n            var endFrame = currentTime + width;\n            var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;\n            var i = 0;\n            var j = 0;\n            var value;\n            if (this.pv.length) {\n                value = createTypedArray(\"float32\", this.pv.length);\n            } else {\n                value = 0;\n            }\n            var sampleValue;\n            while(i < samples){\n                sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);\n                if (this.pv.length) {\n                    for(j = 0; j < this.pv.length; j += 1){\n                        value[j] += sampleValue[j];\n                    }\n                } else {\n                    value += sampleValue;\n                }\n                i += 1;\n            }\n            if (this.pv.length) {\n                for(j = 0; j < this.pv.length; j += 1){\n                    value[j] /= samples;\n                }\n            } else {\n                value /= samples;\n            }\n            return value;\n        }\n        function getTransformValueAtTime(time) {\n            if (!this._transformCachingAtTime) {\n                this._transformCachingAtTime = {\n                    v: new Matrix()\n                };\n            } /// /\n            var matrix = this._transformCachingAtTime.v;\n            matrix.cloneFromProps(this.pre.props);\n            if (this.appliedTransformations < 1) {\n                var anchor = this.a.getValueAtTime(time);\n                matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);\n            }\n            if (this.appliedTransformations < 2) {\n                var scale = this.s.getValueAtTime(time);\n                matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);\n            }\n            if (this.sk && this.appliedTransformations < 3) {\n                var skew = this.sk.getValueAtTime(time);\n                var skewAxis = this.sa.getValueAtTime(time);\n                matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);\n            }\n            if (this.r && this.appliedTransformations < 4) {\n                var rotation = this.r.getValueAtTime(time);\n                matrix.rotate(-rotation * this.r.mult);\n            } else if (!this.r && this.appliedTransformations < 4) {\n                var rotationZ = this.rz.getValueAtTime(time);\n                var rotationY = this.ry.getValueAtTime(time);\n                var rotationX = this.rx.getValueAtTime(time);\n                var orientation = this.or.getValueAtTime(time);\n                matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);\n            }\n            if (this.data.p && this.data.p.s) {\n                var positionX = this.px.getValueAtTime(time);\n                var positionY = this.py.getValueAtTime(time);\n                if (this.data.p.z) {\n                    var positionZ = this.pz.getValueAtTime(time);\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);\n                } else {\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);\n                }\n            } else {\n                var position = this.p.getValueAtTime(time);\n                matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);\n            }\n            return matrix; /// /\n        }\n        function getTransformStaticValueAtTime() {\n            return this.v.clone(new Matrix());\n        }\n        var getTransformProperty = TransformPropertyFactory.getTransformProperty;\n        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {\n            var prop = getTransformProperty(elem, data, container);\n            if (prop.dynamicProperties.length) {\n                prop.getValueAtTime = getTransformValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            return prop;\n        };\n        var propertyGetProp = PropertyFactory.getProp;\n        PropertyFactory.getProp = function(elem, data, type, mult, container) {\n            var prop = propertyGetProp(elem, data, type, mult, container); // prop.getVelocityAtTime = getVelocityAtTime;\n            // prop.loopOut = loopOut;\n            // prop.loopIn = loopIn;\n            if (prop.kf) {\n                prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            prop.loopOut = loopOut;\n            prop.loopIn = loopIn;\n            prop.smooth = smooth;\n            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);\n            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);\n            prop.numKeys = data.a === 1 ? data.k.length : 0;\n            prop.propertyIndex = data.ix;\n            var value = 0;\n            if (type !== 0) {\n                value = createTypedArray(\"float32\", data.a === 1 ? data.k[0].s.length : data.k.length);\n            }\n            prop._cachingAtTime = {\n                lastFrame: initialDefaultFrame,\n                lastIndex: 0,\n                value: value\n            };\n            expressionHelpers.searchExpressions(elem, data, prop);\n            if (prop.k) {\n                container.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n        function getShapeValueAtTime(frameNum) {\n            // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n            if (!this._cachingAtTime) {\n                this._cachingAtTime = {\n                    shapeValue: shapePool.clone(this.pv),\n                    lastIndex: 0,\n                    lastTime: initialDefaultFrame\n                };\n            }\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastTime) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\n                this._cachingAtTime.lastTime = frameNum;\n                this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\n            }\n            return this._cachingAtTime.shapeValue;\n        }\n        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\n        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\n        function ShapeExpressions() {}\n        ShapeExpressions.prototype = {\n            vertices: function vertices(prop, time) {\n                if (this.k) {\n                    this.getValue();\n                }\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                var i;\n                var len = shapePath._length;\n                var vertices = shapePath[prop];\n                var points = shapePath.v;\n                var arr = createSizedArray(len);\n                for(i = 0; i < len; i += 1){\n                    if (prop === \"i\" || prop === \"o\") {\n                        arr[i] = [\n                            vertices[i][0] - points[i][0],\n                            vertices[i][1] - points[i][1]\n                        ];\n                    } else {\n                        arr[i] = [\n                            vertices[i][0],\n                            vertices[i][1]\n                        ];\n                    }\n                }\n                return arr;\n            },\n            points: function points(time) {\n                return this.vertices(\"v\", time);\n            },\n            inTangents: function inTangents(time) {\n                return this.vertices(\"i\", time);\n            },\n            outTangents: function outTangents(time) {\n                return this.vertices(\"o\", time);\n            },\n            isClosed: function isClosed() {\n                return this.v.c;\n            },\n            pointOnPath: function pointOnPath(perc, time) {\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                if (!this._segmentsLength) {\n                    this._segmentsLength = bez.getSegmentsLength(shapePath);\n                }\n                var segmentsLength = this._segmentsLength;\n                var lengths = segmentsLength.lengths;\n                var lengthPos = segmentsLength.totalLength * perc;\n                var i = 0;\n                var len = lengths.length;\n                var accumulatedLength = 0;\n                var pt;\n                while(i < len){\n                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n                        var initIndex = i;\n                        var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;\n                        var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;\n                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\n                        break;\n                    } else {\n                        accumulatedLength += lengths[i].addedLength;\n                    }\n                    i += 1;\n                }\n                if (!pt) {\n                    pt = shapePath.c ? [\n                        shapePath.v[0][0],\n                        shapePath.v[0][1]\n                    ] : [\n                        shapePath.v[shapePath._length - 1][0],\n                        shapePath.v[shapePath._length - 1][1]\n                    ];\n                }\n                return pt;\n            },\n            vectorOnPath: function vectorOnPath(perc, time, vectorType) {\n                // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n                if (perc == 1) {\n                    // eslint-disable-line eqeqeq\n                    perc = this.v.c;\n                } else if (perc == 0) {\n                    // eslint-disable-line eqeqeq\n                    perc = 0.999;\n                }\n                var pt1 = this.pointOnPath(perc, time);\n                var pt2 = this.pointOnPath(perc + 0.001, time);\n                var xLength = pt2[0] - pt1[0];\n                var yLength = pt2[1] - pt1[1];\n                var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));\n                if (magnitude === 0) {\n                    return [\n                        0,\n                        0\n                    ];\n                }\n                var unitVector = vectorType === \"tangent\" ? [\n                    xLength / magnitude,\n                    yLength / magnitude\n                ] : [\n                    -yLength / magnitude,\n                    xLength / magnitude\n                ];\n                return unitVector;\n            },\n            tangentOnPath: function tangentOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, \"tangent\");\n            },\n            normalOnPath: function normalOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, \"normal\");\n            },\n            setGroupProperty: expressionHelpers.setGroupProperty,\n            getValueAtTime: expressionHelpers.getStaticValueAtTime\n        };\n        extendPrototype([\n            ShapeExpressions\n        ], ShapePropertyConstructorFunction);\n        extendPrototype([\n            ShapeExpressions\n        ], KeyframedShapePropertyConstructorFunction);\n        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\n        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\n        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\n        ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {\n            var prop = propertyGetShapeProp(elem, data, type, arr, trims);\n            prop.propertyIndex = data.ix;\n            prop.lock = false;\n            if (type === 3) {\n                expressionHelpers.searchExpressions(elem, data.pt, prop);\n            } else if (type === 4) {\n                expressionHelpers.searchExpressions(elem, data.ks, prop);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n    }\n    function initialize$1() {\n        addPropertyDecorator();\n    }\n    function addDecorator() {\n        function searchExpressions() {\n            if (this.data.d.x) {\n                this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);\n                this.addEffect(this.getExpressionValue.bind(this));\n                return true;\n            }\n            return null;\n        }\n        TextProperty.prototype.getExpressionValue = function(currentValue, text) {\n            var newValue = this.calculateExpression(text);\n            if (currentValue.t !== newValue) {\n                var newData = {};\n                this.copyData(newData, currentValue);\n                newData.t = newValue.toString();\n                newData.__complete = false;\n                return newData;\n            }\n            return currentValue;\n        };\n        TextProperty.prototype.searchProperty = function() {\n            var isKeyframed = this.searchKeyframes();\n            var hasExpressions = this.searchExpressions();\n            this.kf = isKeyframed || hasExpressions;\n            return this.kf;\n        };\n        TextProperty.prototype.searchExpressions = searchExpressions;\n    }\n    function initialize() {\n        addDecorator();\n    }\n    function SVGComposableEffect() {}\n    SVGComposableEffect.prototype = {\n        createMergeNode: function createMergeNode(resultId, ins) {\n            var feMerge = createNS(\"feMerge\");\n            feMerge.setAttribute(\"result\", resultId);\n            var feMergeNode;\n            var i;\n            for(i = 0; i < ins.length; i += 1){\n                feMergeNode = createNS(\"feMergeNode\");\n                feMergeNode.setAttribute(\"in\", ins[i]);\n                feMerge.appendChild(feMergeNode);\n                feMerge.appendChild(feMergeNode);\n            }\n            return feMerge;\n        }\n    };\n    var linearFilterValue = \"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0\";\n    function SVGTintFilter(filter, filterManager, elem, id, source) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"linearRGB\");\n        feColorMatrix.setAttribute(\"values\", linearFilterValue + \" 1 0\");\n        this.linearFilter = feColorMatrix;\n        feColorMatrix.setAttribute(\"result\", id + \"_tint_1\");\n        filter.appendChild(feColorMatrix);\n        feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feColorMatrix.setAttribute(\"values\", \"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0\");\n        feColorMatrix.setAttribute(\"result\", id + \"_tint_2\");\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n        var feMerge = this.createMergeNode(id, [\n            source,\n            id + \"_tint_1\",\n            id + \"_tint_2\"\n        ]);\n        filter.appendChild(feMerge);\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGTintFilter);\n    SVGTintFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var colorBlack = this.filterManager.effectElements[0].p.v;\n            var colorWhite = this.filterManager.effectElements[1].p.v;\n            var opacity = this.filterManager.effectElements[2].p.v / 100;\n            this.linearFilter.setAttribute(\"values\", linearFilterValue + \" \" + opacity + \" 0\");\n            this.matrixFilter.setAttribute(\"values\", colorWhite[0] - colorBlack[0] + \" 0 0 0 \" + colorBlack[0] + \" \" + (colorWhite[1] - colorBlack[1]) + \" 0 0 0 \" + colorBlack[1] + \" \" + (colorWhite[2] - colorBlack[2]) + \" 0 0 0 \" + colorBlack[2] + \" 0 0 0 1 0\");\n        }\n    };\n    function SVGFillFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feColorMatrix.setAttribute(\"values\", \"1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0\");\n        feColorMatrix.setAttribute(\"result\", id);\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n    }\n    SVGFillFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color = this.filterManager.effectElements[2].p.v;\n            var opacity = this.filterManager.effectElements[6].p.v;\n            this.matrixFilter.setAttribute(\"values\", \"0 0 0 0 \" + color[0] + \" 0 0 0 0 \" + color[1] + \" 0 0 0 0 \" + color[2] + \" 0 0 0 \" + opacity + \" 0\");\n        }\n    };\n    function SVGStrokeEffect(fil, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.elem = elem;\n        this.paths = [];\n    }\n    SVGStrokeEffect.prototype.initialize = function() {\n        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n        var path;\n        var groupPath;\n        var i;\n        var len;\n        if (this.filterManager.effectElements[1].p.v === 1) {\n            len = this.elem.maskManager.masksProperties.length;\n            i = 0;\n        } else {\n            i = this.filterManager.effectElements[0].p.v - 1;\n            len = i + 1;\n        }\n        groupPath = createNS(\"g\");\n        groupPath.setAttribute(\"fill\", \"none\");\n        groupPath.setAttribute(\"stroke-linecap\", \"round\");\n        groupPath.setAttribute(\"stroke-dashoffset\", 1);\n        for(i; i < len; i += 1){\n            path = createNS(\"path\");\n            groupPath.appendChild(path);\n            this.paths.push({\n                p: path,\n                m: i\n            });\n        }\n        if (this.filterManager.effectElements[10].p.v === 3) {\n            var mask = createNS(\"mask\");\n            var id = createElementID();\n            mask.setAttribute(\"id\", id);\n            mask.setAttribute(\"mask-type\", \"alpha\");\n            mask.appendChild(groupPath);\n            this.elem.globalData.defs.appendChild(mask);\n            var g = createNS(\"g\");\n            g.setAttribute(\"mask\", \"url(\" + getLocationHref() + \"#\" + id + \")\");\n            while(elemChildren[0]){\n                g.appendChild(elemChildren[0]);\n            }\n            this.elem.layerElement.appendChild(g);\n            this.masker = mask;\n            groupPath.setAttribute(\"stroke\", \"#fff\");\n        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (this.filterManager.effectElements[10].p.v === 2) {\n                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n                while(elemChildren.length){\n                    this.elem.layerElement.removeChild(elemChildren[0]);\n                }\n            }\n            this.elem.layerElement.appendChild(groupPath);\n            this.elem.layerElement.removeAttribute(\"mask\");\n            groupPath.setAttribute(\"stroke\", \"#fff\");\n        }\n        this.initialized = true;\n        this.pathMasker = groupPath;\n    };\n    SVGStrokeEffect.prototype.renderFrame = function(forceRender) {\n        if (!this.initialized) {\n            this.initialize();\n        }\n        var i;\n        var len = this.paths.length;\n        var mask;\n        var path;\n        for(i = 0; i < len; i += 1){\n            if (this.paths[i].m !== -1) {\n                mask = this.elem.maskManager.viewData[this.paths[i].m];\n                path = this.paths[i].p;\n                if (forceRender || this.filterManager._mdf || mask.prop._mdf) {\n                    path.setAttribute(\"d\", mask.lastPath);\n                }\n                if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {\n                    var dasharrayValue;\n                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {\n                        var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var l = path.getTotalLength();\n                        dasharrayValue = \"0 0 0 \" + l * s + \" \";\n                        var lineLength = l * (e - s);\n                        var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                        var units = Math.floor(lineLength / segment);\n                        var j;\n                        for(j = 0; j < units; j += 1){\n                            dasharrayValue += \"1 \" + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + \" \";\n                        }\n                        dasharrayValue += \"0 \" + l * 10 + \" 0 0\";\n                    } else {\n                        dasharrayValue = \"1 \" + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                    }\n                    path.setAttribute(\"stroke-dasharray\", dasharrayValue);\n                }\n            }\n        }\n        if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n            this.pathMasker.setAttribute(\"stroke-width\", this.filterManager.effectElements[4].p.v * 2);\n        }\n        if (forceRender || this.filterManager.effectElements[6].p._mdf) {\n            this.pathMasker.setAttribute(\"opacity\", this.filterManager.effectElements[6].p.v);\n        }\n        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (forceRender || this.filterManager.effectElements[3].p._mdf) {\n                var color = this.filterManager.effectElements[3].p.v;\n                this.pathMasker.setAttribute(\"stroke\", \"rgb(\" + bmFloor(color[0] * 255) + \",\" + bmFloor(color[1] * 255) + \",\" + bmFloor(color[2] * 255) + \")\");\n            }\n        }\n    };\n    function SVGTritoneFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS(\"feColorMatrix\");\n        feColorMatrix.setAttribute(\"type\", \"matrix\");\n        feColorMatrix.setAttribute(\"color-interpolation-filters\", \"linearRGB\");\n        feColorMatrix.setAttribute(\"values\", \"0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\");\n        filter.appendChild(feColorMatrix);\n        var feComponentTransfer = createNS(\"feComponentTransfer\");\n        feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n        feComponentTransfer.setAttribute(\"result\", id);\n        this.matrixFilter = feComponentTransfer;\n        var feFuncR = createNS(\"feFuncR\");\n        feFuncR.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncR);\n        this.feFuncR = feFuncR;\n        var feFuncG = createNS(\"feFuncG\");\n        feFuncG.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncG);\n        this.feFuncG = feFuncG;\n        var feFuncB = createNS(\"feFuncB\");\n        feFuncB.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFuncB);\n        this.feFuncB = feFuncB;\n        filter.appendChild(feComponentTransfer);\n    }\n    SVGTritoneFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color1 = this.filterManager.effectElements[0].p.v;\n            var color2 = this.filterManager.effectElements[1].p.v;\n            var color3 = this.filterManager.effectElements[2].p.v;\n            var tableR = color3[0] + \" \" + color2[0] + \" \" + color1[0];\n            var tableG = color3[1] + \" \" + color2[1] + \" \" + color1[1];\n            var tableB = color3[2] + \" \" + color2[2] + \" \" + color1[2];\n            this.feFuncR.setAttribute(\"tableValues\", tableR);\n            this.feFuncG.setAttribute(\"tableValues\", tableG);\n            this.feFuncB.setAttribute(\"tableValues\", tableB);\n        }\n    };\n    function SVGProLevelsFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var effectElements = this.filterManager.effectElements;\n        var feComponentTransfer = createNS(\"feComponentTransfer\"); // Red\n        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {\n            this.feFuncR = this.createFeFunc(\"feFuncR\", feComponentTransfer);\n        } // Green\n        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {\n            this.feFuncG = this.createFeFunc(\"feFuncG\", feComponentTransfer);\n        } // Blue\n        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {\n            this.feFuncB = this.createFeFunc(\"feFuncB\", feComponentTransfer);\n        } // Alpha\n        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {\n            this.feFuncA = this.createFeFunc(\"feFuncA\", feComponentTransfer);\n        } // RGB\n        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {\n            feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            filter.appendChild(feComponentTransfer);\n        }\n        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {\n            feComponentTransfer = createNS(\"feComponentTransfer\");\n            feComponentTransfer.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n            feComponentTransfer.setAttribute(\"result\", id);\n            filter.appendChild(feComponentTransfer);\n            this.feFuncRComposed = this.createFeFunc(\"feFuncR\", feComponentTransfer);\n            this.feFuncGComposed = this.createFeFunc(\"feFuncG\", feComponentTransfer);\n            this.feFuncBComposed = this.createFeFunc(\"feFuncB\", feComponentTransfer);\n        }\n    }\n    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {\n        var feFunc = createNS(type);\n        feFunc.setAttribute(\"type\", \"table\");\n        feComponentTransfer.appendChild(feFunc);\n        return feFunc;\n    };\n    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\n        var cnt = 0;\n        var segments = 256;\n        var perc;\n        var min = Math.min(inputBlack, inputWhite);\n        var max = Math.max(inputBlack, inputWhite);\n        var table = Array.call(null, {\n            length: segments\n        });\n        var colorValue;\n        var pos = 0;\n        var outputDelta = outputWhite - outputBlack;\n        var inputDelta = inputWhite - inputBlack;\n        while(cnt <= 256){\n            perc = cnt / 256;\n            if (perc <= min) {\n                colorValue = inputDelta < 0 ? outputWhite : outputBlack;\n            } else if (perc >= max) {\n                colorValue = inputDelta < 0 ? outputBlack : outputWhite;\n            } else {\n                colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);\n            }\n            table[pos] = colorValue;\n            pos += 1;\n            cnt += 256 / (segments - 1);\n        }\n        return table.join(\" \");\n    };\n    SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var val;\n            var effectElements = this.filterManager.effectElements;\n            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {\n                val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);\n                this.feFuncRComposed.setAttribute(\"tableValues\", val);\n                this.feFuncGComposed.setAttribute(\"tableValues\", val);\n                this.feFuncBComposed.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {\n                val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);\n                this.feFuncR.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {\n                val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);\n                this.feFuncG.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {\n                val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);\n                this.feFuncB.setAttribute(\"tableValues\", val);\n            }\n            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {\n                val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);\n                this.feFuncA.setAttribute(\"tableValues\", val);\n            }\n        }\n    };\n    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {\n        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;\n        var filterSize = filterManager.data.fs || globalFilterSize;\n        filter.setAttribute(\"x\", filterSize.x || globalFilterSize.x);\n        filter.setAttribute(\"y\", filterSize.y || globalFilterSize.y);\n        filter.setAttribute(\"width\", filterSize.width || globalFilterSize.width);\n        filter.setAttribute(\"height\", filterSize.height || globalFilterSize.height);\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS(\"feGaussianBlur\");\n        feGaussianBlur.setAttribute(\"in\", \"SourceAlpha\");\n        feGaussianBlur.setAttribute(\"result\", id + \"_drop_shadow_1\");\n        feGaussianBlur.setAttribute(\"stdDeviation\", \"0\");\n        this.feGaussianBlur = feGaussianBlur;\n        filter.appendChild(feGaussianBlur);\n        var feOffset = createNS(\"feOffset\");\n        feOffset.setAttribute(\"dx\", \"25\");\n        feOffset.setAttribute(\"dy\", \"0\");\n        feOffset.setAttribute(\"in\", id + \"_drop_shadow_1\");\n        feOffset.setAttribute(\"result\", id + \"_drop_shadow_2\");\n        this.feOffset = feOffset;\n        filter.appendChild(feOffset);\n        var feFlood = createNS(\"feFlood\");\n        feFlood.setAttribute(\"flood-color\", \"#00ff00\");\n        feFlood.setAttribute(\"flood-opacity\", \"1\");\n        feFlood.setAttribute(\"result\", id + \"_drop_shadow_3\");\n        this.feFlood = feFlood;\n        filter.appendChild(feFlood);\n        var feComposite = createNS(\"feComposite\");\n        feComposite.setAttribute(\"in\", id + \"_drop_shadow_3\");\n        feComposite.setAttribute(\"in2\", id + \"_drop_shadow_2\");\n        feComposite.setAttribute(\"operator\", \"in\");\n        feComposite.setAttribute(\"result\", id + \"_drop_shadow_4\");\n        filter.appendChild(feComposite);\n        var feMerge = this.createMergeNode(id, [\n            id + \"_drop_shadow_4\",\n            source\n        ]);\n        filter.appendChild(feMerge); //\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGDropShadowEffect);\n    SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n                this.feGaussianBlur.setAttribute(\"stdDeviation\", this.filterManager.effectElements[4].p.v / 4);\n            }\n            if (forceRender || this.filterManager.effectElements[0].p._mdf) {\n                var col = this.filterManager.effectElements[0].p.v;\n                this.feFlood.setAttribute(\"flood-color\", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));\n            }\n            if (forceRender || this.filterManager.effectElements[1].p._mdf) {\n                this.feFlood.setAttribute(\"flood-opacity\", this.filterManager.effectElements[1].p.v / 255);\n            }\n            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {\n                var distance = this.filterManager.effectElements[3].p.v;\n                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\n                var x = distance * Math.cos(angle);\n                var y = distance * Math.sin(angle);\n                this.feOffset.setAttribute(\"dx\", x);\n                this.feOffset.setAttribute(\"dy\", y);\n            }\n        }\n    };\n    var _svgMatteSymbols = [];\n    function SVGMatte3Effect(filterElem, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.filterElem = filterElem;\n        this.elem = elem;\n        elem.matteElement = createNS(\"g\");\n        elem.matteElement.appendChild(elem.layerElement);\n        elem.matteElement.appendChild(elem.transformedElement);\n        elem.baseElement = elem.matteElement;\n    }\n    SVGMatte3Effect.prototype.findSymbol = function(mask) {\n        var i = 0;\n        var len = _svgMatteSymbols.length;\n        while(i < len){\n            if (_svgMatteSymbols[i] === mask) {\n                return _svgMatteSymbols[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {\n        var parentNode = mask.layerElement.parentNode;\n        if (!parentNode) {\n            return;\n        }\n        var children = parentNode.children;\n        var i = 0;\n        var len = children.length;\n        while(i < len){\n            if (children[i] === mask.layerElement) {\n                break;\n            }\n            i += 1;\n        }\n        var nextChild;\n        if (i <= len - 2) {\n            nextChild = children[i + 1];\n        }\n        var useElem = createNS(\"use\");\n        useElem.setAttribute(\"href\", \"#\" + symbolId);\n        if (nextChild) {\n            parentNode.insertBefore(useElem, nextChild);\n        } else {\n            parentNode.appendChild(useElem);\n        }\n    };\n    SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {\n        if (!this.findSymbol(mask)) {\n            var symbolId = createElementID();\n            var masker = createNS(\"mask\");\n            masker.setAttribute(\"id\", mask.layerId);\n            masker.setAttribute(\"mask-type\", \"alpha\");\n            _svgMatteSymbols.push(mask);\n            var defs = elem.globalData.defs;\n            defs.appendChild(masker);\n            var symbol = createNS(\"symbol\");\n            symbol.setAttribute(\"id\", symbolId);\n            this.replaceInParent(mask, symbolId);\n            symbol.appendChild(mask.layerElement);\n            defs.appendChild(symbol);\n            var useElem = createNS(\"use\");\n            useElem.setAttribute(\"href\", \"#\" + symbolId);\n            masker.appendChild(useElem);\n            mask.data.hd = false;\n            mask.show();\n        }\n        elem.setMatte(mask.layerId);\n    };\n    SVGMatte3Effect.prototype.initialize = function() {\n        var ind = this.filterManager.effectElements[0].p.v;\n        var elements = this.elem.comp.elements;\n        var i = 0;\n        var len = elements.length;\n        while(i < len){\n            if (elements[i] && elements[i].data.ind === ind) {\n                this.setElementAsMask(this.elem, elements[i]);\n            }\n            i += 1;\n        }\n        this.initialized = true;\n    };\n    SVGMatte3Effect.prototype.renderFrame = function() {\n        if (!this.initialized) {\n            this.initialize();\n        }\n    };\n    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {\n        // Outset the filter region by 100% on all sides to accommodate blur expansion.\n        filter.setAttribute(\"x\", \"-100%\");\n        filter.setAttribute(\"y\", \"-100%\");\n        filter.setAttribute(\"width\", \"300%\");\n        filter.setAttribute(\"height\", \"300%\");\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS(\"feGaussianBlur\");\n        feGaussianBlur.setAttribute(\"result\", id);\n        filter.appendChild(feGaussianBlur);\n        this.feGaussianBlur = feGaussianBlur;\n    }\n    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            // Empirical value, matching AE's blur appearance.\n            var kBlurrinessToSigma = 0.3;\n            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma; // Dimensions mapping:\n            //\n            //   1 -> horizontal & vertical\n            //   2 -> horizontal only\n            //   3 -> vertical only\n            //\n            var dimensions = this.filterManager.effectElements[1].p.v;\n            var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq\n            var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute(\"stdDeviation\", sigmaX + \" \" + sigmaY); // Repeat edges mapping:\n            //\n            //   0 -> off -> duplicate\n            //   1 -> on  -> wrap\n            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? \"wrap\" : \"duplicate\"; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute(\"edgeMode\", edgeMode);\n        }\n    };\n    function TransformEffect() {}\n    TransformEffect.prototype.init = function(effectsManager) {\n        this.effectsManager = effectsManager;\n        this.type = effectTypes.TRANSFORM_EFFECT;\n        this.matrix = new Matrix();\n        this.opacity = -1;\n        this._mdf = false;\n        this._opMdf = false;\n    };\n    TransformEffect.prototype.renderFrame = function(forceFrame) {\n        this._opMdf = false;\n        this._mdf = false;\n        if (forceFrame || this.effectsManager._mdf) {\n            var effectElements = this.effectsManager.effectElements;\n            var anchor = effectElements[0].p.v;\n            var position = effectElements[1].p.v;\n            var isUniformScale = effectElements[2].p.v === 1;\n            var scaleHeight = effectElements[3].p.v;\n            var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;\n            var skew = effectElements[5].p.v;\n            var skewAxis = effectElements[6].p.v;\n            var rotation = effectElements[7].p.v;\n            this.matrix.reset();\n            this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);\n            this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);\n            this.matrix.rotate(-rotation * degToRads);\n            this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);\n            this.matrix.translate(position[0], position[1], 0);\n            this._mdf = true;\n            if (this.opacity !== effectElements[8].p.v) {\n                this.opacity = effectElements[8].p.v;\n                this._opMdf = true;\n            }\n        }\n    };\n    function SVGTransformEffect(_, filterManager) {\n        this.init(filterManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], SVGTransformEffect);\n    function CVTransformEffect(effectsManager) {\n        this.init(effectsManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], CVTransformEffect);\n    registerRenderer(\"canvas\", CanvasRenderer);\n    registerRenderer(\"html\", HybridRenderer);\n    registerRenderer(\"svg\", SVGRenderer); // Registering shape modifiers\n    ShapeModifiers.registerModifier(\"tm\", TrimModifier);\n    ShapeModifiers.registerModifier(\"pb\", PuckerAndBloatModifier);\n    ShapeModifiers.registerModifier(\"rp\", RepeaterModifier);\n    ShapeModifiers.registerModifier(\"rd\", RoundCornersModifier);\n    ShapeModifiers.registerModifier(\"zz\", ZigZagModifier);\n    ShapeModifiers.registerModifier(\"op\", OffsetPathModifier); // Registering expression plugin\n    setExpressionsPlugin(Expressions);\n    setExpressionInterfaces(getInterface);\n    initialize$1();\n    initialize(); // Registering svg effects\n    registerEffect$1(20, SVGTintFilter, true);\n    registerEffect$1(21, SVGFillFilter, true);\n    registerEffect$1(22, SVGStrokeEffect, false);\n    registerEffect$1(23, SVGTritoneFilter, true);\n    registerEffect$1(24, SVGProLevelsFilter, true);\n    registerEffect$1(25, SVGDropShadowEffect, true);\n    registerEffect$1(28, SVGMatte3Effect, false);\n    registerEffect$1(29, SVGGaussianBlurEffect, true);\n    registerEffect$1(35, SVGTransformEffect, false);\n    registerEffect(35, CVTransformEffect);\n    return lottie;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG90dGllLXdlYi9idWlsZC9wbGF5ZXIvbG90dGllLmpzIiwibWFwcGluZ3MiOiI7QUFBQyxPQUFPQSxjQUFjLGVBQWdCLFNBQVdDLE1BQU0sRUFBRUMsT0FBTztJQUM5RCxLQUFpRCxHQUFjRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2hGLENBQ29HO0FBQ3RHLEVBQUcsUUFBTztJQUFjO0lBRXRCLElBQUlRLFFBQVE7SUFDWixJQUFJQyxlQUFlO0lBQ25CLElBQUlDLGdCQUFnQjtJQUNwQixJQUFJQyxzQkFBc0IsQ0FBQztJQUUzQixJQUFJQyxlQUFlLFNBQVNBLGFBQWFDLElBQUk7UUFDM0NILGdCQUFnQixDQUFDLENBQUNHO0lBQ3BCO0lBRUEsSUFBSUMsZUFBZSxTQUFTQTtRQUMxQixPQUFPSjtJQUNUO0lBRUEsSUFBSUssa0JBQWtCLFNBQVNBLGdCQUFnQkMsS0FBSztRQUNsRFAsZUFBZU87SUFDakI7SUFFQSxJQUFJQyxrQkFBa0IsU0FBU0E7UUFDN0IsT0FBT1I7SUFDVDtJQUVBLFNBQVNTLFVBQVVDLElBQUk7UUFDckIsdUVBQXVFO1FBQ3ZFLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQ0Y7SUFDaEM7SUFFQSxTQUFTRyxnQkFBZ0JDLE9BQU8sRUFBRUMsV0FBVztRQUMzQyxJQUFJQztRQUNKLElBQUlDLE1BQU1ILFFBQVFJLE1BQU07UUFDeEIsSUFBSUM7UUFFSixJQUFLSCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQkcsa0JBQWtCTCxPQUFPLENBQUNFLEVBQUUsQ0FBQ0ksU0FBUztZQUV0QyxJQUFLLElBQUlDLFFBQVFGLGdCQUFpQjtnQkFDaEMsSUFBSUcsT0FBT0YsU0FBUyxDQUFDRyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsaUJBQWlCRSxPQUFPTixZQUFZSyxTQUFTLENBQUNDLEtBQUssR0FBR0YsZUFBZSxDQUFDRSxLQUFLO1lBQ3RIO1FBQ0Y7SUFDRjtJQUVBLFNBQVNJLGNBQWNDLE1BQU0s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U0FBUyxDQUFDaUMsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEVBQUUsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUcsRUFBRUEsV0FBVyxDQUFDLEdBQUc7UUFDNVI7UUFFQSxTQUFTQztZQUNQLElBQUksQ0FBQyxJQUFJLENBQUNsQixtQkFBbUIsRUFBRTtnQkFDN0IsSUFBSSxDQUFDbUIsU0FBUyxHQUFHLENBQUUsS0FBSSxDQUFDdkQsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEVBQUUsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFLLElBQUksQ0FBQ0EsS0FBSyxDQUFDLEdBQUcsS0FBSyxLQUFL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ZUUsZ0JBQWdCLENBQUMsTUFBTW1PLHFCQUFxQixnQ0FBZ0M7SUFFM0Z4a0MscUJBQXFCeXNFO0lBQ3JCdnNFLHdCQUF3QjZ6RTtJQUN4QjBEO0lBQ0FNLGNBQWMsMEJBQTBCO0lBRXhDbGdDLGlCQUFpQixJQUFJMGdDLGVBQWU7SUFDcEMxZ0MsaUJBQWlCLElBQUkrZ0MsZUFBZTtJQUNwQy9nQyxpQkFBaUIsSUFBSWdoQyxpQkFBaUI7SUFDdENoaEMsaUJBQWlCLElBQUkyaEMsa0JBQWtCO0lBQ3ZDM2hDLGlCQUFpQixJQUFJc2lDLG9CQUFvQjtJQUN6Q3RpQyxpQkFBaUIsSUFBSXNqQyxxQkFBcUI7SUFDMUN0akMsaUJBQWlCLElBQUk4akMsaUJBQWlCO0lBQ3RDOWpDLGlCQUFpQixJQUFJdWtDLHVCQUF1QjtJQUM1Q3ZrQyxpQkFBaUIsSUFBSW1sQyxvQkFBb0I7SUFDekMxckIsZUFBZSxJQUFJMnJCO0lBRW5CLE9BQU85bkY7QUFFVCIsInNvdXJjZXMiOlsid2VicGFjazovL2dhcnVkYWhhY2tzLy4vbm9kZV9tb2R1bGVzL2xvdHRpZS13ZWIvYnVpbGQvcGxheWVyL2xvdHRpZS5qcz9jNzI2Il0sInNvdXJjZXNDb250ZW50IjpbIih0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiKSAmJiAoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5sb3R0aWUgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBzdmdOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gIHZhciBsb2NhdGlvbkhyZWYgPSAnJztcbiAgdmFyIF91c2VXZWJXb3JrZXIgPSBmYWxzZTtcbiAgdmFyIGluaXRpYWxEZWZhdWx0RnJhbWUgPSAtOTk5OTk5O1xuXG4gIHZhciBzZXRXZWJXb3JrZXIgPSBmdW5jdGlvbiBzZXRXZWJXb3JrZXIoZmxhZykge1xuICAgIF91c2VXZWJXb3JrZXIgPSAhIWZsYWc7XG4gIH07XG5cbiAgdmFyIGdldFdlYldvcmtlciA9IGZ1bmN0aW9uIGdldFdlYldvcmtlcigpIHtcbiAgICByZXR1cm4gX3VzZVdlYldvcmtlcjtcbiAgfTtcblxuICB2YXIgc2V0TG9jYXRpb25IcmVmID0gZnVuY3Rpb24gc2V0TG9jYXRpb25IcmVmKHZhbHVlKSB7XG4gICAgbG9jYXRpb25IcmVmID0gdmFsdWU7XG4gIH07XG5cbiAgdmFyIGdldExvY2F0aW9uSHJlZiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgICByZXR1cm4gbG9jYXRpb25IcmVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZShzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgc291cmNlUHJvdG90eXBlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzb3VyY2VQcm90b3R5cGUgPSBzb3VyY2VzW2ldLnByb3RvdHlwZTtcblxuICAgICAgZm9yICh2YXIgYXR0ciBpbiBzb3VyY2VQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2VQcm90b3R5cGUsIGF0dHIpKSBkZXN0aW5hdGlvbi5wcm90b3R5cGVbYXR0cl0gPSBzb3VyY2VQcm90b3R5cGVbYXR0cl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBQcm94eUZ1bmN0aW9uKCkge31cblxuICAgIFByb3h5RnVuY3Rpb24ucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHJldHVybiBQcm94eUZ1bmN0aW9uO1xuICB9XG5cbiAgLy8gaW1wb3J0IEhvd2wgZnJvbSAnLi4vLi4vM3JkX3BhcnR5L2hvd2xlcic7XG4gIHZhciBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1ZGlvQ29udHJvbGxlcihhdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9zID0gW107XG4gICAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcbiAgICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgQXVkaW9Db250cm9sbGVyLnByb3RvdHlwZSA9IHtcbiAgICAgIGFkZEF1ZGlvOiBmdW5jdGlvbiBhZGRBdWRpbyhhdWRpbykge1xuICAgICAgICB0aGlzLmF1ZGlvcy5wdXNoKGF1ZGlvKTtcbiAgICAgIH0sXG4gICAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXRSYXRlOiBmdW5jdGlvbiBzZXRSYXRlKHJhdGVWYWx1ZSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuYXVkaW9zLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS5zZXRSYXRlKHJhdGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjcmVhdGVBdWRpbzogZnVuY3Rpb24gY3JlYXRlQXVkaW8oYXNzZXRQYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLmF1ZGlvRmFjdG9yeSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmF1ZGlvRmFjdG9yeShhc3NldFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHdpbmRvdy5Ib3dsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuSG93bCh7XG4gICAgICAgICAgICBzcmM6IFthc3NldFBhdGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzUGxheWluZzogZmFsc2UsXG4gICAgICAgICAgcGxheTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNlZWs6IGZ1bmN0aW9uIHNlZWsoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcGxheWluZzogZnVuY3Rpb24gcGxheWluZygpIHt9LFxuICAgICAgICAgIHJhdGU6IGZ1bmN0aW9uIHJhdGUoKSB7fSxcbiAgICAgICAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uIHNldFZvbHVtZSgpIHt9XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2V0QXVkaW9GYWN0b3J5OiBmdW5jdGlvbiBzZXRBdWRpb0ZhY3RvcnkoYXVkaW9GYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuYXVkaW9GYWN0b3J5ID0gYXVkaW9GYWN0b3J5O1xuICAgICAgfSxcbiAgICAgIHNldFZvbHVtZTogZnVuY3Rpb24gc2V0Vm9sdW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIG11dGU6IGZ1bmN0aW9uIG11dGUoKSB7XG4gICAgICAgIHRoaXMuX2lzTXV0ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIHVubXV0ZTogZnVuY3Rpb24gdW5tdXRlKCkge1xuICAgICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgZ2V0Vm9sdW1lOiBmdW5jdGlvbiBnZXRWb2x1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XG4gICAgICB9LFxuICAgICAgX3VwZGF0ZVZvbHVtZTogZnVuY3Rpb24gX3VwZGF0ZVZvbHVtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgdGhpcy5hdWRpb3NbaV0udm9sdW1lKHRoaXMuX3ZvbHVtZSAqICh0aGlzLl9pc011dGVkID8gMCA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgQXVkaW9Db250cm9sbGVyKCk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBjcmVhdGVUeXBlZEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBhcnIgPSBbXTtcbiAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgY2FzZSAndWludDhjJzpcbiAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IDEuMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFyci5wdXNoKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeSh0eXBlLCBsZW4pIHtcbiAgICAgIGlmICh0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09ICdpbnQxNicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSAndWludDhjJykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVSZWd1bGFyQXJyYXkodHlwZSwgbGVuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5RmFjdG9yeTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVndWxhckFycmF5O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2l6ZWRBcnJheShsZW4pIHtcbiAgICByZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwge1xuICAgICAgbGVuZ3RoOiBsZW5cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ2ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDYob2JqKTsgfVxuICB2YXIgc3ViZnJhbWVFbmFibGVkID0gdHJ1ZTtcbiAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gbnVsbDtcbiAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IG51bGw7XG4gIHZhciBpZFByZWZpeCQxID0gJyc7XG4gIHZhciBpc1NhZmFyaSA9IC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIHZhciBfc2hvdWxkUm91bmRWYWx1ZXMgPSBmYWxzZTtcbiAgdmFyIGJtUG93ID0gTWF0aC5wb3c7XG4gIHZhciBibVNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciBibUZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGJtTWF4ID0gTWF0aC5tYXg7XG4gIHZhciBibU1pbiA9IE1hdGgubWluO1xuICB2YXIgQk1NYXRoID0ge307XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IFsnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2F0YW4yJywgJ2NlaWwnLCAnY2JydCcsICdleHBtMScsICdjbHozMicsICdjb3MnLCAnY29zaCcsICdleHAnLCAnZmxvb3InLCAnZnJvdW5kJywgJ2h5cG90JywgJ2ltdWwnLCAnbG9nJywgJ2xvZzFwJywgJ2xvZzInLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdwb3cnLCAncmFuZG9tJywgJ3JvdW5kJywgJ3NpZ24nLCAnc2luJywgJ3NpbmgnLCAnc3FydCcsICd0YW4nLCAndGFuaCcsICd0cnVuYycsICdFJywgJ0xOMTAnLCAnTE4yJywgJ0xPRzEwRScsICdMT0cyRScsICdQSScsICdTUVJUMV8yJywgJ1NRUlQyJ107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBCTU1hdGhbcHJvcGVydHlOYW1lc1tpXV0gPSBNYXRoW3Byb3BlcnR5TmFtZXNbaV1dO1xuICAgIH1cbiAgfSkoKTtcblxuICBmdW5jdGlvbiBQcm9qZWN0SW50ZXJmYWNlJDEoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgQk1NYXRoLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gIEJNTWF0aC5hYnMgPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgdmFyIHRPZlZhbCA9IF90eXBlb2YkNih2YWwpO1xuXG4gICAgaWYgKHRPZlZhbCA9PT0gJ29iamVjdCcgJiYgdmFsLmxlbmd0aCkge1xuICAgICAgdmFyIGFic0FyciA9IGNyZWF0ZVNpemVkQXJyYXkodmFsLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWJzQXJyW2ldID0gTWF0aC5hYnModmFsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFic0FycjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5hYnModmFsKTtcbiAgfTtcblxuICB2YXIgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxNTA7XG4gIHZhciBkZWdUb1JhZHMgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XG5cbiAgZnVuY3Rpb24gcm91bmRWYWx1ZXMoZmxhZykge1xuICAgIF9zaG91bGRSb3VuZFZhbHVlcyA9ICEhZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGJtUm5kKHZhbHVlKSB7XG4gICAgaWYgKF9zaG91bGRSb3VuZFZhbHVlcykge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0eWxlRGl2KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbGVtZW50LnN0eWxlLnRvcCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5sZWZ0ID0gMDtcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSAnMCAwJztcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgICBlbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybVN0eWxlID0gJ3ByZXNlcnZlLTNkJztcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNRW50ZXJGcmFtZUV2ZW50KHR5cGUsIGN1cnJlbnRUaW1lLCB0b3RhbFRpbWUsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHRoaXMudG90YWxUaW1lID0gdG90YWxUaW1lO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudCh0eXBlLCBmcmFtZU11bHRpcGxpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVMb29wRXZlbnQodHlwZSwgdG90YWxMb29wcywgY3VycmVudExvb3AsIGZyYW1lTXVsdGlwbGllcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5jdXJyZW50TG9vcCA9IGN1cnJlbnRMb29wO1xuICAgIHRoaXMudG90YWxMb29wcyA9IHRvdGFsTG9vcHM7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG5cbiAgZnVuY3Rpb24gQk1TZWdtZW50U3RhcnRFdmVudCh0eXBlLCBmaXJzdEZyYW1lLCB0b3RhbEZyYW1lcykge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcbiAgICB0aGlzLnRvdGFsRnJhbWVzID0gdG90YWxGcmFtZXM7XG4gIH1cblxuICBmdW5jdGlvbiBCTURlc3Ryb3lFdmVudCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQobmF0aXZlRXJyb3IsIGN1cnJlbnRUaW1lKSB7XG4gICAgdGhpcy50eXBlID0gJ3JlbmRlckZyYW1lRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBCTUNvbmZpZ0Vycm9yRXZlbnQobmF0aXZlRXJyb3IpIHtcbiAgICB0aGlzLnR5cGUgPSAnY29uZmlnRXJyb3InO1xuICAgIHRoaXMubmF0aXZlRXJyb3IgPSBuYXRpdmVFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCh0eXBlLCBuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG5cbiAgdmFyIGNyZWF0ZUVsZW1lbnRJRCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ID0gMDtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlSUQoKSB7XG4gICAgICBfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiBpZFByZWZpeCQxICsgJ19fbG90dGllX2VsZW1lbnRfJyArIF9jb3VudDtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xuICAgIHZhciByO1xuICAgIHZhciBnO1xuICAgIHZhciBiO1xuICAgIHZhciBpO1xuICAgIHZhciBmO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuICAgIHZhciB0O1xuICAgIGkgPSBNYXRoLmZsb29yKGggKiA2KTtcbiAgICBmID0gaCAqIDYgLSBpO1xuICAgIHAgPSB2ICogKDEgLSBzKTtcbiAgICBxID0gdiAqICgxIC0gZiAqIHMpO1xuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG5cbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gdDtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIHIgPSBxO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gdjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gcTtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHIgPSB0O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDU6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gcDtcbiAgICAgICAgYiA9IHE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gW3IsIGcsIGJdO1xuICB9XG5cbiAgZnVuY3Rpb24gUkdCdG9IU1YociwgZywgYikge1xuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICB2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgdmFyIGg7XG4gICAgdmFyIHMgPSBtYXggPT09IDAgPyAwIDogZCAvIG1heDtcbiAgICB2YXIgdiA9IG1heCAvIDI1NTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIG1pbjpcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSBnIC0gYiArIGQgKiAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGggLz0gNiAqIGQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSBiIC0gciArIGQgKiAyO1xuICAgICAgICBoIC89IDYgKiBkO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gciAtIGcgKyBkICogNDtcbiAgICAgICAgaCAvPSA2ICogZDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBbaCwgcywgdl07XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTYXR1cmF0aW9uVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMV0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsxXSA+IDEpIHtcbiAgICAgIGhzdlsxXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMV0gPD0gMCkge1xuICAgICAgaHN2WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLCBoc3ZbMV0sIGhzdlsyXSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMl0gKz0gb2Zmc2V0O1xuXG4gICAgaWYgKGhzdlsyXSA+IDEpIHtcbiAgICAgIGhzdlsyXSA9IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMl0gPCAwKSB7XG4gICAgICBoc3ZbMl0gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEh1ZVRvUkdCKGNvbG9yLCBvZmZzZXQpIHtcbiAgICB2YXIgaHN2ID0gUkdCdG9IU1YoY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSk7XG4gICAgaHN2WzBdICs9IG9mZnNldCAvIDM2MDtcblxuICAgIGlmIChoc3ZbMF0gPiAxKSB7XG4gICAgICBoc3ZbMF0gLT0gMTtcbiAgICB9IGVsc2UgaWYgKGhzdlswXSA8IDApIHtcbiAgICAgIGhzdlswXSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuXG4gIHZhciByZ2JUb0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29sb3JNYXAgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgaGV4O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gICAgICBoZXggPSBpLnRvU3RyaW5nKDE2KTtcbiAgICAgIGNvbG9yTWFwW2ldID0gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICByID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgIGcgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgYiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnIycgKyBjb2xvck1hcFtyXSArIGNvbG9yTWFwW2ddICsgY29sb3JNYXBbYl07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBzZXRTdWJmcmFtZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZykge1xuICAgIHN1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcbiAgfTtcblxuICB2YXIgZ2V0U3ViZnJhbWVFbmFibGVkID0gZnVuY3Rpb24gZ2V0U3ViZnJhbWVFbmFibGVkKCkge1xuICAgIHJldHVybiBzdWJmcmFtZUVuYWJsZWQ7XG4gIH07XG5cbiAgdmFyIHNldEV4cHJlc3Npb25zUGx1Z2luID0gZnVuY3Rpb24gc2V0RXhwcmVzc2lvbnNQbHVnaW4odmFsdWUpIHtcbiAgICBleHByZXNzaW9uc1BsdWdpbiA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uc1BsdWdpbiA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25zUGx1Z2luKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc1BsdWdpbjtcbiAgfTtcblxuICB2YXIgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMgPSBmdW5jdGlvbiBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyh2YWx1ZSkge1xuICAgIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXRFeHByZXNzaW9uSW50ZXJmYWNlcyA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc0ludGVyZmFjZXM7XG4gIH07XG5cbiAgdmFyIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpIHtcbiAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IHZhbHVlO1xuICB9O1xuXG4gIHZhciBnZXREZWZhdWx0Q3VydmVTZWdtZW50cyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkge1xuICAgIHJldHVybiBkZWZhdWx0Q3VydmVTZWdtZW50cztcbiAgfTtcblxuICB2YXIgc2V0SWRQcmVmaXggPSBmdW5jdGlvbiBzZXRJZFByZWZpeCh2YWx1ZSkge1xuICAgIGlkUHJlZml4JDEgPSB2YWx1ZTtcbiAgfTtcblxuICB2YXIgZ2V0SWRQcmVmaXggPSBmdW5jdGlvbiBnZXRJZFByZWZpeCgpIHtcbiAgICByZXR1cm4gaWRQcmVmaXgkMTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVOUyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNShvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQ1ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkNSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDUob2JqKTsgfVxuXG4gIHZhciBkYXRhTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2NvdW50ZXJJZCA9IDE7XG4gICAgdmFyIHByb2Nlc3NlcyA9IFtdO1xuICAgIHZhciB3b3JrZXJGbjtcbiAgICB2YXIgd29ya2VySW5zdGFuY2U7XG4gICAgdmFyIHdvcmtlclByb3h5ID0ge1xuICAgICAgb25tZXNzYWdlOiBmdW5jdGlvbiBvbm1lc3NhZ2UoKSB7fSxcbiAgICAgIHBvc3RNZXNzYWdlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShwYXRoKSB7XG4gICAgICAgIHdvcmtlckZuKHtcbiAgICAgICAgICBkYXRhOiBwYXRoXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIF93b3JrZXJTZWxmID0ge1xuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgd29ya2VyUHJveHkub25tZXNzYWdlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICAgIGlmICh3aW5kb3cuV29ya2VyICYmIHdpbmRvdy5CbG9iICYmIGdldFdlYldvcmtlcigpKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWyd2YXIgX3dvcmtlclNlbGYgPSBzZWxmOyBzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7XG4gICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICAgfSk7IC8vIHZhciBibG9iID0gbmV3IEJsb2IoWydzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuXG4gICAgICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcih1cmwpO1xuICAgICAgfVxuXG4gICAgICB3b3JrZXJGbiA9IGZuO1xuICAgICAgcmV0dXJuIHdvcmtlclByb3h5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwV29ya2VyKCkge1xuICAgICAgaWYgKCF3b3JrZXJJbnN0YW5jZSkge1xuICAgICAgICB3b3JrZXJJbnN0YW5jZSA9IGNyZWF0ZVdvcmtlcihmdW5jdGlvbiB3b3JrZXJTdGFydChlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZGF0YUZ1bmN0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlTGF5ZXJzKGxheWVycywgY29tcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICB2YXIga0xlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBsYXllckRhdGEgPSBsYXllcnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoJ2tzJyBpbiBsYXllckRhdGEgJiYgIWxheWVyRGF0YS5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5jb21wbGV0ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0LmsuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhtYXNrUHJvcHNbal0ucHQuayk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGlmIChsYXllckRhdGEudHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmxheWVycyA9IGZpbmRDb21wTGF5ZXJzKGxheWVyRGF0YS5yZWZJZCwgY29tcHMpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhsYXllckRhdGEubGF5ZXJzLCBjb21wcyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGF0YS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJEYXRhLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVGV4dChsYXllckRhdGEpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZUNoYXJzKGNoYXJzLCBhc3NldHMpIHtcbiAgICAgICAgICAgICAgaWYgKGNoYXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBjaGFycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyc1tpXS50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21wRGF0YSA9IGZpbmRDb21wKGNoYXJzW2ldLmRhdGEucmVmSWQsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzW2ldLmRhdGEubGF5ZXJzID0gZmluZENvbXBMYXllcnMoY2hhcnNbaV0uZGF0YS5yZWZJZCwgYXNzZXRzKTsgLy8gY2hhcnNbaV0uZGF0YS5pcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEub3AgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEuc3IgPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS53ID0gY29tcERhdGEudztcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBhOiB7IGs6IFswLCAwLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHA6IHsgazogWzAsIC1jb21wRGF0YS5oLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHI6IHsgazogMCwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHM6IHsgazogWzEwMCwgMTAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG86IHsgazogMTAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XG5cbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoY2hhcnNbaV0uZGF0YS5sYXllcnMsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBjb21wcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHNbaV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wTGF5ZXJzKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgY29tcCA9IGZpbmRDb21wKGlkLCBjb21wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXAubGF5ZXJzLl9fdXNlZCkge1xuICAgICAgICAgICAgICAgICAgY29tcC5sYXllcnMuX191c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmxheWVycztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb21wLmxheWVycykpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlU2hhcGVzKGFycikge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChhcnJbaV0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmspO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uZVswXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGFycltpXS5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMocGF0aCkge1xuICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IHBhdGguaS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5pW2ldWzBdICs9IHBhdGgudltpXVswXTtcbiAgICAgICAgICAgICAgICBwYXRoLmlbaV1bMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgICAgICAgICAgICAgIHBhdGgub1tpXVswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICAgICAgICAgICAgcGF0aC5vW2ldWzFdICs9IHBhdGgudltpXVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obWluaW11bSwgYW5pbVZlcnNpb25TdHJpbmcpIHtcbiAgICAgICAgICAgICAgdmFyIGFuaW1WZXJzaW9uID0gYW5pbVZlcnNpb25TdHJpbmcgPyBhbmltVmVyc2lvblN0cmluZy5zcGxpdCgnLicpIDogWzEwMCwgMTAwLCAxMDBdO1xuXG4gICAgICAgICAgICAgIGlmIChtaW5pbXVtWzBdID4gYW5pbVZlcnNpb25bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblswXSA+IG1pbmltdW1bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobWluaW11bVsxXSA+IGFuaW1WZXJzaW9uWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoYW5pbVZlcnNpb25bMV0gPiBtaW5pbXVtWzFdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMl0gPiBhbmltVmVyc2lvblsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFuaW1WZXJzaW9uWzJdID4gbWluaW11bVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hlY2tUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMTRdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnREYXRhID0gdGV4dExheWVyLnQuZDtcbiAgICAgICAgICAgICAgICB0ZXh0TGF5ZXIudC5kID0ge1xuICAgICAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICAgICAgczogZG9jdW1lbnREYXRhLFxuICAgICAgICAgICAgICAgICAgICB0OiAwXG4gICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ2hhcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LCA3LCA5OV07XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmNoYXJzICYmICFjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuY2hhcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gYW5pbWF0aW9uRGF0YS5jaGFyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGNoYXJEYXRhLmRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLmlwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLm9wID0gOTk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFuaW1hdGlvbkRhdGEuY2hhcnNbaV0udCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zaGFwZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5OiAnbm8nXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEuc2hhcGVzWzBdLml0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFsxMDAsIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2s6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHk6ICd0cidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrUGF0aFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs1LCA3LCAxNV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRleHRMYXllci50LnA7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhdGhEYXRhLmEgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICBwYXRoRGF0YS5hID0ge1xuICAgICAgICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICAgICAgICBrOiBwYXRoRGF0YS5hXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0aERhdGEucCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhEYXRhLnAgPSB7XG4gICAgICAgICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgICAgICAgIGs6IHBhdGhEYXRhLnBcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEuciA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEuclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgMSwgOV07XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZVNoYXBlcyhzaGFwZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKHNoYXBlc1tpXS5pdCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJyB8fCBzaGFwZXNbaV0udHkgPT09ICdzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmsgJiYgc2hhcGVzW2ldLmMua1swXS5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IHNoYXBlc1tpXS5jLmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVswXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsxXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsyXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVszXSAvPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyc1tpXS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgdmFyIGNoZWNrU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMThdO1xuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgICB2YXIgakxlbjtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmsuYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLnNbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLmVbMF0uYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZUNsb3NpbmdTaGFwZXMoYXJyW2ldLml0KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgdmFyIGtMZW47XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGxheWVyRGF0YSA9IGxheWVyc1tpXTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyRGF0YS5oYXNNYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICBqTGVuID0gbWFza1Byb3BzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQua1trXS5zWzBdLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0uYyA9IG1hc2tQcm9wc1tqXS5jbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlRGF0YShhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLl9fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjaGVja0NvbG9ycyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY2hlY2tUZXh0KGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja0NoYXJzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1BhdGhQcm9wZXJ0aWVzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1NoYXBlcyhhbmltYXRpb25EYXRhKTtcbiAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzKTtcbiAgICAgICAgICAgICAgY29tcGxldGVDaGFycyhhbmltYXRpb25EYXRhLmNoYXJzLCBhbmltYXRpb25EYXRhLmFzc2V0cyk7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLnQuYS5sZW5ndGggPT09IDAgJiYgISgnbScgaW4gZGF0YS50LnApKSB7Ly8gZGF0YS5zaW5nbGVTaGFwZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1vZHVsZU9iID0ge307XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZURhdGEgPSBjb21wbGV0ZURhdGE7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja0NvbG9ycyA9IGNoZWNrQ29sb3JzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tDaGFycyA9IGNoZWNrQ2hhcnM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja1BhdGhQcm9wZXJ0aWVzID0gY2hlY2tQYXRoUHJvcGVydGllcztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrU2hhcGVzID0gY2hlY2tTaGFwZXM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jb21wbGV0ZUxheWVycyA9IGNvbXBsZXRlTGF5ZXJzO1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZU9iO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyID0gZGF0YUZ1bmN0aW9uTWFuYWdlcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSZXNwb25zZSh4aHIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0eXBlb2YgZG91YmxlcyB0aGUgdGltZSBvZiBleGVjdXRpb24gb2YgdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYXZhaWxhYmxlLCBpdCdzIGJldHRlciB0byB1c2UgdGhlIGhlYWRlciB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudFR5cGVIZWFkZXIgJiYgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nICYmIGNvbnRlbnRUeXBlSGVhZGVyLmluZGV4T2YoJ2pzb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiBfdHlwZW9mJDUoeGhyLnJlc3BvbnNlKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBmdW5jdGlvbiBsb2FkQXNzZXQocGF0aCwgZnVsbFBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsgLy8gc2V0IHJlc3BvbnNlVHlwZSBhZnRlciBjYWxsaW5nIG9wZW4gb3IgSUUgd2lsbCBicmVhay5cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGNyYXNoZXMgb24gQW5kcm9pZCBXZWJWaWV3IHByaW9yIHRvIEtpdEthdFxuICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxuXG4gICAgICAgICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gSGFjayB0byB3b3JrYXJvdW5kIGJhbm5lciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICB4aHIub3BlbihbJ0cnLCAnRScsICdUJ10uam9pbignJyksIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHdvcmthcm91bmQgYmFubmVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFsnRycsICdFJywgJ1QnXS5qb2luKCcnKSwgZnVsbFBhdGggKyAnLycgKyBwYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb2FkOiBsb2FkQXNzZXRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkQW5pbWF0aW9uJykge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIubG9hZChlLmRhdGEucGF0aCwgZS5kYXRhLmZ1bGxQYXRoLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5kYXRhTWFuYWdlci5jb21wbGV0ZURhdGEoZGF0YSk7XG5cbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IGUuZGF0YS5hbmltYXRpb247XG5cbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmRhdGFNYW5hZ2VyLmNvbXBsZXRlRGF0YShhbmltYXRpb24pO1xuXG4gICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkRGF0YScpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyLmxvYWQoZS5kYXRhLnBhdGgsIGUuZGF0YS5mdWxsUGF0aCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB3b3JrZXJJbnN0YW5jZS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgdmFyIGlkID0gZGF0YS5pZDtcbiAgICAgICAgICB2YXIgcHJvY2VzcyA9IHByb2Nlc3Nlc1tpZF07XG4gICAgICAgICAgcHJvY2Vzc2VzW2lkXSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoZGF0YS5zdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbkNvbXBsZXRlKGRhdGEucGF5bG9hZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLm9uRXJyb3IpIHtcbiAgICAgICAgICAgIHByb2Nlc3Mub25FcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIF9jb3VudGVySWQgKz0gMTtcbiAgICAgIHZhciBpZCA9ICdwcm9jZXNzSWRfJyArIF9jb3VudGVySWQ7XG4gICAgICBwcm9jZXNzZXNbaWRdID0ge1xuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRBbmltYXRpb24ocGF0aCwgb25Db21wbGV0ZSwgb25FcnJvcikge1xuICAgICAgc2V0dXBXb3JrZXIoKTtcbiAgICAgIHZhciBwcm9jZXNzSWQgPSBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpO1xuICAgICAgd29ya2VySW5zdGFuY2UucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eXBlOiAnbG9hZEFuaW1hdGlvbicsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkRGF0YShwYXRoLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdsb2FkRGF0YScsXG4gICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgIGZ1bGxQYXRoOiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBpZDogcHJvY2Vzc0lkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFuaW1hdGlvbihhbmltLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdjb21wbGV0ZScsXG4gICAgICAgIGFuaW1hdGlvbjogYW5pbSxcbiAgICAgICAgaWQ6IHByb2Nlc3NJZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRBbmltYXRpb246IGxvYWRBbmltYXRpb24sXG4gICAgICBsb2FkRGF0YTogbG9hZERhdGEsXG4gICAgICBjb21wbGV0ZUFuaW1hdGlvbjogY29tcGxldGVBbmltYXRpb25cbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIEltYWdlUHJlbG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm94eUltYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSAxO1xuICAgICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcbiAgICAgIHRoaXMubG9hZGVkQXNzZXRzICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb290YWdlTG9hZGVkKCkge1xuICAgICAgdGhpcy5sb2FkZWRGb290YWdlc0NvdW50ICs9IDE7XG5cbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgYXNzZXRzUGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICB2YXIgcGF0aCA9ICcnO1xuXG4gICAgICBpZiAoYXNzZXREYXRhLmUpIHtcbiAgICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgICAgfSBlbHNlIGlmIChhc3NldHNQYXRoKSB7XG4gICAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcblxuICAgICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcbiAgICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBhc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3RJbWFnZUxvYWRlZChpbWcpIHtcbiAgICAgIHZhciBfY291bnQgPSAwO1xuICAgICAgdmFyIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib3ggPSBpbWcuZ2V0QkJveCgpO1xuXG4gICAgICAgIGlmIChib3gud2lkdGggfHwgX2NvdW50ID4gNTAwKSB7XG4gICAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcblxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cblxuICAgICAgICBfY291bnQgKz0gMTtcbiAgICAgIH0uYmluZCh0aGlzKSwgNTApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVOUygnaW1hZ2UnKTtcblxuICAgICAgaWYgKGlzU2FmYXJpKSB7XG4gICAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkKGltZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcblxuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBpbWcuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudEhlbHBlci5hcHBlbmQoaW1nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgYXNzZXREYXRhOiBhc3NldERhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1nRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVUYWcoJ2ltZycpO1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHByb3h5SW1hZ2U7XG5cbiAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgICAgaW1nLnNyYyA9IHBhdGg7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGltZzogaW1nLFxuICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGb290YWdlRGF0YShkYXRhKSB7XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGFzc2V0RGF0YTogZGF0YVxuICAgICAgfTtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChkYXRhLCB0aGlzLmFzc2V0c1BhdGgsIHRoaXMucGF0aCk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkRGF0YShwYXRoLCBmdW5jdGlvbiAoZm9vdGFnZURhdGEpIHtcbiAgICAgICAgb2IuaW1nID0gZm9vdGFnZURhdGE7XG5cbiAgICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2Zvb3RhZ2VMb2FkZWQoKTtcbiAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldHMsIGNiKSB7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gY2I7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCFhc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKCFhc3NldHNbaV0udCB8fCBhc3NldHNbaV0udCA9PT0gJ3NlcScpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXRzW2ldLnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxGb290YWdlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBhdGgocGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRBc3NldHNQYXRoKHBhdGgpIHtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhdGggfHwgJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQoYXNzZXREYXRhKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5pbWFnZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNbaV0uYXNzZXREYXRhID09PSBhc3NldERhdGEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaV0uaW1nO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRlZEltYWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsSW1hZ2VzID09PSB0aGlzLmxvYWRlZEFzc2V0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkZWRGb290YWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsRm9vdGFnZXMgPT09IHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRDYWNoZVR5cGUodHlwZSwgZWxlbWVudEhlbHBlcikge1xuICAgICAgaWYgKHR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIgPSBlbGVtZW50SGVscGVyO1xuICAgICAgICB0aGlzLl9jcmVhdGVJbWFnZURhdGEgPSB0aGlzLmNyZWF0ZUltYWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gdGhpcy5jcmVhdGVJbWdEYXRhLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gSW1hZ2VQcmVsb2FkZXJGYWN0b3J5KCkge1xuICAgICAgdGhpcy5faW1hZ2VMb2FkZWQgPSBpbWFnZUxvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCA9IGZvb3RhZ2VMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMudGVzdEltYWdlTG9hZGVkID0gdGVzdEltYWdlTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhID0gY3JlYXRlRm9vdGFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xuICAgICAgdGhpcy5wYXRoID0gJyc7XG4gICAgICB0aGlzLnRvdGFsSW1hZ2VzID0gMDtcbiAgICAgIHRoaXMudG90YWxGb290YWdlcyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEFzc2V0cyA9IDA7XG4gICAgICB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPSAwO1xuICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYiA9IG51bGw7XG4gICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIH1cblxuICAgIEltYWdlUHJlbG9hZGVyRmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICBsb2FkQXNzZXRzOiBsb2FkQXNzZXRzLFxuICAgICAgc2V0QXNzZXRzUGF0aDogc2V0QXNzZXRzUGF0aCxcbiAgICAgIHNldFBhdGg6IHNldFBhdGgsXG4gICAgICBsb2FkZWRJbWFnZXM6IGxvYWRlZEltYWdlcyxcbiAgICAgIGxvYWRlZEZvb3RhZ2VzOiBsb2FkZWRGb290YWdlcyxcbiAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBnZXRBc3NldDogZ2V0QXNzZXQsXG4gICAgICBjcmVhdGVJbWdEYXRhOiBjcmVhdGVJbWdEYXRhLFxuICAgICAgY3JlYXRlSW1hZ2VEYXRhOiBjcmVhdGVJbWFnZURhdGEsXG4gICAgICBpbWFnZUxvYWRlZDogaW1hZ2VMb2FkZWQsXG4gICAgICBmb290YWdlTG9hZGVkOiBmb290YWdlTG9hZGVkLFxuICAgICAgc2V0Q2FjaGVUeXBlOiBzZXRDYWNoZVR5cGVcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVByZWxvYWRlckZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBCYXNlRXZlbnQoKSB7fVxuXG4gIEJhc2VFdmVudC5wcm90b3R5cGUgPSB7XG4gICAgdHJpZ2dlckV2ZW50OiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2Nic1tldmVudE5hbWVdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9LFxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIG1hcmtlclBhcnNlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBwYXJzZVBheWxvYWRMaW5lcyhwYXlsb2FkKSB7XG4gICAgICB2YXIgbGluZXMgPSBwYXlsb2FkLnNwbGl0KCdcXHJcXG4nKTtcbiAgICAgIHZhciBrZXlzID0ge307XG4gICAgICB2YXIgbGluZTtcbiAgICAgIHZhciBrZXlzQ291bnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1tpXS5zcGxpdCgnOicpO1xuXG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIGtleXNbbGluZVswXV0gPSBsaW5lWzFdLnRyaW0oKTtcbiAgICAgICAgICBrZXlzQ291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoa2V5c0NvdW50ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKF9tYXJrZXJzKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBfbWFya2VyID0gX21hcmtlcnNbaV07XG4gICAgICAgIHZhciBtYXJrZXJEYXRhID0ge1xuICAgICAgICAgIHRpbWU6IF9tYXJrZXIudG0sXG4gICAgICAgICAgZHVyYXRpb246IF9tYXJrZXIuZHJcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IEpTT04ucGFyc2UoX21hcmtlcnNbaV0uY20pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IHBhcnNlUGF5bG9hZExpbmVzKF9tYXJrZXJzW2ldLmNtKTtcbiAgICAgICAgICB9IGNhdGNoIChfXykge1xuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0ge1xuICAgICAgICAgICAgICBuYW1lOiBfbWFya2Vyc1tpXS5jbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXJrZXJzLnB1c2gobWFya2VyRGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgUHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiByZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApIHtcbiAgICAgIHRoaXMuY29tcG9zaXRpb25zLnB1c2goY29tcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb21wb3NpdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS5ubSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLnh0KSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9zaXRpb25zW2ldLnByZXBhcmVGcmFtZSh0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5jb21wSW50ZXJmYWNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5jb21wb3NpdGlvbnMgPSBbXTtcbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgICBfdGhpc1Byb2plY3RGdW5jdGlvbi5yZWdpc3RlckNvbXBvc2l0aW9uID0gcmVnaXN0ZXJDb21wb3NpdGlvbjtcbiAgICAgIHJldHVybiBfdGhpc1Byb2plY3RGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJlbmRlcmVycyA9IHt9O1xuXG4gIHZhciByZWdpc3RlclJlbmRlcmVyID0gZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihrZXksIHZhbHVlKSB7XG4gICAgcmVuZGVyZXJzW2tleV0gPSB2YWx1ZTtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRSZW5kZXJlcihrZXkpIHtcbiAgICByZXR1cm4gcmVuZGVyZXJzW2tleV07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB7XG4gICAgLy8gUmV0dXJucyBjYW52YXMgYnkgZGVmYXVsdCBmb3IgY29tcGF0aWJpbGl0eVxuICAgIGlmIChyZW5kZXJlcnMuY2FudmFzKSB7XG4gICAgICByZXR1cm4gJ2NhbnZhcyc7XG4gICAgfSAvLyBSZXR1cm5zIGFueSByZW5kZXJlciB0aGF0IGlzIHJlZ2lzdGVyZWRcblxuXG4gICAgZm9yICh2YXIga2V5IGluIHJlbmRlcmVycykge1xuICAgICAgaWYgKHJlbmRlcmVyc1trZXldKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQ0KG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mJDQgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiQ0ID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2YkNChvYmopOyB9XG5cbiAgdmFyIEFuaW1hdGlvbkl0ZW0gPSBmdW5jdGlvbiBBbmltYXRpb25JdGVtKCkge1xuICAgIHRoaXMuX2NicyA9IFtdO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMucGF0aCA9ICcnO1xuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSAwO1xuICAgIHRoaXMuZmlyc3RGcmFtZSA9IDA7XG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIHRoaXMuZnJhbWVNdWx0ID0gMDtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IDE7XG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0ge307XG4gICAgdGhpcy5hc3NldHMgPSBbXTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmFuaW1hdGlvbklEID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gMDtcbiAgICB0aGlzLnNlZ21lbnRQb3MgPSAwO1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSBnZXRTdWJmcmFtZUVuYWJsZWQoKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMucHJvamVjdEludGVyZmFjZSA9IFByb2plY3RJbnRlcmZhY2UoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbmV3IEltYWdlUHJlbG9hZGVyKCk7XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIgPSBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5KCk7XG4gICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgdGhpcy5jb25maWdBbmltYXRpb24gPSB0aGlzLmNvbmZpZ0FuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZXR1cEVycm9yID0gdGhpcy5vblNldHVwRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uU2VnbWVudENvbXBsZXRlID0gdGhpcy5vblNlZ21lbnRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50ID0gbmV3IEJNRW50ZXJGcmFtZUV2ZW50KCdkcmF3bkZyYW1lJywgMCwgMCwgMCk7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IGdldEV4cHJlc3Npb25zUGx1Z2luKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRXZlbnRdLCBBbmltYXRpb25JdGVtKTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IHBhcmFtcy53cmFwcGVyIHx8IHBhcmFtcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1UeXBlID0gJ3N2Zyc7XG5cbiAgICBpZiAocGFyYW1zLmFuaW1UeXBlKSB7XG4gICAgICBhbmltVHlwZSA9IHBhcmFtcy5hbmltVHlwZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5yZW5kZXJlcikge1xuICAgICAgYW5pbVR5cGUgPSBwYXJhbXMucmVuZGVyZXI7XG4gICAgfVxuXG4gICAgdmFyIFJlbmRlcmVyQ2xhc3MgPSBnZXRSZW5kZXJlcihhbmltVHlwZSk7XG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlckNsYXNzKHRoaXMsIHBhcmFtcy5yZW5kZXJlclNldHRpbmdzKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldENhY2hlVHlwZShhbmltVHlwZSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvamVjdEludGVyZmFjZSh0aGlzLnByb2plY3RJbnRlcmZhY2UpO1xuICAgIHRoaXMuYW5pbVR5cGUgPSBhbmltVHlwZTtcblxuICAgIGlmIChwYXJhbXMubG9vcCA9PT0gJycgfHwgcGFyYW1zLmxvb3AgPT09IG51bGwgfHwgcGFyYW1zLmxvb3AgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMubG9vcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5sb29wID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9vcCA9IHBhcnNlSW50KHBhcmFtcy5sb29wLCAxMCk7XG4gICAgfVxuXG4gICAgdGhpcy5hdXRvcGxheSA9ICdhdXRvcGxheScgaW4gcGFyYW1zID8gcGFyYW1zLmF1dG9wbGF5IDogdHJ1ZTtcbiAgICB0aGlzLm5hbWUgPSBwYXJhbXMubmFtZSA/IHBhcmFtcy5uYW1lIDogJyc7XG4gICAgdGhpcy5hdXRvbG9hZFNlZ21lbnRzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgJ2F1dG9sb2FkU2VnbWVudHMnKSA/IHBhcmFtcy5hdXRvbG9hZFNlZ21lbnRzIDogdHJ1ZTtcbiAgICB0aGlzLmFzc2V0c1BhdGggPSBwYXJhbXMuYXNzZXRzUGF0aDtcbiAgICB0aGlzLmluaXRpYWxTZWdtZW50ID0gcGFyYW1zLmluaXRpYWxTZWdtZW50O1xuXG4gICAgaWYgKHBhcmFtcy5hdWRpb0ZhY3RvcnkpIHtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnNldEF1ZGlvRmFjdG9yeShwYXJhbXMuYXVkaW9GYWN0b3J5KTtcbiAgICB9XG5cbiAgICBpZiAocGFyYW1zLmFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIHRoaXMuc2V0dXBBbmltYXRpb24ocGFyYW1zLmFuaW1hdGlvbkRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBhdGgpIHtcbiAgICAgIGlmIChwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGFyYW1zLnBhdGguc3Vic3RyKDAsIHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxlTmFtZSA9IHBhcmFtcy5wYXRoLnN1YnN0cihwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlTmFtZS5zdWJzdHIoMCwgdGhpcy5maWxlTmFtZS5sYXN0SW5kZXhPZignLmpzb24nKSk7XG4gICAgICBkYXRhTWFuYWdlci5sb2FkQW5pbWF0aW9uKHBhcmFtcy5wYXRoLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbiwgdGhpcy5vblNldHVwRXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5vblNldHVwRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldHVwQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhTWFuYWdlci5jb21wbGV0ZUFuaW1hdGlvbihkYXRhLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhbmltYXRpb25EYXRhKSB7XG4gICAgaWYgKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmIChfdHlwZW9mJDQoYW5pbWF0aW9uRGF0YSkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFuaW1hdGlvbkRhdGEgPSBKU09OLnBhcnNlKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICB3cmFwcGVyOiB3cmFwcGVyLFxuICAgICAgYW5pbWF0aW9uRGF0YTogYW5pbWF0aW9uRGF0YVxuICAgIH07XG4gICAgdmFyIHdyYXBwZXJBdHRyaWJ1dGVzID0gd3JhcHBlci5hdHRyaWJ1dGVzO1xuICAgIHBhcmFtcy5wYXRoID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXBhdGgnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpLnZhbHVlIDogJyc7XG4gICAgcGFyYW1zLmFuaW1UeXBlID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXJlbmRlcmVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXJlbmRlcmVyJykudmFsdWUgOiBnZXRSZWdpc3RlcmVkUmVuZGVyZXIoKSB8fCAnY2FudmFzJztcbiAgICB2YXIgbG9vcCA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWxvb3AnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpLnZhbHVlIDogJyc7XG5cbiAgICBpZiAobG9vcCA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvb3AgPT09ICd0cnVlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobG9vcCAhPT0gJycpIHtcbiAgICAgIHBhcmFtcy5sb29wID0gcGFyc2VJbnQobG9vcCwgMTApO1xuICAgIH1cblxuICAgIHZhciBhdXRvcGxheSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tYXV0b3BsYXknKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpLnZhbHVlIDogdHJ1ZTtcbiAgICBwYXJhbXMuYXV0b3BsYXkgPSBhdXRvcGxheSAhPT0gJ2ZhbHNlJztcbiAgICBwYXJhbXMubmFtZSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1uYW1lJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJykudmFsdWUgOiAnJztcbiAgICB2YXIgcHJlcmVuZGVyID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXByZXJlbmRlcicpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wcmVyZW5kZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykudmFsdWUgOiAnJztcblxuICAgIGlmIChwcmVyZW5kZXIgPT09ICdmYWxzZScpIHtcbiAgICAgIHBhcmFtcy5wcmVyZW5kZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5wYXRoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaW5jbHVkZUxheWVycyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEub3AgPiB0aGlzLmFuaW1hdGlvbkRhdGEub3ApIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YS5vcCA9IGRhdGEub3A7XG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcihkYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5hbmltYXRpb25EYXRhLmxheWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbmV3TGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChsYXllcnNbaV0uaWQgPT09IG5ld0xheWVyc1tqXS5pZCkge1xuICAgICAgICAgIGxheWVyc1tpXSA9IG5ld0xheWVyc1tqXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jaGFycyB8fCBkYXRhLmZvbnRzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoZGF0YS5jaGFycyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkRm9udHMoZGF0YS5mb250cywgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmFzc2V0cykge1xuICAgICAgbGVuID0gZGF0YS5hc3NldHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cy5wdXNoKGRhdGEuYXNzZXRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlQW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5vblNlZ21lbnRDb21wbGV0ZSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUub25TZWdtZW50Q29tcGxldGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGRhdGE7XG4gICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgIGlmIChleHByZXNzaW9uc1BsdWdpbikge1xuICAgICAgZXhwcmVzc2lvbnNQbHVnaW4uaW5pdEV4cHJlc3Npb25zKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZE5leHRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5zZWdtZW50cztcblxuICAgIGlmICghc2VnbWVudHMgfHwgc2VnbWVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF1dG9sb2FkU2VnbWVudHMpIHtcbiAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9yZWFkeScpO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gc2VnbWVudC50aW1lICogdGhpcy5mcmFtZVJhdGU7XG4gICAgdmFyIHNlZ21lbnRQYXRoID0gdGhpcy5wYXRoICsgdGhpcy5maWxlTmFtZSArICdfJyArIHRoaXMuc2VnbWVudFBvcyArICcuanNvbic7XG4gICAgdGhpcy5zZWdtZW50UG9zICs9IDE7XG4gICAgZGF0YU1hbmFnZXIubG9hZERhdGEoc2VnbWVudFBhdGgsIHRoaXMuaW5jbHVkZUxheWVycy5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5sb2FkU2VnbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xuXG4gICAgaWYgKCFzZWdtZW50cykge1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICB9XG5cbiAgICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmltYWdlc0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2xvYWRlZF9pbWFnZXMnKTtcbiAgICB0aGlzLmNoZWNrTG9hZGVkKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucHJlbG9hZEltYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldEFzc2V0c1BhdGgodGhpcy5hc3NldHNQYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRBc3NldHModGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cywgdGhpcy5pbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1EYXRhO1xuXG4gICAgICBpZiAodGhpcy5pbml0aWFsU2VnbWVudCkge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmluaXRpYWxTZWdtZW50WzFdIC0gdGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5pbml0aWFsU2VnbWVudFswXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcih0aGlzLmFuaW1hdGlvbkRhdGEub3AgLSB0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xuICAgICAgICB0aGlzLmZpcnN0RnJhbWUgPSBNYXRoLnJvdW5kKHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcblxuICAgICAgaWYgKCFhbmltRGF0YS5hc3NldHMpIHtcbiAgICAgICAgYW5pbURhdGEuYXNzZXRzID0gW107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cztcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5hbmltYXRpb25EYXRhLmZyO1xuICAgICAgdGhpcy5mcmFtZU11bHQgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnIgLyAxMDAwO1xuICAgICAgdGhpcy5yZW5kZXJlci5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyhhbmltRGF0YS5hc3NldHMpO1xuICAgICAgdGhpcy5tYXJrZXJzID0gbWFya2VyUGFyc2VyKGFuaW1EYXRhLm1hcmtlcnMgfHwgW10pO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb25maWdfcmVhZHknKTtcbiAgICAgIHRoaXMucHJlbG9hZEltYWdlcygpO1xuICAgICAgdGhpcy5sb2FkU2VnbWVudHMoKTtcbiAgICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcbiAgICAgIHRoaXMud2FpdEZvckZvbnRzTG9hZGVkKCk7XG5cbiAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMudHJpZ2dlckNvbmZpZ0Vycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUud2FpdEZvckZvbnRzTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VGltZW91dCh0aGlzLndhaXRGb3JGb250c0xvYWRlZC5iaW5kKHRoaXMpLCAyMCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRlZCAmJiB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQgJiYgKHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkSW1hZ2VzKCkgfHwgdGhpcy5yZW5kZXJlci5yZW5kZXJlclR5cGUgIT09ICdjYW52YXMnKSAmJiB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEZvb3RhZ2VzKCkpIHtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcblxuICAgICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIGV4cHJlc3Npb25zUGx1Z2luLmluaXRFeHByZXNzaW9ucyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJlci5pbml0SXRlbXMoKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ0RPTUxvYWRlZCcpO1xuICAgICAgfS5iaW5kKHRoaXMpLCAwKTtcbiAgICAgIHRoaXMuZ290b0ZyYW1lKCk7XG5cbiAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIC8vIEFkZGluZyB0aGlzIHZhbGlkYXRpb24gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIGNhc2UgYW4gZXZlbnQgb2JqZWN0IHdhcyBiZWluZyBwYXNzZWQgZG93blxuICAgIHZhciBfd2lkdGggPSB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gd2lkdGggOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgX2hlaWdodCA9IHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInID8gaGVpZ2h0IDogdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U3ViZnJhbWUgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSAhIWZsYWc7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ290b0ZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy5pc1N1YmZyYW1lRW5hYmxlZCA/IHRoaXMuY3VycmVudFJhd0ZyYW1lIDogfn50aGlzLmN1cnJlbnRSYXdGcmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cbiAgICBpZiAodGhpcy50aW1lQ29tcGxldGVkICE9PSB0aGlzLnRvdGFsRnJhbWVzICYmIHRoaXMuY3VycmVudEZyYW1lID4gdGhpcy50aW1lQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMudGltZUNvbXBsZXRlZDtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnJhbWUnKTtcbiAgICB0aGlzLnJlbmRlckZyYW1lKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkcmF3bkZyYW1lJyk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbnNQbHVnaW4ucmVzZXRGcmFtZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wbGF5Jyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5yZXN1bWUoKTtcblxuICAgICAgaWYgKHRoaXMuX2lkbGUpIHtcbiAgICAgICAgdGhpcy5faWRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19wYXVzZScpO1xuICAgICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgICB0aGlzLnRyaWdnZXIoJ19pZGxlJyk7XG4gICAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5wYXVzZSgpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF0YSA9IGZ1bmN0aW9uIChtYXJrZXJOYW1lKSB7XG4gICAgdmFyIG1hcmtlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tYXJrZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtYXJrZXIgPSB0aGlzLm1hcmtlcnNbaV07XG5cbiAgICAgIGlmIChtYXJrZXIucGF5bG9hZCAmJiBtYXJrZXIucGF5bG9hZC5uYW1lID09PSBtYXJrZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFN0b3AgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKG51bVZhbHVlKSkge1xuICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZ2V0TWFya2VyRGF0YSh2YWx1ZSk7XG5cbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0ZyYW1lKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcik7XG4gICAgfVxuXG4gICAgdGhpcy5wYXVzZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvVG9BbmRQbGF5ID0gZnVuY3Rpb24gKHZhbHVlLCBpc0ZyYW1lLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bVZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xuXG4gICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgIGlmICghbWFya2VyLmR1cmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5nb1RvQW5kU3RvcChtYXJrZXIudGltZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wbGF5U2VnbWVudHMoW21hcmtlci50aW1lLCBtYXJrZXIudGltZSArIG1hcmtlci5kdXJhdGlvbl0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobnVtVmFsdWUsIGlzRnJhbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMucGxheSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkdmFuY2VUaW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUgfHwgdGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5jdXJyZW50UmF3RnJhbWUgKyB2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcjtcbiAgICB2YXIgX2lzQ29tcGxldGUgPSBmYWxzZTsgLy8gQ2hlY2tpbmcgaWYgbmV4dFZhbHVlID4gdG90YWxGcmFtZXMgLSAxIGZvciBhZGRyZXNzaW5nIG5vbiBsb29waW5nIGFuZCBsb29waW5nIGFuaW1hdGlvbnMuXG4gICAgLy8gSWYgYW5pbWF0aW9uIHdvbid0IGxvb3AsIGl0IHNob3VsZCBzdG9wIGF0IHRvdGFsRnJhbWVzIC0gMS4gSWYgaXQgd2lsbCBsb29wIGl0IHNob3VsZCBjb21wbGV0ZSB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlbiBsb29wLlxuXG4gICAgaWYgKG5leHRWYWx1ZSA+PSB0aGlzLnRvdGFsRnJhbWVzIC0gMSAmJiB0aGlzLmZyYW1lTW9kaWZpZXIgPiAwKSB7XG4gICAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLnBsYXlDb3VudCA9PT0gdGhpcy5sb29wKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSA+IHRoaXMudG90YWxGcmFtZXMgPyBuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzIDogMCkpIHtcbiAgICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgbmV4dFZhbHVlID0gdGhpcy50b3RhbEZyYW1lcyAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMpIHtcbiAgICAgICAgdGhpcy5wbGF5Q291bnQgKz0gMTtcblxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IHRydWU7XG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlIDwgMCkge1xuICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcbiAgICAgICAgaWYgKHRoaXMubG9vcCAmJiAhKHRoaXMucGxheUNvdW50LS0gPD0gMCAmJiB0aGlzLmxvb3AgIT09IHRydWUpKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodGhpcy50b3RhbEZyYW1lcyArIG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21wbGV0ZWRMb29wKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRWYWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChfaXNDb21wbGV0ZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjb21wbGV0ZScpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZGp1c3RTZWdtZW50ID0gZnVuY3Rpb24gKGFyciwgb2Zmc2V0KSB7XG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xuXG4gICAgaWYgKGFyclsxXSA8IGFyclswXSkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclswXSAtIGFyclsxXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMV07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgLSAwLjAwMSAtIG9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChhcnJbMV0gPiBhcnJbMF0pIHtcbiAgICAgIGlmICh0aGlzLmZyYW1lTW9kaWZpZXIgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlTcGVlZCA8IDApIHtcbiAgICAgICAgICB0aGlzLnNldFNwZWVkKC10aGlzLnBsYXlTcGVlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXREaXJlY3Rpb24oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IGFyclsxXSAtIGFyclswXTtcbiAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICB0aGlzLmZpcnN0RnJhbWUgPSBhcnJbMF07XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKDAuMDAxICsgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZ21lbnRTdGFydCcpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNlZ21lbnQgPSBmdW5jdGlvbiAoaW5pdCwgZW5kKSB7XG4gICAgdmFyIHBlbmRpbmdGcmFtZSA9IC0xO1xuXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA8IGluaXQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gaW5pdDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJyZW50UmF3RnJhbWUgKyB0aGlzLmZpcnN0RnJhbWUgPiBlbmQpIHtcbiAgICAgICAgcGVuZGluZ0ZyYW1lID0gZW5kIC0gaW5pdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBpbml0O1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSBlbmQgLSBpbml0O1xuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG5cbiAgICBpZiAocGVuZGluZ0ZyYW1lICE9PSAtMSkge1xuICAgICAgdGhpcy5nb1RvQW5kU3RvcChwZW5kaW5nRnJhbWUsIHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wbGF5U2VnbWVudHMgPSBmdW5jdGlvbiAoYXJyLCBmb3JjZUZsYWcpIHtcbiAgICBpZiAoZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKF90eXBlb2YkNChhcnJbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnJbaV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGggJiYgZm9yY2VGbGFnKSB7XG4gICAgICB0aGlzLmFkanVzdFNlZ21lbnQodGhpcy5zZWdtZW50cy5zaGlmdCgpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlc2V0U2VnbWVudHMgPSBmdW5jdGlvbiAoZm9yY2VGbGFnKSB7XG4gICAgdGhpcy5zZWdtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwLCB0aGlzLmFuaW1hdGlvbkRhdGEub3BdKTtcblxuICAgIGlmIChmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuY2hlY2tTZWdtZW50cygwKTtcbiAgICB9XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tTZWdtZW50cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lIHx8ICF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gICAgdGhpcy5fY2JzID0gbnVsbDtcbiAgICB0aGlzLm9uRW50ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5vbkxvb3BDb21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICB0aGlzLm9uU2VnbWVudFN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLm9uRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IG51bGw7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gbnVsbDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY3VycmVudFJhd0ZyYW1lID0gdmFsdWU7XG4gICAgdGhpcy5nb3RvRnJhbWUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IHZhbDtcbiAgICB0aGlzLnVwZGFGcmFtZU1vZGlmaWVyKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheURpcmVjdGlvbiA9IHZhbCA8IDAgPyAtMSA6IDE7XG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldExvb3AgPSBmdW5jdGlvbiAoaXNMb29waW5nKSB7XG4gICAgdGhpcy5sb29wID0gaXNMb29waW5nO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFZvbHVtZSA9IGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRWb2x1bWUodmFsKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRWb2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Db250cm9sbGVyLmdldFZvbHVtZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLm11dGUoKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS51bm11dGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnVubXV0ZSgpO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWVNb2RpZmllciA9IHRoaXMuZnJhbWVNdWx0ICogdGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb247XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0UmF0ZSh0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbik7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0c1BhdGggPSBmdW5jdGlvbiAoYXNzZXREYXRhKSB7XG4gICAgdmFyIHBhdGggPSAnJztcblxuICAgIGlmIChhc3NldERhdGEuZSkge1xuICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hc3NldHNQYXRoKSB7XG4gICAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XG5cbiAgICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xuICAgICAgICBpbWFnZVBhdGggPSBpbWFnZVBhdGguc3BsaXQoJy8nKVsxXTtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IHRoaXMuYXNzZXRzUGF0aCArIGltYWdlUGF0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgIHBhdGggKz0gYXNzZXREYXRhLnUgPyBhc3NldERhdGEudSA6ICcnO1xuICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXRBc3NldERhdGEgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMuYXNzZXRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoaWQgPT09IHRoaXMuYXNzZXRzW2ldLmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0c1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJlci5oaWRlKCk7XG4gIH07XG5cbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNob3coKTtcbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChpc0ZyYW1lKSB7XG4gICAgcmV0dXJuIGlzRnJhbWUgPyB0aGlzLnRvdGFsRnJhbWVzIDogdGhpcy50b3RhbEZyYW1lcyAvIHRoaXMuZnJhbWVSYXRlO1xuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoLCBkb2N1bWVudERhdGEsIGluZGV4KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5yZW5kZXJlci5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICAgICAgZWxlbWVudC51cGRhdGVEb2N1bWVudERhdGEoZG9jdW1lbnREYXRhLCBpbmRleCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBUT0RPOiBkZWNpZGUgaG93IHRvIGhhbmRsZSBjYXRjaCBjYXNlXG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh0aGlzLl9jYnMgJiYgdGhpcy5fY2JzW25hbWVdKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSAnZW50ZXJGcmFtZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNRW50ZXJGcmFtZUV2ZW50KG5hbWUsIHRoaXMuY3VycmVudEZyYW1lLCB0aGlzLnRvdGFsRnJhbWVzLCB0aGlzLmZyYW1lTW9kaWZpZXIpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkcmF3bkZyYW1lJzpcbiAgICAgICAgICB0aGlzLmRyYXduRnJhbWVFdmVudC5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50LnRvdGFsVGltZSA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICAgICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQuZGlyZWN0aW9uID0gdGhpcy5mcmFtZU1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIHRoaXMuZHJhd25GcmFtZUV2ZW50KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdsb29wQ29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnY29tcGxldGUnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzZWdtZW50U3RhcnQnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2Rlc3Ryb3knOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2VudGVyRnJhbWUnICYmIHRoaXMub25FbnRlckZyYW1lKSB7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZS5jYWxsKHRoaXMsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2xvb3BDb21wbGV0ZScgJiYgdGhpcy5vbkxvb3BDb21wbGV0ZSkge1xuICAgICAgdGhpcy5vbkxvb3BDb21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlTG9vcEV2ZW50KG5hbWUsIHRoaXMubG9vcCwgdGhpcy5wbGF5Q291bnQsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdjb21wbGV0ZScgJiYgdGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICB0aGlzLm9uQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUV2ZW50KG5hbWUsIHRoaXMuZnJhbWVNdWx0KSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09ICdzZWdtZW50U3RhcnQnICYmIHRoaXMub25TZWdtZW50U3RhcnQpIHtcbiAgICAgIHRoaXMub25TZWdtZW50U3RhcnQuY2FsbCh0aGlzLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gJ2Rlc3Ryb3knICYmIHRoaXMub25EZXN0cm95KSB7XG4gICAgICB0aGlzLm9uRGVzdHJveS5jYWxsKHRoaXMsIG5ldyBCTURlc3Ryb3lFdmVudChuYW1lLCB0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnRyaWdnZXJSZW5kZXJGcmFtZUVycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyQ29uZmlnRXJyb3IgPSBmdW5jdGlvbiAobmF0aXZlRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgQk1Db25maWdFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCB0aGlzLmN1cnJlbnRGcmFtZSk7XG4gICAgdGhpcy50cmlnZ2VyRXZlbnQoJ2Vycm9yJywgZXJyb3IpO1xuXG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgYW5pbWF0aW9uTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbW9kdWxlT2IgPSB7fTtcbiAgICB2YXIgcmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBbXTtcbiAgICB2YXIgaW5pdFRpbWUgPSAwO1xuICAgIHZhciBsZW4gPSAwO1xuICAgIHZhciBwbGF5aW5nQW5pbWF0aW9uc051bSA9IDA7XG4gICAgdmFyIF9zdG9wcGVkID0gdHJ1ZTtcbiAgICB2YXIgX2lzRnJvemVuID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGV2KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBldi50YXJnZXQ7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24gPT09IGFuaW1JdGVtKSB7XG4gICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICBsZW4gLT0gMTtcblxuICAgICAgICAgIGlmICghYW5pbUl0ZW0uaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHN1YnRyYWN0UGxheWluZ0NvdW50KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQW5pbWF0aW9uKGVsZW1lbnQsIGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PT0gZWxlbWVudCAmJiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBlbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLnNldERhdGEoZWxlbWVudCwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICByZXR1cm4gYW5pbUl0ZW07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW5BbmltcyA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcbiAgICAgIHZhciBhbmltYXRpb25zID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRQbGF5aW5nQ291bnQoKSB7XG4gICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSArPSAxO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdWJ0cmFjdFBsYXlpbmdDb3VudCgpIHtcbiAgICAgIHBsYXlpbmdBbmltYXRpb25zTnVtIC09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpIHtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2Rlc3Ryb3knLCByZW1vdmVFbGVtZW50KTtcbiAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ19hY3RpdmUnLCBhZGRQbGF5aW5nQ291bnQpO1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2lkbGUnLCBzdWJ0cmFjdFBsYXlpbmdDb3VudCk7XG4gICAgICByZWdpc3RlcmVkQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgZWxlbTogZWxlbWVudCxcbiAgICAgICAgYW5pbWF0aW9uOiBhbmltSXRlbVxuICAgICAgfSk7XG4gICAgICBsZW4gKz0gMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBudWxsKTtcbiAgICAgIGFuaW1JdGVtLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIGFuaW1JdGVtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXRTcGVlZCh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBsYXkoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wbGF5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKG5vd1RpbWUpIHtcbiAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vd1RpbWUgLSBpbml0VGltZTtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLmFkdmFuY2VUaW1lKGVsYXBzZWRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuXG4gICAgICBpZiAocGxheWluZ0FuaW1hdGlvbnNOdW0gJiYgIV9pc0Zyb3plbikge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3RvcHBlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlyc3Qobm93VGltZSkge1xuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdG9wKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc3RvcChhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24udG9nZ2xlUGF1c2UoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5kZXN0cm95KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VhcmNoQW5pbWF0aW9ucyhhbmltYXRpb25EYXRhLCBzdGFuZGFsb25lLCByZW5kZXJlcikge1xuICAgICAgdmFyIGFuaW1FbGVtZW50cyA9IFtdLmNvbmNhdChbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xvdHRpZScpKSwgW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdib2R5bW92aW4nKSkpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuQW5pbXMgPSBhbmltRWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xuICAgICAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgICAgICBhbmltRWxlbWVudHNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckFuaW1hdGlvbihhbmltRWxlbWVudHNbaV0sIGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhbmRhbG9uZSAmJiBsZW5BbmltcyA9PT0gMCkge1xuICAgICAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICAgICAgcmVuZGVyZXIgPSAnc3ZnJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgYm9keS5pbm5lclRleHQgPSAnJztcbiAgICAgICAgdmFyIGRpdiA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnZGF0YS1ibS10eXBlJywgcmVuZGVyZXIpO1xuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGRpdiwgYW5pbWF0aW9uRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ucmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWN0aXZhdGUoKSB7XG4gICAgICBpZiAoIV9pc0Zyb3plbiAmJiBwbGF5aW5nQW5pbWF0aW9uc051bSkge1xuICAgICAgICBpZiAoX3N0b3BwZWQpIHtcbiAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZpcnN0KTtcbiAgICAgICAgICBfc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgX2lzRnJvemVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgIF9pc0Zyb3plbiA9IGZhbHNlO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRWb2x1bWUodmFsLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbXV0ZShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bm11dGUoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi51bm11dGUoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtb2R1bGVPYi5yZWdpc3RlckFuaW1hdGlvbiA9IHJlZ2lzdGVyQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICAgIG1vZHVsZU9iLnNldFNwZWVkID0gc2V0U3BlZWQ7XG4gICAgbW9kdWxlT2Iuc2V0RGlyZWN0aW9uID0gc2V0RGlyZWN0aW9uO1xuICAgIG1vZHVsZU9iLnBsYXkgPSBwbGF5O1xuICAgIG1vZHVsZU9iLnBhdXNlID0gcGF1c2U7XG4gICAgbW9kdWxlT2Iuc3RvcCA9IHN0b3A7XG4gICAgbW9kdWxlT2IudG9nZ2xlUGF1c2UgPSB0b2dnbGVQYXVzZTtcbiAgICBtb2R1bGVPYi5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgICBtb2R1bGVPYi5yZXNpemUgPSByZXNpemU7IC8vIG1vZHVsZU9iLnN0YXJ0ID0gc3RhcnQ7XG5cbiAgICBtb2R1bGVPYi5nb1RvQW5kU3RvcCA9IGdvVG9BbmRTdG9wO1xuICAgIG1vZHVsZU9iLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIG1vZHVsZU9iLmZyZWV6ZSA9IGZyZWV6ZTtcbiAgICBtb2R1bGVPYi51bmZyZWV6ZSA9IHVuZnJlZXplO1xuICAgIG1vZHVsZU9iLnNldFZvbHVtZSA9IHNldFZvbHVtZTtcbiAgICBtb2R1bGVPYi5tdXRlID0gbXV0ZTtcbiAgICBtb2R1bGVPYi51bm11dGUgPSB1bm11dGU7XG4gICAgbW9kdWxlT2IuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucztcbiAgICByZXR1cm4gbW9kdWxlT2I7XG4gIH0oKTtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICB2YXIgQmV6aWVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcclxuICAgICAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cclxuICAgICAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXHJcbiAgICAgICAqXHJcbiAgICAgICAqIENyZWRpdHM6IGlzIGJhc2VkIG9uIEZpcmVmb3gncyBuc1NNSUxLZXlTcGxpbmUuY3BwXHJcbiAgICAgICAqIFVzYWdlOlxyXG4gICAgICAgKiB2YXIgc3BsaW5lID0gQmV6aWVyRWFzaW5nKFsgMC4yNSwgMC4xLCAwLjI1LCAxLjAgXSlcclxuICAgICAgICogc3BsaW5lLmdldCh4KSA9PiByZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgfCB4IG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIHZhciBvYiA9IHt9O1xuICAgIG9iLmdldEJlemllckVhc2luZyA9IGdldEJlemllckVhc2luZztcbiAgICB2YXIgYmV6aWVycyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZ2V0QmV6aWVyRWFzaW5nKGEsIGIsIGMsIGQsIG5tKSB7XG4gICAgICB2YXIgc3RyID0gbm0gfHwgKCdiZXpfJyArIGEgKyAnXycgKyBiICsgJ18nICsgYyArICdfJyArIGQpLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xuXG4gICAgICBpZiAoYmV6aWVyc1tzdHJdKSB7XG4gICAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXpFYXNpbmcgPSBuZXcgQmV6aWVyRWFzaW5nKFthLCBiLCBjLCBkXSk7XG4gICAgICBiZXppZXJzW3N0cl0gPSBiZXpFYXNpbmc7XG4gICAgICByZXR1cm4gYmV6RWFzaW5nO1xuICAgIH0gLy8gVGhlc2UgdmFsdWVzIGFyZSBlc3RhYmxpc2hlZCBieSBlbXBpcmljaXNtIHdpdGggdGVzdHMgKHRyYWRlb2ZmOiBwZXJmb3JtYW5jZSBWUyBwcmVjaXNpb24pXG5cblxuICAgIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG4gICAgdmFyIE5FV1RPTl9NSU5fU0xPUEUgPSAwLjAwMTtcbiAgICB2YXIgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuICAgIHZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuICAgIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XG4gICAgdmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcbiAgICB2YXIgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGZ1bmN0aW9uIEEoYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDKGFBMSkge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMTtcbiAgICB9IC8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIoYVQsIGFBMSwgYUEyKSB7XG4gICAgICByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7XG4gICAgfSAvLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5cblxuICAgIGZ1bmN0aW9uIGdldFNsb3BlKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIEEoYUExLCBhQTIpICogYVQgKiBhVCArIDIuMCAqIEIoYUExLCBhQTIpICogYVQgKyBDKGFBMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgICB2YXIgY3VycmVudFgsXG4gICAgICAgICAgY3VycmVudFQsXG4gICAgICAgICAgaSA9IDA7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcblxuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICAgIHJldHVybiBjdXJyZW50VDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgICAgICB2YXIgY3VycmVudFNsb3BlID0gZ2V0U2xvcGUoYUd1ZXNzVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoY3VycmVudFNsb3BlID09PSAwLjApIHJldHVybiBhR3Vlc3NUO1xuICAgICAgICB2YXIgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgICAqIHBvaW50cyBpcyBhbiBhcnJheSBvZiBbIG1YMSwgbVkxLCBtWDIsIG1ZMiBdXHJcbiAgICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBCZXppZXJFYXNpbmcocG9pbnRzKSB7XG4gICAgICB0aGlzLl9wID0gcG9pbnRzO1xuICAgICAgdGhpcy5fbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIEJlemllckVhc2luZy5wcm90b3R5cGUgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCh4KSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xuICAgICAgICBpZiAoIXRoaXMuX3ByZWNvbXB1dGVkKSB0aGlzLl9wcmVjb21wdXRlKCk7XG4gICAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgcmV0dXJuIHg7IC8vIGxpbmVhclxuICAgICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cblxuICAgICAgICBpZiAoeCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICAgIGlmICh4ID09PSAxKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGNhbGNCZXppZXIodGhpcy5fZ2V0VEZvclgoeCksIG1ZMSwgbVkyKTtcbiAgICAgIH0sXG4gICAgICAvLyBQcml2YXRlIHBhcnRcbiAgICAgIF9wcmVjb21wdXRlOiBmdW5jdGlvbiBfcHJlY29tcHV0ZSgpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgICBtWTEgPSB0aGlzLl9wWzFdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICAgIG1ZMiA9IHRoaXMuX3BbM107XG4gICAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobVgxICE9PSBtWTEgfHwgbVgyICE9PSBtWTIpIHtcbiAgICAgICAgICB0aGlzLl9jYWxjU2FtcGxlVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY2FsY1NhbXBsZVZhbHVlczogZnVuY3Rpb24gX2NhbGNTYW1wbGVWYWx1ZXMoKSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICAgIHRoaXMuX21TYW1wbGVWYWx1ZXNbaV0gPSBjYWxjQmV6aWVyKGkgKiBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXHJcbiAgICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxyXG4gICAgICAgICAgICovXG4gICAgICBfZ2V0VEZvclg6IGZ1bmN0aW9uIF9nZXRURm9yWChhWCkge1xuICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcbiAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgICBtU2FtcGxlVmFsdWVzID0gdGhpcy5fbVNhbXBsZVZhbHVlcztcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcblxuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC0tY3VycmVudFNhbXBsZTsgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XG5cbiAgICAgICAgdmFyIGRpc3QgPSAoYVggLSBtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChtU2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGUgKyAxXSAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcblxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzRm9yVDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBwb29saW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIF9kb3VibGUoYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KGFyci5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgXCJkb3VibGVcIjogX2RvdWJsZVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcG9vbEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbml0aWFsTGVuZ3RoLCBfY3JlYXRlLCBfcmVsZWFzZSkge1xuICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgdmFyIF9tYXhMZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgICAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBuZXdFbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBuZXdFbGVtZW50KCkge1xuICAgICAgICB2YXIgZWxlbWVudDtcblxuICAgICAgICBpZiAoX2xlbmd0aCkge1xuICAgICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgICBlbGVtZW50ID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50ID0gX2NyZWF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xuICAgICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICAgIHBvb2wgPSBwb29saW5nW1wiZG91YmxlXCJdKHBvb2wpO1xuICAgICAgICAgIF9tYXhMZW5ndGggKj0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfcmVsZWFzZSkge1xuICAgICAgICAgIF9yZWxlYXNlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcG9vbFtfbGVuZ3RoXSA9IGVsZW1lbnQ7XG4gICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgYmV6aWVyTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhZGRlZExlbmd0aDogMCxcbiAgICAgICAgcGVyY2VudHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpKSxcbiAgICAgICAgbGVuZ3RoczogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGdldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKCkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgdmFyIHNlZ21lbnRzTGVuZ3RoUG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZW5ndGhzOiBbXSxcbiAgICAgICAgdG90YWxMZW5ndGg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBlbGVtZW50Lmxlbmd0aHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYmV6aWVyTGVuZ3RoUG9vbC5yZWxlYXNlKGVsZW1lbnQubGVuZ3Roc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQubGVuZ3Rocy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUsIHJlbGVhc2UpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gYmV6RnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGggPSBNYXRoO1xuXG4gICAgZnVuY3Rpb24gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgZGV0MSA9IHgxICogeTIgKyB5MSAqIHgzICsgeDIgKiB5MyAtIHgzICogeTIgLSB5MyAqIHgxIC0geDIgKiB5MTtcbiAgICAgIHJldHVybiBkZXQxID4gLTAuMDAxICYmIGRldDEgPCAwLjAwMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTNEKHgxLCB5MSwgejEsIHgyLCB5MiwgejIsIHgzLCB5MywgejMpIHtcbiAgICAgIGlmICh6MSA9PT0gMCAmJiB6MiA9PT0gMCAmJiB6MyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcG9pbnRPbkxpbmUyRCh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3QxID0gbWF0aC5zcXJ0KG1hdGgucG93KHgyIC0geDEsIDIpICsgbWF0aC5wb3coeTIgLSB5MSwgMikgKyBtYXRoLnBvdyh6MiAtIHoxLCAyKSk7XG4gICAgICB2YXIgZGlzdDIgPSBtYXRoLnNxcnQobWF0aC5wb3coeDMgLSB4MSwgMikgKyBtYXRoLnBvdyh5MyAtIHkxLCAyKSArIG1hdGgucG93KHozIC0gejEsIDIpKTtcbiAgICAgIHZhciBkaXN0MyA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgyLCAyKSArIG1hdGgucG93KHkzIC0geTIsIDIpICsgbWF0aC5wb3coejMgLSB6MiwgMikpO1xuICAgICAgdmFyIGRpZmZEaXN0O1xuXG4gICAgICBpZiAoZGlzdDEgPiBkaXN0Mikge1xuICAgICAgICBpZiAoZGlzdDEgPiBkaXN0Mykge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDEgLSBkaXN0MiAtIGRpc3QzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZEaXN0ID0gZGlzdDMgLSBkaXN0MiAtIGRpc3QxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpc3QzID4gZGlzdDIpIHtcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaWZmRGlzdCA9IGRpc3QyIC0gZGlzdDEgLSBkaXN0MztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpZmZEaXN0ID4gLTAuMDAwMSAmJiBkaWZmRGlzdCA8IDAuMDAwMTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmV6aWVyTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBwdENvb3JkO1xuICAgICAgICB2YXIgcGVyYztcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0RGlzdGFuY2U7XG4gICAgICAgIHZhciBwb2ludCA9IFtdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gW107XG4gICAgICAgIHZhciBsZW5ndGhEYXRhID0gYmV6aWVyTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgIHBlcmMgPSBrIC8gKGN1cnZlU2VnbWVudHMgLSAxKTtcbiAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHRDb29yZCA9IGJtUG93KDEgLSBwZXJjLCAzKSAqIHB0MVtpXSArIDMgKiBibVBvdygxIC0gcGVyYywgMikgKiBwZXJjICogcHQzW2ldICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIHB0NFtpXSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xuICAgICAgICAgICAgcG9pbnRbaV0gPSBwdENvb3JkO1xuXG4gICAgICAgICAgICBpZiAobGFzdFBvaW50W2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB0RGlzdGFuY2UgKz0gYm1Qb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sIDIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXN0UG9pbnRbaV0gPSBwb2ludFtpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocHREaXN0YW5jZSkge1xuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGVuZ3RoRGF0YS5wZXJjZW50c1trXSA9IHBlcmM7XG4gICAgICAgICAgbGVuZ3RoRGF0YS5sZW5ndGhzW2tdID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGhEYXRhLmFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGhEYXRhO1xuICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50c0xlbmd0aChzaGFwZURhdGEpIHtcbiAgICAgIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB2YXIgY2xvc2VkID0gc2hhcGVEYXRhLmM7XG4gICAgICB2YXIgcGF0aFYgPSBzaGFwZURhdGEudjtcbiAgICAgIHZhciBwYXRoTyA9IHNoYXBlRGF0YS5vO1xuICAgICAgdmFyIHBhdGhJID0gc2hhcGVEYXRhLmk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZURhdGEuX2xlbmd0aDtcbiAgICAgIHZhciBsZW5ndGhzID0gc2VnbWVudHNMZW5ndGgubGVuZ3RocztcbiAgICAgIHZhciB0b3RhbExlbmd0aCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbaSArIDFdLCBwYXRoT1tpXSwgcGF0aElbaSArIDFdKTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsb3NlZCAmJiBsZW4pIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbMF0sIHBhdGhPW2ldLCBwYXRoSVswXSk7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnRzTGVuZ3RoLnRvdGFsTGVuZ3RoID0gdG90YWxMZW5ndGg7XG4gICAgICByZXR1cm4gc2VnbWVudHNMZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQmV6aWVyRGF0YShsZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBvaW50RGF0YShwYXJ0aWFsLCBwb2ludCkge1xuICAgICAgdGhpcy5wYXJ0aWFsTGVuZ3RoID0gcGFydGlhbDtcbiAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICB9XG5cbiAgICB2YXIgYnVpbGRCZXppZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0b3JlZERhdGEgPSB7fTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAocHQxLCBwdDIsIHB0MywgcHQ0KSB7XG4gICAgICAgIHZhciBiZXppZXJOYW1lID0gKHB0MVswXSArICdfJyArIHB0MVsxXSArICdfJyArIHB0MlswXSArICdfJyArIHB0MlsxXSArICdfJyArIHB0M1swXSArICdfJyArIHB0M1sxXSArICdfJyArIHB0NFswXSArICdfJyArIHB0NFsxXSkucmVwbGFjZSgvXFwuL2csICdwJyk7XG5cbiAgICAgICAgaWYgKCFzdG9yZWREYXRhW2Jlemllck5hbWVdKSB7XG4gICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgdmFyIHB0Q29vcmQ7XG4gICAgICAgICAgdmFyIHBlcmM7XG4gICAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgcHREaXN0YW5jZTtcbiAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocHQxLmxlbmd0aCA9PT0gMiAmJiAocHQxWzBdICE9PSBwdDJbMF0gfHwgcHQxWzFdICE9PSBwdDJbMV0pICYmIHBvaW50T25MaW5lMkQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdLCBwdDFbMF0gKyBwdDNbMF0sIHB0MVsxXSArIHB0M1sxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0sIHB0MlswXSArIHB0NFswXSwgcHQyWzFdICsgcHQ0WzFdKSkge1xuICAgICAgICAgICAgY3VydmVTZWdtZW50cyA9IDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJlemllckRhdGEgPSBuZXcgQmV6aWVyRGF0YShjdXJ2ZVNlZ21lbnRzKTtcbiAgICAgICAgICBsZW4gPSBwdDMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gMDtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIHB0Q29vcmQgPSBibVBvdygxIC0gcGVyYywgMykgKiBwdDFbaV0gKyAzICogYm1Qb3coMSAtIHBlcmMsIDIpICogcGVyYyAqIChwdDFbaV0gKyBwdDNbaV0pICsgMyAqICgxIC0gcGVyYykgKiBibVBvdyhwZXJjLCAyKSAqIChwdDJbaV0gKyBwdDRbaV0pICsgYm1Qb3cocGVyYywgMykgKiBwdDJbaV07XG4gICAgICAgICAgICAgIHBvaW50W2ldID0gcHRDb29yZDtcblxuICAgICAgICAgICAgICBpZiAobGFzdFBvaW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibVBvdyhwb2ludFtpXSAtIGxhc3RQb2ludFtpXSwgMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgICBiZXppZXJEYXRhLnBvaW50c1trXSA9IG5ldyBQb2ludERhdGEocHREaXN0YW5jZSwgcG9pbnQpO1xuICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoID0gYWRkZWRMZW5ndGg7XG4gICAgICAgICAgc3RvcmVkRGF0YVtiZXppZXJOYW1lXSA9IGJlemllckRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RvcmVkRGF0YVtiZXppZXJOYW1lXTtcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQZXJjKHBlcmMsIGJlemllckRhdGEpIHtcbiAgICAgIHZhciBwZXJjZW50cyA9IGJlemllckRhdGEucGVyY2VudHM7XG4gICAgICB2YXIgbGVuZ3RocyA9IGJlemllckRhdGEubGVuZ3RocztcbiAgICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaW5pdFBvcyA9IGJtRmxvb3IoKGxlbiAtIDEpICogcGVyYyk7XG4gICAgICB2YXIgbGVuZ3RoUG9zID0gcGVyYyAqIGJlemllckRhdGEuYWRkZWRMZW5ndGg7XG4gICAgICB2YXIgbFBlcmMgPSAwO1xuXG4gICAgICBpZiAoaW5pdFBvcyA9PT0gbGVuIC0gMSB8fCBpbml0UG9zID09PSAwIHx8IGxlbmd0aFBvcyA9PT0gbGVuZ3Roc1tpbml0UG9zXSkge1xuICAgICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXIgPSBsZW5ndGhzW2luaXRQb3NdID4gbGVuZ3RoUG9zID8gLTEgOiAxO1xuICAgICAgdmFyIGZsYWcgPSB0cnVlO1xuXG4gICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICBpZiAobGVuZ3Roc1tpbml0UG9zXSA8PSBsZW5ndGhQb3MgJiYgbGVuZ3Roc1tpbml0UG9zICsgMV0gPiBsZW5ndGhQb3MpIHtcbiAgICAgICAgICBsUGVyYyA9IChsZW5ndGhQb3MgLSBsZW5ndGhzW2luaXRQb3NdKSAvIChsZW5ndGhzW2luaXRQb3MgKyAxXSAtIGxlbmd0aHNbaW5pdFBvc10pO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0UG9zICs9IGRpcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0UG9zIDwgMCB8fCBpbml0UG9zID49IGxlbiAtIDEpIHtcbiAgICAgICAgICAvLyBGSVggZm9yIFR5cGVkQXJyYXlzIHRoYXQgZG9uJ3Qgc3RvcmUgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGggZW5vdWdoIGFjY3VyYWN5XG4gICAgICAgICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50c1tpbml0UG9zXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MgKyAxXSAtIHBlcmNlbnRzW2luaXRQb3NdKSAqIGxQZXJjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBvaW50SW5TZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgcGVyY2VudCwgYmV6aWVyRGF0YSkge1xuICAgICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKHBlcmNlbnQsIGJlemllckRhdGEpO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHB0WCA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVswXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzBdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMF0gKyB0MSAqIHQxICogdDEgKiBwdDJbMF0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgdmFyIHB0WSA9IG1hdGgucm91bmQoKHUxICogdTEgKiB1MSAqIHB0MVsxXSArICh0MSAqIHUxICogdTEgKyB1MSAqIHQxICogdTEgKyB1MSAqIHUxICogdDEpICogcHQzWzFdICsgKHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MSkgKiBwdDRbMV0gKyB0MSAqIHQxICogdDEgKiBwdDJbMV0pICogMTAwMCkgLyAxMDAwO1xuICAgICAgcmV0dXJuIFtwdFgsIHB0WV07XG4gICAgfVxuXG4gICAgdmFyIGJlemllclNlZ21lbnRQb2ludHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgOCk7XG5cbiAgICBmdW5jdGlvbiBnZXROZXdTZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgc3RhcnRQZXJjLCBlbmRQZXJjLCBiZXppZXJEYXRhKSB7XG4gICAgICBpZiAoc3RhcnRQZXJjIDwgMCkge1xuICAgICAgICBzdGFydFBlcmMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBlcmMgPiAxKSB7XG4gICAgICAgIHN0YXJ0UGVyYyA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciB0MCA9IGdldERpc3RhbmNlUGVyYyhzdGFydFBlcmMsIGJlemllckRhdGEpO1xuICAgICAgZW5kUGVyYyA9IGVuZFBlcmMgPiAxID8gMSA6IGVuZFBlcmM7XG4gICAgICB2YXIgdDEgPSBnZXREaXN0YW5jZVBlcmMoZW5kUGVyYywgYmV6aWVyRGF0YSk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdDEubGVuZ3RoO1xuICAgICAgdmFyIHUwID0gMSAtIHQwO1xuICAgICAgdmFyIHUxID0gMSAtIHQxO1xuICAgICAgdmFyIHUwdTB1MCA9IHUwICogdTAgKiB1MDtcbiAgICAgIHZhciB0MHUwdTBfMyA9IHQwICogdTAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTBfMyA9IHQwICogdDAgKiB1MCAqIDM7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdDAgPSB0MCAqIHQwICogdDA7IC8vXG5cbiAgICAgIHZhciB1MHUwdTEgPSB1MCAqIHUwICogdTE7XG4gICAgICB2YXIgdDB1MHUxXzMgPSB0MCAqIHUwICogdTEgKyB1MCAqIHQwICogdTEgKyB1MCAqIHUwICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MHQwdTFfMyA9IHQwICogdDAgKiB1MSArIHUwICogdDAgKiB0MSArIHQwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDB0MSA9IHQwICogdDAgKiB0MTsgLy9cblxuICAgICAgdmFyIHUwdTF1MSA9IHUwICogdTEgKiB1MTtcbiAgICAgIHZhciB0MHUxdTFfMyA9IHQwICogdTEgKiB1MSArIHUwICogdDEgKiB1MSArIHUwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcblxuICAgICAgdmFyIHQwdDF1MV8zID0gdDAgKiB0MSAqIHUxICsgdTAgKiB0MSAqIHQxICsgdDAgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDB0MXQxID0gdDAgKiB0MSAqIHQxOyAvL1xuXG4gICAgICB2YXIgdTF1MXUxID0gdTEgKiB1MSAqIHUxO1xuICAgICAgdmFyIHQxdTF1MV8zID0gdDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICB2YXIgdDF0MXUxXzMgPSB0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG5cbiAgICAgIHZhciB0MXQxdDEgPSB0MSAqIHQxICogdDE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0XSA9IG1hdGgucm91bmQoKHUwdTB1MCAqIHB0MVtpXSArIHQwdTB1MF8zICogcHQzW2ldICsgdDB0MHUwXzMgKiBwdDRbaV0gKyB0MHQwdDAgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAxXSA9IG1hdGgucm91bmQoKHUwdTB1MSAqIHB0MVtpXSArIHQwdTB1MV8zICogcHQzW2ldICsgdDB0MHUxXzMgKiBwdDRbaV0gKyB0MHQwdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAyXSA9IG1hdGgucm91bmQoKHUwdTF1MSAqIHB0MVtpXSArIHQwdTF1MV8zICogcHQzW2ldICsgdDB0MXUxXzMgKiBwdDRbaV0gKyB0MHQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAzXSA9IG1hdGgucm91bmQoKHUxdTF1MSAqIHB0MVtpXSArIHQxdTF1MV8zICogcHQzW2ldICsgdDF0MXUxXzMgKiBwdDRbaV0gKyB0MXQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmV6aWVyU2VnbWVudFBvaW50cztcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2VnbWVudHNMZW5ndGg6IGdldFNlZ21lbnRzTGVuZ3RoLFxuICAgICAgZ2V0TmV3U2VnbWVudDogZ2V0TmV3U2VnbWVudCxcbiAgICAgIGdldFBvaW50SW5TZWdtZW50OiBnZXRQb2ludEluU2VnbWVudCxcbiAgICAgIGJ1aWxkQmV6aWVyRGF0YTogYnVpbGRCZXppZXJEYXRhLFxuICAgICAgcG9pbnRPbkxpbmUyRDogcG9pbnRPbkxpbmUyRCxcbiAgICAgIHBvaW50T25MaW5lM0Q6IHBvaW50T25MaW5lM0RcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJleiA9IGJlekZ1bmN0aW9uKCk7XG5cbiAgdmFyIGluaXRGcmFtZSA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XG4gIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGVWYWx1ZShmcmFtZU51bSwgY2FjaGluZykge1xuICAgIHZhciBvZmZzZXRUaW1lID0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIHZhciBuZXdWYWx1ZTtcblxuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG5ld1ZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcbiAgICB2YXIgaSA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHZhciBsZW4gPSB0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICB2YXIga2V5RGF0YTtcbiAgICB2YXIgbmV4dEtleURhdGE7XG4gICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICB3aGlsZSAoZmxhZykge1xuICAgICAga2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2ldO1xuICAgICAgbmV4dEtleURhdGEgPSB0aGlzLmtleWZyYW1lc1tpICsgMV07XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxICYmIGZyYW1lTnVtID49IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSB7XG4gICAgICAgIGlmIChrZXlEYXRhLmgpIHtcbiAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUgPiBmcmFtZU51bSkge1xuICAgICAgICBpdGVyYXRpb25JbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAga2V5ZnJhbWVNZXRhZGF0YSA9IHRoaXMua2V5ZnJhbWVzTWV0YWRhdGFbaV0gfHwge307XG4gICAgdmFyIGs7XG4gICAgdmFyIGtMZW47XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGo7XG4gICAgdmFyIGZuYztcbiAgICB2YXIgbmV4dEtleVRpbWUgPSBuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZTtcbiAgICB2YXIga2V5VGltZSA9IGtleURhdGEudCAtIG9mZnNldFRpbWU7XG4gICAgdmFyIGVuZFZhbHVlO1xuXG4gICAgaWYgKGtleURhdGEudG8pIHtcbiAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhKSB7XG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEuYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEoa2V5RGF0YS5zLCBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZSwga2V5RGF0YS50bywga2V5RGF0YS50aSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhO1xuXG4gICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgfHwgZnJhbWVOdW0gPCBrZXlUaW1lKSB7XG4gICAgICAgIHZhciBpbmQgPSBmcmFtZU51bSA+PSBuZXh0S2V5VGltZSA/IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbaW5kXS5wb2ludFtrXTtcbiAgICAgICAgfSAvLyBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IC0xO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSwga2V5RGF0YS5uKS5nZXQ7XG4gICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgIH1cblxuICAgICAgICBwZXJjID0gZm5jKChmcmFtZU51bSAtIGtleVRpbWUpIC8gKG5leHRLZXlUaW1lIC0ga2V5VGltZSkpO1xuICAgICAgICB2YXIgZGlzdGFuY2VJbkxpbmUgPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgc2VnbWVudFBlcmM7XG4gICAgICAgIHZhciBhZGRlZExlbmd0aCA9IGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkgPyBjYWNoaW5nLl9sYXN0QWRkZWRMZW5ndGggOiAwO1xuICAgICAgICBqID0gY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9PT0gaSA/IGNhY2hpbmcuX2xhc3RQb2ludCA6IDA7XG4gICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICBqTGVuID0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgICAgYWRkZWRMZW5ndGggKz0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcblxuICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZUluTGluZSA+PSBhZGRlZExlbmd0aCAmJiBkaXN0YW5jZUluTGluZSA8IGFkZGVkTGVuZ3RoICsgYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGgpIHtcbiAgICAgICAgICAgIHNlZ21lbnRQZXJjID0gKGRpc3RhbmNlSW5MaW5lIC0gYWRkZWRMZW5ndGgpIC8gYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10gKyAoYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBvaW50W2tdIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10pICogc2VnbWVudFBlcmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChqIDwgakxlbiAtIDEpIHtcbiAgICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hpbmcuX2xhc3RQb2ludCA9IGo7XG4gICAgICAgIGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3V0WDtcbiAgICAgIHZhciBvdXRZO1xuICAgICAgdmFyIGluWDtcbiAgICAgIHZhciBpblk7XG4gICAgICB2YXIga2V5VmFsdWU7XG4gICAgICBsZW4gPSBrZXlEYXRhLnMubGVuZ3RoO1xuICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcblxuICAgICAgaWYgKHRoaXMuc2ggJiYga2V5RGF0YS5oICE9PSAxKSB7XG4gICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xuICAgICAgICAgIG5ld1ZhbHVlWzBdID0gZW5kVmFsdWVbMF07XG4gICAgICAgICAgbmV3VmFsdWVbMV0gPSBlbmRWYWx1ZVsxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGVuZFZhbHVlWzJdO1xuICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDw9IGtleVRpbWUpIHtcbiAgICAgICAgICBuZXdWYWx1ZVswXSA9IGtleURhdGEuc1swXTtcbiAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGtleURhdGEuc1sxXTtcbiAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGtleURhdGEuc1syXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcXVhdFN0YXJ0ID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLnMpO1xuICAgICAgICAgIHZhciBxdWF0RW5kID0gY3JlYXRlUXVhdGVybmlvbihlbmRWYWx1ZSk7XG4gICAgICAgICAgdmFyIHRpbWUgPSAoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpO1xuICAgICAgICAgIHF1YXRlcm5pb25Ub0V1bGVyKG5ld1ZhbHVlLCBzbGVycChxdWF0U3RhcnQsIHF1YXRFbmQsIHRpbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKGtleURhdGEuaCAhPT0gMSkge1xuICAgICAgICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8IGtleVRpbWUpIHtcbiAgICAgICAgICAgICAgcGVyYyA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoa2V5RGF0YS5vLnguY29uc3RydWN0b3IgPT09IEFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCkge1xuICAgICAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldKSB7XG4gICAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLnhbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby54WzBdIDoga2V5RGF0YS5vLnhbaV07XG4gICAgICAgICAgICAgICAgICBvdXRZID0ga2V5RGF0YS5vLnlbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuby55WzBdIDoga2V5RGF0YS5vLnlbaV07XG4gICAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueFtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5pLnhbMF0gOiBrZXlEYXRhLmkueFtpXTtcbiAgICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55W2ldID09PSB1bmRlZmluZWQgPyBrZXlEYXRhLmkueVswXSA6IGtleURhdGEuaS55W2ldO1xuICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldID0gZm5jO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdFtpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgICAgb3V0WCA9IGtleURhdGEuby54O1xuICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueTtcbiAgICAgICAgICAgICAgICBpblggPSBrZXlEYXRhLmkueDtcbiAgICAgICAgICAgICAgICBpblkgPSBrZXlEYXRhLmkueTtcbiAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xuICAgICAgICAgICAgICAgIGtleURhdGEua2V5ZnJhbWVNZXRhZGF0YSA9IGZuYztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcbiAgICAgICAgICBrZXlWYWx1ZSA9IGtleURhdGEuaCA9PT0gMSA/IGtleURhdGEuc1tpXSA6IGtleURhdGEuc1tpXSArIChlbmRWYWx1ZVtpXSAtIGtleURhdGEuc1tpXSkgKiBwZXJjO1xuXG4gICAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICdtdWx0aWRpbWVuc2lvbmFsJykge1xuICAgICAgICAgICAgbmV3VmFsdWVbaV0gPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBrZXlWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfSAvLyBiYXNlZCBvbiBAVG9qaSdzIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9cblxuXG4gIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIGF4ID0gYVswXTtcbiAgICB2YXIgYXkgPSBhWzFdO1xuICAgIHZhciBheiA9IGFbMl07XG4gICAgdmFyIGF3ID0gYVszXTtcbiAgICB2YXIgYnggPSBiWzBdO1xuICAgIHZhciBieSA9IGJbMV07XG4gICAgdmFyIGJ6ID0gYlsyXTtcbiAgICB2YXIgYncgPSBiWzNdO1xuICAgIHZhciBvbWVnYTtcbiAgICB2YXIgY29zb207XG4gICAgdmFyIHNpbm9tO1xuICAgIHZhciBzY2FsZTA7XG4gICAgdmFyIHNjYWxlMTtcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG5cbiAgICBpZiAoY29zb20gPCAwLjApIHtcbiAgICAgIGNvc29tID0gLWNvc29tO1xuICAgICAgYnggPSAtYng7XG4gICAgICBieSA9IC1ieTtcbiAgICAgIGJ6ID0gLWJ6O1xuICAgICAgYncgPSAtYnc7XG4gICAgfVxuXG4gICAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICBzY2FsZTEgPSB0O1xuICAgIH1cblxuICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcbiAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xuICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YXRlcm5pb25Ub0V1bGVyKG91dCwgcXVhdCkge1xuICAgIHZhciBxeCA9IHF1YXRbMF07XG4gICAgdmFyIHF5ID0gcXVhdFsxXTtcbiAgICB2YXIgcXogPSBxdWF0WzJdO1xuICAgIHZhciBxdyA9IHF1YXRbM107XG4gICAgdmFyIGhlYWRpbmcgPSBNYXRoLmF0YW4yKDIgKiBxeSAqIHF3IC0gMiAqIHF4ICogcXosIDEgLSAyICogcXkgKiBxeSAtIDIgKiBxeiAqIHF6KTtcbiAgICB2YXIgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMiAqIHF4ICogcXkgKyAyICogcXogKiBxdyk7XG4gICAgdmFyIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiBxeCAqIHF3IC0gMiAqIHF5ICogcXosIDEgLSAyICogcXggKiBxeCAtIDIgKiBxeiAqIHF6KTtcbiAgICBvdXRbMF0gPSBoZWFkaW5nIC8gZGVnVG9SYWRzO1xuICAgIG91dFsxXSA9IGF0dGl0dWRlIC8gZGVnVG9SYWRzO1xuICAgIG91dFsyXSA9IGJhbmsgLyBkZWdUb1JhZHM7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVRdWF0ZXJuaW9uKHZhbHVlcykge1xuICAgIHZhciBoZWFkaW5nID0gdmFsdWVzWzBdICogZGVnVG9SYWRzO1xuICAgIHZhciBhdHRpdHVkZSA9IHZhbHVlc1sxXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYmFuayA9IHZhbHVlc1syXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhoZWFkaW5nIC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoYXR0aXR1ZGUgLyAyKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyhiYW5rIC8gMik7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oaGVhZGluZyAvIDIpO1xuICAgIHZhciBzMiA9IE1hdGguc2luKGF0dGl0dWRlIC8gMik7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oYmFuayAvIDIpO1xuICAgIHZhciB3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgIHZhciB4ID0gczEgKiBzMiAqIGMzICsgYzEgKiBjMiAqIHMzO1xuICAgIHZhciB5ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHZhciB6ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHJldHVybiBbeCwgeSwgeiwgd107XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZUF0Q3VycmVudFRpbWUoKSB7XG4gICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICBpZiAoIShmcmFtZU51bSA9PT0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgfHwgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZW5kVGltZSAmJiBmcmFtZU51bSA+PSBlbmRUaW1lIHx8IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSkpKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZnJhbWVOdW0pIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nKTtcbiAgICAgIHRoaXMucHYgPSByZW5kZXJSZXN1bHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICByZXR1cm4gdGhpcy5wdjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFZWYWx1ZSh2YWwpIHtcbiAgICB2YXIgbXVsdGlwbGllZFZhbHVlO1xuXG4gICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG11bHRpcGxpZWRWYWx1ZSA9IHZhbCAqIHRoaXMubXVsdDtcblxuICAgICAgaWYgKG1hdGhBYnModGhpcy52IC0gbXVsdGlwbGllZFZhbHVlKSA+IDAuMDAwMDEpIHtcbiAgICAgICAgdGhpcy52ID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy52Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsW2ldICogdGhpcy5tdWx0O1xuXG4gICAgICAgIGlmIChtYXRoQWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgdGhpcy52W2ldID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICAgIHZhciBmaW5hbFZhbHVlID0gdGhpcy5rZiA/IHRoaXMucHYgOiB0aGlzLmRhdGEuaztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH1cblxuICBmdW5jdGlvbiBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMudiA9IG11bHQgPyBkYXRhLmsgKiBtdWx0IDogZGF0YS5rO1xuICAgIHRoaXMucHYgPSBkYXRhLms7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5rID0gZmFsc2U7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMudmVsID0gMDtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cblxuICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgIHRoaXMudmVsID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMudltpXSA9IGRhdGEua1tpXSAqIHRoaXMubXVsdDtcbiAgICAgIHRoaXMucHZbaV0gPSBkYXRhLmtbaV07XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgX2xhc3RLZXlmcmFtZUluZGV4OiAtMVxuICAgIH07XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLnYgPSBpbml0RnJhbWU7XG4gICAgdGhpcy5wdiA9IGluaXRGcmFtZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbZ2V0VmFsdWVBdEN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xuICAgIHRoaXMucHJvcFR5cGUgPSAnbXVsdGlkaW1lbnNpb25hbCc7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG4gICAgdmFyIHRvO1xuICAgIHZhciB0aTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgIGlmIChkYXRhLmtbaV0udG8gJiYgZGF0YS5rW2ldLnMgJiYgZGF0YS5rW2kgKyAxXSAmJiBkYXRhLmtbaSArIDFdLnMpIHtcbiAgICAgICAgcyA9IGRhdGEua1tpXS5zO1xuICAgICAgICBlID0gZGF0YS5rW2kgKyAxXS5zO1xuICAgICAgICB0byA9IGRhdGEua1tpXS50bztcbiAgICAgICAgdGkgPSBkYXRhLmtbaV0udGk7XG5cbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBzWzBdICsgdG9bMF0sIHNbMV0gKyB0b1sxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSwgc1sxXSwgZVswXSwgZVsxXSwgZVswXSArIHRpWzBdLCBlWzFdICsgdGlbMV0pIHx8IHMubGVuZ3RoID09PSAzICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHNbMl0gPT09IGVbMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdLCBzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdLCBlWzJdICsgdGlbMl0pKSB7XG4gICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSAmJiB0b1swXSA9PT0gMCAmJiB0b1sxXSA9PT0gMCAmJiB0aVswXSA9PT0gMCAmJiB0aVsxXSA9PT0gMCkge1xuICAgICAgICAgIGlmIChzLmxlbmd0aCA9PT0gMiB8fCBzWzJdID09PSBlWzJdICYmIHRvWzJdID09PSAwICYmIHRpWzJdID09PSAwKSB7XG4gICAgICAgICAgICBkYXRhLmtbaV0udG8gPSBudWxsO1xuICAgICAgICAgICAgZGF0YS5rW2ldLnRpID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuayA9IHRydWU7XG4gICAgdGhpcy5rZiA9IHRydWU7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB2YXIgYXJyTGVuID0gZGF0YS5rWzBdLnMubGVuZ3RoO1xuICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xuICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy52W2ldID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5wdltpXSA9IGluaXRGcmFtZTtcbiAgICB9XG5cbiAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgbGFzdEZyYW1lOiBpbml0RnJhbWUsXG4gICAgICBsYXN0SW5kZXg6IDAsXG4gICAgICB2YWx1ZTogY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbilcbiAgICB9O1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG5cbiAgdmFyIFByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgaWYgKGRhdGEuc2lkKSB7XG4gICAgICAgIGRhdGEgPSBlbGVtLmdsb2JhbERhdGEuc2xvdE1hbmFnZXIuZ2V0UHJvcChkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHA7XG5cbiAgICAgIGlmICghZGF0YS5rLmxlbmd0aCkge1xuICAgICAgICBwID0gbmV3IFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEua1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcCA9IG5ldyBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBnZXRQcm9wOiBnZXRQcm9wXG4gICAgfTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBEeW5hbWljUHJvcGVydHlDb250YWluZXIoKSB7fVxuXG4gIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUgPSB7XG4gICAgYWRkRHluYW1pY1Byb3BlcnR5OiBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gICAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzOiBmdW5jdGlvbiBpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50UG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDIpO1xuICAgIH1cblxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xuICAgIHRoaXMuYyA9IGZhbHNlO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gODtcbiAgICB0aGlzLnYgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gICAgdGhpcy5vID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICAgIHRoaXMuaSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgfVxuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuc2V0UGF0aERhdGEgPSBmdW5jdGlvbiAoY2xvc2VkLCBsZW4pIHtcbiAgICB0aGlzLmMgPSBjbG9zZWQ7XG4gICAgdGhpcy5zZXRMZW5ndGgobGVuKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdGhpcy52W2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMub1tpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLmlbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnNldExlbmd0aCA9IGZ1bmN0aW9uIChsZW4pIHtcbiAgICB3aGlsZSAodGhpcy5fbWF4TGVuZ3RoIDwgbGVuKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICB9O1xuXG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuZG91YmxlQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52ID0gdGhpcy52LmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xuICAgIHRoaXMuaSA9IHRoaXMuaS5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICB0aGlzLm8gPSB0aGlzLm8uY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoICo9IDI7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRYWUF0ID0gZnVuY3Rpb24gKHgsIHksIHR5cGUsIHBvcywgcmVwbGFjZSkge1xuICAgIHZhciBhcnI7XG4gICAgdGhpcy5fbGVuZ3RoID0gTWF0aC5tYXgodGhpcy5fbGVuZ3RoLCBwb3MgKyAxKTtcblxuICAgIGlmICh0aGlzLl9sZW5ndGggPj0gdGhpcy5fbWF4TGVuZ3RoKSB7XG4gICAgICB0aGlzLmRvdWJsZUFycmF5TGVuZ3RoKCk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgYXJyID0gdGhpcy52O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnaSc6XG4gICAgICAgIGFyciA9IHRoaXMuaTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ28nOlxuICAgICAgICBhcnIgPSB0aGlzLm87XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCFhcnJbcG9zXSB8fCBhcnJbcG9zXSAmJiAhcmVwbGFjZSkge1xuICAgICAgYXJyW3Bvc10gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgIH1cblxuICAgIGFycltwb3NdWzBdID0geDtcbiAgICBhcnJbcG9zXVsxXSA9IHk7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uICh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBwb3MsIHJlcGxhY2UpIHtcbiAgICB0aGlzLnNldFhZQXQodlgsIHZZLCAndicsIHBvcywgcmVwbGFjZSk7XG4gICAgdGhpcy5zZXRYWUF0KG9YLCBvWSwgJ28nLCBwb3MsIHJlcGxhY2UpO1xuICAgIHRoaXMuc2V0WFlBdChpWCwgaVksICdpJywgcG9zLCByZXBsYWNlKTtcbiAgfTtcblxuICBTaGFwZVBhdGgucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld1BhdGggPSBuZXcgU2hhcGVQYXRoKCk7XG4gICAgbmV3UGF0aC5zZXRQYXRoRGF0YSh0aGlzLmMsIHRoaXMuX2xlbmd0aCk7XG4gICAgdmFyIHZlcnRpY2VzID0gdGhpcy52O1xuICAgIHZhciBvdXRQb2ludHMgPSB0aGlzLm87XG4gICAgdmFyIGluUG9pbnRzID0gdGhpcy5pO1xuICAgIHZhciBpbml0ID0gMDtcblxuICAgIGlmICh0aGlzLmMpIHtcbiAgICAgIG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbMF1bMF0sIHZlcnRpY2VzWzBdWzFdLCBpblBvaW50c1swXVswXSwgaW5Qb2ludHNbMF1bMV0sIG91dFBvaW50c1swXVswXSwgb3V0UG9pbnRzWzBdWzFdLCAwLCBmYWxzZSk7XG4gICAgICBpbml0ID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY250ID0gdGhpcy5fbGVuZ3RoIC0gMTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gaW5pdDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBuZXdQYXRoLnNldFRyaXBsZUF0KHZlcnRpY2VzW2NudF1bMF0sIHZlcnRpY2VzW2NudF1bMV0sIGluUG9pbnRzW2NudF1bMF0sIGluUG9pbnRzW2NudF1bMV0sIG91dFBvaW50c1tjbnRdWzBdLCBvdXRQb2ludHNbY250XVsxXSwgaSwgZmFsc2UpO1xuICAgICAgY250IC09IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG4gIH07XG5cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfTtcblxuICB2YXIgc2hhcGVQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGVQYXRoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsZWFzZShzaGFwZVBhdGgpIHtcbiAgICAgIHZhciBsZW4gPSBzaGFwZVBhdGguX2xlbmd0aDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLnZbaV0pO1xuICAgICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGguaVtpXSk7XG4gICAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5vW2ldKTtcbiAgICAgICAgc2hhcGVQYXRoLnZbaV0gPSBudWxsO1xuICAgICAgICBzaGFwZVBhdGguaVtpXSA9IG51bGw7XG4gICAgICAgIHNoYXBlUGF0aC5vW2ldID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgc2hhcGVQYXRoLl9sZW5ndGggPSAwO1xuICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZShzaGFwZSkge1xuICAgICAgdmFyIGNsb25lZCA9IGZhY3RvcnkubmV3RWxlbWVudCgpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aCA9PT0gdW5kZWZpbmVkID8gc2hhcGUudi5sZW5ndGggOiBzaGFwZS5fbGVuZ3RoO1xuICAgICAgY2xvbmVkLnNldExlbmd0aChsZW4pO1xuICAgICAgY2xvbmVkLmMgPSBzaGFwZS5jO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgY2xvbmVkLnNldFRyaXBsZUF0KHNoYXBlLnZbaV1bMF0sIHNoYXBlLnZbaV1bMV0sIHNoYXBlLm9baV1bMF0sIHNoYXBlLm9baV1bMV0sIHNoYXBlLmlbaV1bMF0sIHNoYXBlLmlbaV1bMV0sIGkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cblxuICAgIHZhciBmYWN0b3J5ID0gcG9vbEZhY3RvcnkoNCwgY3JlYXRlLCByZWxlYXNlKTtcbiAgICBmYWN0b3J5LmNsb25lID0gY2xvbmU7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTaGFwZUNvbGxlY3Rpb24oKSB7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSA0O1xuICAgIHRoaXMuc2hhcGVzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICB9XG5cbiAgU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZURhdGEpIHtcbiAgICBpZiAodGhpcy5fbGVuZ3RoID09PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuc2hhcGVzID0gdGhpcy5zaGFwZXMuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgICB0aGlzLl9tYXhMZW5ndGggKj0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xuICAgIHRoaXMuX2xlbmd0aCArPSAxO1xuICB9O1xuXG4gIFNoYXBlQ29sbGVjdGlvbi5wcm90b3R5cGUucmVsZWFzZVNoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgc2hhcGVQb29sLnJlbGVhc2UodGhpcy5zaGFwZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHNoYXBlQ29sbGVjdGlvblBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge1xuICAgICAgbmV3U2hhcGVDb2xsZWN0aW9uOiBuZXdTaGFwZUNvbGxlY3Rpb24sXG4gICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgfTtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9tYXhMZW5ndGggPSA0O1xuICAgIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcblxuICAgIGZ1bmN0aW9uIG5ld1NoYXBlQ29sbGVjdGlvbigpIHtcbiAgICAgIHZhciBzaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGlmIChfbGVuZ3RoKSB7XG4gICAgICAgIF9sZW5ndGggLT0gMTtcbiAgICAgICAgc2hhcGVDb2xsZWN0aW9uID0gcG9vbFtfbGVuZ3RoXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoYXBlQ29sbGVjdGlvbiA9IG5ldyBTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxlYXNlKHNoYXBlQ29sbGVjdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZVBvb2wucmVsZWFzZShzaGFwZUNvbGxlY3Rpb24uc2hhcGVzW2ldKTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGggPSAwO1xuXG4gICAgICBpZiAoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xuICAgICAgICBwb29sID0gcG9vbGluZ1tcImRvdWJsZVwiXShwb29sKTtcbiAgICAgICAgX21heExlbmd0aCAqPSAyO1xuICAgICAgfVxuXG4gICAgICBwb29sW19sZW5ndGhdID0gc2hhcGVDb2xsZWN0aW9uO1xuICAgICAgX2xlbmd0aCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdEZyYW1lID0gLTk5OTk5OTtcblxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHByZXZpb3VzVmFsdWUsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xuICAgICAgdmFyIGtleVByb3BTO1xuICAgICAgdmFyIGtleVByb3BFO1xuICAgICAgdmFyIGlzSG9sZDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgakxlbjtcbiAgICAgIHZhciBrTGVuO1xuICAgICAgdmFyIHBlcmM7XG4gICAgICB2YXIgdmVydGV4VmFsdWU7XG4gICAgICB2YXIga2YgPSB0aGlzLmtleWZyYW1lcztcblxuICAgICAgaWYgKGZyYW1lTnVtIDwga2ZbMF0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmWzBdLnNbMF07XG4gICAgICAgIGlzSG9sZCA9IHRydWU7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPj0ga2Zba2YubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZSkge1xuICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDFdLnMgPyBrZltrZi5sZW5ndGggLSAxXS5zWzBdIDoga2Zba2YubGVuZ3RoIC0gMl0uZVswXTtcbiAgICAgICAgLyogaWYoa2Zba2YubGVuZ3RoIC0gMV0ucyl7XHJcbiAgICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcclxuICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAga2V5UHJvcFMgPSBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xyXG4gICAgICAgICAgICAgIH0gKi9cblxuICAgICAgICBpc0hvbGQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcbiAgICAgICAgdmFyIGxlbiA9IGtmLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgICAgdmFyIGtleURhdGE7XG4gICAgICAgIHZhciBuZXh0S2V5RGF0YTtcbiAgICAgICAgdmFyIGtleWZyYW1lTWV0YWRhdGE7XG5cbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICBrZXlEYXRhID0ga2ZbaV07XG4gICAgICAgICAgbmV4dEtleURhdGEgPSBrZltpICsgMV07XG5cbiAgICAgICAgICBpZiAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGtleWZyYW1lTWV0YWRhdGEgPSB0aGlzLmtleWZyYW1lc01ldGFkYXRhW2ldIHx8IHt9O1xuICAgICAgICBpc0hvbGQgPSBrZXlEYXRhLmggPT09IDE7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcblxuICAgICAgICBpZiAoIWlzSG9sZCkge1xuICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuYztcblxuICAgICAgICAgICAgaWYgKGtleWZyYW1lTWV0YWRhdGEuX19mbmN0KSB7XG4gICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsIGtleURhdGEuby55LCBrZXlEYXRhLmkueCwga2V5RGF0YS5pLnkpLmdldDtcbiAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0gKGtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSkpIC8gKG5leHRLZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUgLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGtleVByb3BFID0gbmV4dEtleURhdGEucyA/IG5leHRLZXlEYXRhLnNbMF0gOiBrZXlEYXRhLmVbMF07XG4gICAgICAgIH1cblxuICAgICAgICBrZXlQcm9wUyA9IGtleURhdGEuc1swXTtcbiAgICAgIH1cblxuICAgICAgakxlbiA9IHByZXZpb3VzVmFsdWUuX2xlbmd0aDtcbiAgICAgIGtMZW4gPSBrZXlQcm9wUy5pWzBdLmxlbmd0aDtcbiAgICAgIGNhY2hpbmcubGFzdEluZGV4ID0gaXRlcmF0aW9uSW5kZXg7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMuaVtqXVtrXSA6IGtleVByb3BTLmlbal1ba10gKyAoa2V5UHJvcEUuaVtqXVtrXSAtIGtleVByb3BTLmlbal1ba10pICogcGVyYztcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLmlbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcbiAgICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLm9bal1ba10gOiBrZXlQcm9wUy5vW2pdW2tdICsgKGtleVByb3BFLm9bal1ba10gLSBrZXlQcm9wUy5vW2pdW2tdKSAqIHBlcmM7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZS5vW2pdW2tdID0gdmVydGV4VmFsdWU7XG4gICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDoga2V5UHJvcFMudltqXVtrXSArIChrZXlQcm9wRS52W2pdW2tdIC0ga2V5UHJvcFMudltqXVtrXSkgKiBwZXJjO1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lKCkge1xuICAgICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgICB2YXIgaW5pdFRpbWUgPSB0aGlzLmtleWZyYW1lc1swXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGxhc3RGcmFtZSA9IHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lO1xuXG4gICAgICBpZiAoIShsYXN0RnJhbWUgIT09IGluaXRGcmFtZSAmJiAobGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSB8fCBsYXN0RnJhbWUgPiBlbmRUaW1lICYmIGZyYW1lTnVtID4gZW5kVGltZSkpKSB7XG4gICAgICAgIC8vLyAvXG4gICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEluZGV4ID0gbGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA6IDA7XG4gICAgICAgIHRoaXMuaW50ZXJwb2xhdGVTaGFwZShmcmFtZU51bSwgdGhpcy5wdiwgdGhpcy5fY2FjaGluZyk7IC8vLyAvXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XG4gICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNldFNoYXBlKCkge1xuICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hhcGVzRXF1YWwoc2hhcGUxLCBzaGFwZTIpIHtcbiAgICAgIGlmIChzaGFwZTEuX2xlbmd0aCAhPT0gc2hhcGUyLl9sZW5ndGggfHwgc2hhcGUxLmMgIT09IHNoYXBlMi5jKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUxLl9sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGUxLnZbaV1bMF0gIT09IHNoYXBlMi52W2ldWzBdIHx8IHNoYXBlMS52W2ldWzFdICE9PSBzaGFwZTIudltpXVsxXSB8fCBzaGFwZTEub1tpXVswXSAhPT0gc2hhcGUyLm9baV1bMF0gfHwgc2hhcGUxLm9baV1bMV0gIT09IHNoYXBlMi5vW2ldWzFdIHx8IHNoYXBlMS5pW2ldWzBdICE9PSBzaGFwZTIuaVtpXVswXSB8fCBzaGFwZTEuaVtpXVsxXSAhPT0gc2hhcGUyLmlbaV1bMV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VlZhbHVlKG5ld1BhdGgpIHtcbiAgICAgIGlmICghc2hhcGVzRXF1YWwodGhpcy52LCBuZXdQYXRoKSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUobmV3UGF0aCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NFZmZlY3RzU2VxdWVuY2UoKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubG9jaykge1xuICAgICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvY2sgPSB0cnVlO1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICB2YXIgZmluYWxWYWx1ZTtcblxuICAgICAgaWYgKHRoaXMua2YpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMucHY7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5rcykge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLmtzLms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5kYXRhLnB0Lms7XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZVtpXShmaW5hbFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRWVmFsdWUoZmluYWxWYWx1ZSk7XG4gICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUocGF0aERhdGEpO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICAgIH1cblxuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmludGVycG9sYXRlU2hhcGUgPSBpbnRlcnBvbGF0ZVNoYXBlO1xuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XG4gICAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgdGhpcy5rZiA9IHRydWU7XG4gICAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodGhpcy5rZXlmcmFtZXNbMF0uc1swXS5jLCBsZW4pO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMubGFzdEZyYW1lID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XG4gICAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIH1cblxuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuXG4gICAgdmFyIEVsbFNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY1BvaW50ID0gcm91bmRDb3JuZXI7XG5cbiAgICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDQpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydEVsbFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydEVsbFRvUGF0aDogZnVuY3Rpb24gY29udmVydEVsbFRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXTtcbiAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAudlsxXTtcbiAgICAgICAgICB2YXIgczAgPSB0aGlzLnMudlswXSAvIDI7XG4gICAgICAgICAgdmFyIHMxID0gdGhpcy5zLnZbMV0gLyAyO1xuXG4gICAgICAgICAgdmFyIF9jdyA9IHRoaXMuZCAhPT0gMztcblxuICAgICAgICAgIHZhciBfdiA9IHRoaXMudjtcbiAgICAgICAgICBfdi52WzBdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YudlsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LnZbMV1bMV0gPSBwMTtcbiAgICAgICAgICBfdi52WzJdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlsyXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3YudlszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92LnZbM11bMV0gPSBwMTtcbiAgICAgICAgICBfdi5pWzBdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3YuaVswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LmlbMV1bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICAgIF92LmlbMl1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi5pWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3YuaVszXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xuICAgICAgICAgIF92Lm9bMF1bMV0gPSBwMSAtIHMxO1xuICAgICAgICAgIF92Lm9bMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcbiAgICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzJdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1syXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92Lm9bM11bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gRWxsU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFN0YXJTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDApO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcblxuICAgICAgICBpZiAoZGF0YS5zeSA9PT0gMSkge1xuICAgICAgICAgIHRoaXMuaXIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlyLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmlzID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5pcywgMCwgMC4wMSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoID0gdGhpcy5jb252ZXJ0U3RhclRvUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRQb2x5Z29uVG9QYXRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vcyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3MsIDAsIDAuMDEsIHRoaXMpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udmVydFN0YXJUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRTdGFyVG9QYXRoKCkge1xuICAgICAgICAgIHZhciBudW1QdHMgPSBNYXRoLmZsb29yKHRoaXMucHQudikgKiAyO1xuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gbnVtUHRzO1xuICAgICAgICAgIC8qIHRoaXMudi52Lmxlbmd0aCA9IG51bVB0cztcclxuICAgICAgICAgICAgICAgICAgdGhpcy52LmkubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLnYuby5sZW5ndGggPSBudW1QdHM7ICovXG5cbiAgICAgICAgICB2YXIgbG9uZ0ZsYWcgPSB0cnVlO1xuICAgICAgICAgIHZhciBsb25nUmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciBzaG9ydFJhZCA9IHRoaXMuaXIudjtcbiAgICAgICAgICB2YXIgbG9uZ1JvdW5kID0gdGhpcy5vcy52O1xuICAgICAgICAgIHZhciBzaG9ydFJvdW5kID0gdGhpcy5pcy52O1xuICAgICAgICAgIHZhciBsb25nUGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiBsb25nUmFkIC8gKG51bVB0cyAqIDIpO1xuICAgICAgICAgIHZhciBzaG9ydFBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogc2hvcnRSYWQgLyAobnVtUHRzICogMik7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIHJhZDtcbiAgICAgICAgICB2YXIgcm91bmRuZXNzO1xuICAgICAgICAgIHZhciBwZXJpbVNlZ21lbnQ7XG4gICAgICAgICAgdmFyIGN1cnJlbnRBbmcgPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcbiAgICAgICAgICB2YXIgZGlyID0gdGhpcy5kYXRhLmQgPT09IDMgPyAtMSA6IDE7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICByYWQgPSBsb25nRmxhZyA/IGxvbmdSYWQgOiBzaG9ydFJhZDtcbiAgICAgICAgICAgIHJvdW5kbmVzcyA9IGxvbmdGbGFnID8gbG9uZ1JvdW5kIDogc2hvcnRSb3VuZDtcbiAgICAgICAgICAgIHBlcmltU2VnbWVudCA9IGxvbmdGbGFnID8gbG9uZ1BlcmltU2VnbWVudCA6IHNob3J0UGVyaW1TZWdtZW50O1xuICAgICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciB5ID0gcmFkICogTWF0aC5zaW4oY3VycmVudEFuZyk7XG4gICAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeSAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteCAvIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgIHggKz0gK3RoaXMucC52WzBdO1xuICAgICAgICAgICAgeSArPSArdGhpcy5wLnZbMV07XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQoeCwgeSwgeCAtIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5IC0gb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHggKyBveCAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeSArIG95ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCBpLCB0cnVlKTtcbiAgICAgICAgICAgIC8qIHRoaXMudi52W2ldID0gW3gseV07XHJcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuaVtpXSA9IFt4K294KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHkrb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52Lm9baV0gPSBbeC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcclxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gbnVtUHRzOyAqL1xuXG4gICAgICAgICAgICBsb25nRmxhZyA9ICFsb25nRmxhZztcbiAgICAgICAgICAgIGN1cnJlbnRBbmcgKz0gYW5nbGUgKiBkaXI7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb252ZXJ0UG9seWdvblRvUGF0aDogZnVuY3Rpb24gY29udmVydFBvbHlnb25Ub1BhdGgoKSB7XG4gICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAvIG51bVB0cztcbiAgICAgICAgICB2YXIgcmFkID0gdGhpcy5vci52O1xuICAgICAgICAgIHZhciByb3VuZG5lc3MgPSB0aGlzLm9zLnY7XG4gICAgICAgICAgdmFyIHBlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogcmFkIC8gKG51bVB0cyAqIDQpO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgKiAwLjU7XG4gICAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xuICAgICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnBhdGhzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgdGhpcy5wYXRoc1swXSA9IHRoaXMudjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5KTtcbiAgICAgIHJldHVybiBTdGFyU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuXG4gICAgdmFyIFJlY3RTaGFwZVByb3BlcnR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZnVuY3Rpb24gUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LmMgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMuciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuciwgMCwgMCwgdGhpcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRSZWN0VG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29udmVydFJlY3RUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRSZWN0VG9QYXRoKCkge1xuICAgICAgICAgIHZhciBwMCA9IHRoaXMucC52WzBdO1xuICAgICAgICAgIHZhciBwMSA9IHRoaXMucC52WzFdO1xuICAgICAgICAgIHZhciB2MCA9IHRoaXMucy52WzBdIC8gMjtcbiAgICAgICAgICB2YXIgdjEgPSB0aGlzLnMudlsxXSAvIDI7XG4gICAgICAgICAgdmFyIHJvdW5kID0gYm1NaW4odjAsIHYxLCB0aGlzLnIudik7XG4gICAgICAgICAgdmFyIGNQb2ludCA9IHJvdW5kICogKDEgLSByb3VuZENvcm5lcik7XG4gICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSAwO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZCA9PT0gMiB8fCB0aGlzLmQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIGNQb2ludCwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIDEsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwLCBwMSArIHYxLCAyKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwIC0gdjAsIHAxIC0gdjEsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIDAsIHRydWUpO1xuXG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCAtIHYwLCBwMSAtIHYxICsgY1BvaW50LCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIGNQb2ludCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCArIHYwLCBwMSArIHYxIC0gY1BvaW50LCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCBwMCAtIHYwLCBwMSAtIHYxLCAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwIC0gdjAsIHAxICsgdjEsIDIsIHRydWUpO1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgKyB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgKyB2MSwgcDAgKyB2MCwgcDEgKyB2MSwgMywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xuICAgICAgcmV0dXJuIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBnZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSkge1xuICAgICAgdmFyIHByb3A7XG5cbiAgICAgIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICAgICAgdmFyIGRhdGFQcm9wID0gdHlwZSA9PT0gMyA/IGRhdGEucHQgOiBkYXRhLmtzO1xuICAgICAgICB2YXIga2V5cyA9IGRhdGFQcm9wLms7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvcCA9IG5ldyBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AgPSBuZXcgU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgIHByb3AgPSBuZXcgUmVjdFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA3KSB7XG4gICAgICAgIHByb3AgPSBuZXcgU3RhclNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wLmspIHtcbiAgICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9wO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtleWZyYW1lZFNoYXBlUHJvcGVydHk7XG4gICAgfVxuXG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuZ2V0U2hhcGVQcm9wID0gZ2V0U2hhcGVQcm9wO1xuICAgIG9iLmdldENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIG9iLmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24gPSBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uO1xuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIC8qIVxyXG4gICBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxyXG4gICAoYykgRXBpc3RlbWV4IDIwMTQtMjAxNVxyXG4gICB3d3cuZXBpc3RlbWV4LmNvbVxyXG4gICBCeSBLZW4gRnlyc3RlbmJlcmdcclxuICAgQ29udHJpYnV0aW9ucyBieSBsZWVvbml5YS5cclxuICAgTGljZW5zZTogTUlULCBoZWFkZXIgcmVxdWlyZWQuXHJcbiAgICovXG5cbiAgLyoqXHJcbiAgICogMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGlkZW50aXR5IG1hdHJpeC5cclxuICAgKlxyXG4gICAqIFRoZSBtYXRyaXggY2FuIHN5bmNocm9uaXplIGEgY2FudmFzIGNvbnRleHQgYnkgc3VwcGx5aW5nIHRoZSBjb250ZXh0XHJcbiAgICogYXMgYW4gYXJndW1lbnQsIG9yIGxhdGVyIGFwcGx5IGN1cnJlbnQgYWJzb2x1dGUgdHJhbnNmb3JtIHRvIGFuXHJcbiAgICogZXhpc3RpbmcgY29udGV4dC5cclxuICAgKlxyXG4gICAqIEFsbCB2YWx1ZXMgYXJlIGhhbmRsZWQgYXMgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjb250ZXh0XSAtIE9wdGlvbmFsIGNvbnRleHQgdG8gc3luYyB3aXRoIE1hdHJpeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGEgLSBzY2FsZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gYiAtIHNoZWFyIHlcclxuICAgKiBAcHJvcCB7bnVtYmVyfSBjIC0gc2hlYXIgeFxyXG4gICAqIEBwcm9wIHtudW1iZXJ9IGQgLSBzY2FsZSB5XHJcbiAgICogQHByb3Age251bWJlcn0gZSAtIHRyYW5zbGF0ZSB4XHJcbiAgICogQHByb3Age251bWJlcn0gZiAtIHRyYW5zbGF0ZSB5XHJcbiAgICogQHByb3Age0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBbY29udGV4dD1udWxsXSAtIHNldCBvciBnZXQgY3VycmVudCBjYW52YXMgY29udGV4dFxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqL1xuXG4gIHZhciBNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgX3NpbiA9IE1hdGguc2luO1xuICAgIHZhciBfdGFuID0gTWF0aC50YW47XG4gICAgdmFyIF9ybmQgPSBNYXRoLnJvdW5kO1xuXG4gICAgZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnByb3BzWzBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMV0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1syXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbNF0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s1XSA9IDE7XG4gICAgICB0aGlzLnByb3BzWzZdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbN10gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s4XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzldID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTBdID0gMTtcbiAgICAgIHRoaXMucHJvcHNbMTFdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTJdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTNdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTRdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMTVdID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJvdGF0ZShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCBtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWShhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAwLCBtU2luLCAwLCAwLCAxLCAwLCAwLCAtbVNpbiwgMCwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm90YXRlWihhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuXG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuXG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hlYXIoc3gsIHN5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCBzeSwgc3gsIDEsIDAsIDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXcoYXgsIGF5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGVhcihfdGFuKGF4KSwgX3RhbihheSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNrZXdGcm9tQXhpcyhheCwgYW5nbGUpIHtcbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG5cbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG5cbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIDAsIDAsIC1tU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKS5fdCgxLCAwLCAwLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSkuX3QobUNvcywgLW1TaW4sIDAsIDAsIG1TaW4sIG1Db3MsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpOyAvLyByZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAtbVNpbiwgbUNvcywgMCwgMCkuX3QoMSwgMCwgX3RhbihheCksIDEsIDAsIDApLl90KG1Db3MsIC1tU2luLCBtU2luLCBtQ29zLCAwLCAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XG4gICAgICBpZiAoIXN6ICYmIHN6ICE9PSAwKSB7XG4gICAgICAgIHN6ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN4ID09PSAxICYmIHN5ID09PSAxICYmIHN6ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdChzeCwgMCwgMCwgMCwgMCwgc3ksIDAsIDAsIDAsIDAsIHN6LCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCkge1xuICAgICAgdGhpcy5wcm9wc1swXSA9IGE7XG4gICAgICB0aGlzLnByb3BzWzFdID0gYjtcbiAgICAgIHRoaXMucHJvcHNbMl0gPSBjO1xuICAgICAgdGhpcy5wcm9wc1szXSA9IGQ7XG4gICAgICB0aGlzLnByb3BzWzRdID0gZTtcbiAgICAgIHRoaXMucHJvcHNbNV0gPSBmO1xuICAgICAgdGhpcy5wcm9wc1s2XSA9IGc7XG4gICAgICB0aGlzLnByb3BzWzddID0gaDtcbiAgICAgIHRoaXMucHJvcHNbOF0gPSBpO1xuICAgICAgdGhpcy5wcm9wc1s5XSA9IGo7XG4gICAgICB0aGlzLnByb3BzWzEwXSA9IGs7XG4gICAgICB0aGlzLnByb3BzWzExXSA9IGw7XG4gICAgICB0aGlzLnByb3BzWzEyXSA9IG07XG4gICAgICB0aGlzLnByb3BzWzEzXSA9IG47XG4gICAgICB0aGlzLnByb3BzWzE0XSA9IG87XG4gICAgICB0aGlzLnByb3BzWzE1XSA9IHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5LCB0eikge1xuICAgICAgdHogPSB0eiB8fCAwO1xuXG4gICAgICBpZiAodHggIT09IDAgfHwgdHkgIT09IDAgfHwgdHogIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3QoMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgdHgsIHR5LCB0eiwgMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybShhMiwgYjIsIGMyLCBkMiwgZTIsIGYyLCBnMiwgaDIsIGkyLCBqMiwgazIsIGwyLCBtMiwgbjIsIG8yLCBwMikge1xuICAgICAgdmFyIF9wID0gdGhpcy5wcm9wcztcblxuICAgICAgaWYgKGEyID09PSAxICYmIGIyID09PSAwICYmIGMyID09PSAwICYmIGQyID09PSAwICYmIGUyID09PSAwICYmIGYyID09PSAxICYmIGcyID09PSAwICYmIGgyID09PSAwICYmIGkyID09PSAwICYmIGoyID09PSAwICYmIGsyID09PSAxICYmIGwyID09PSAwKSB7XG4gICAgICAgIC8vIE5PVEU6IGNvbW1lbnRpbmcgdGhpcyBjb25kaXRpb24gYmVjYXVzZSBUdXJib0ZhbiBkZW9wdGltaXplcyBjb2RlIHdoZW4gcHJlc2VudFxuICAgICAgICAvLyBpZihtMiAhPT0gMCB8fCBuMiAhPT0gMCB8fCBvMiAhPT0gMCl7XG4gICAgICAgIF9wWzEyXSA9IF9wWzEyXSAqIGEyICsgX3BbMTVdICogbTI7XG4gICAgICAgIF9wWzEzXSA9IF9wWzEzXSAqIGYyICsgX3BbMTVdICogbjI7XG4gICAgICAgIF9wWzE0XSA9IF9wWzE0XSAqIGsyICsgX3BbMTVdICogbzI7XG4gICAgICAgIF9wWzE1XSAqPSBwMjsgLy8gfVxuXG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGExID0gX3BbMF07XG4gICAgICB2YXIgYjEgPSBfcFsxXTtcbiAgICAgIHZhciBjMSA9IF9wWzJdO1xuICAgICAgdmFyIGQxID0gX3BbM107XG4gICAgICB2YXIgZTEgPSBfcFs0XTtcbiAgICAgIHZhciBmMSA9IF9wWzVdO1xuICAgICAgdmFyIGcxID0gX3BbNl07XG4gICAgICB2YXIgaDEgPSBfcFs3XTtcbiAgICAgIHZhciBpMSA9IF9wWzhdO1xuICAgICAgdmFyIGoxID0gX3BbOV07XG4gICAgICB2YXIgazEgPSBfcFsxMF07XG4gICAgICB2YXIgbDEgPSBfcFsxMV07XG4gICAgICB2YXIgbTEgPSBfcFsxMl07XG4gICAgICB2YXIgbjEgPSBfcFsxM107XG4gICAgICB2YXIgbzEgPSBfcFsxNF07XG4gICAgICB2YXIgcDEgPSBfcFsxNV07XG4gICAgICAvKiBtYXRyaXggb3JkZXIgKGNhbnZhcyBjb21wYXRpYmxlKTpcclxuICAgICAgICAgICAqIGFjZVxyXG4gICAgICAgICAgICogYmRmXHJcbiAgICAgICAgICAgKiAwMDFcclxuICAgICAgICAgICAqL1xuXG4gICAgICBfcFswXSA9IGExICogYTIgKyBiMSAqIGUyICsgYzEgKiBpMiArIGQxICogbTI7XG4gICAgICBfcFsxXSA9IGExICogYjIgKyBiMSAqIGYyICsgYzEgKiBqMiArIGQxICogbjI7XG4gICAgICBfcFsyXSA9IGExICogYzIgKyBiMSAqIGcyICsgYzEgKiBrMiArIGQxICogbzI7XG4gICAgICBfcFszXSA9IGExICogZDIgKyBiMSAqIGgyICsgYzEgKiBsMiArIGQxICogcDI7XG4gICAgICBfcFs0XSA9IGUxICogYTIgKyBmMSAqIGUyICsgZzEgKiBpMiArIGgxICogbTI7XG4gICAgICBfcFs1XSA9IGUxICogYjIgKyBmMSAqIGYyICsgZzEgKiBqMiArIGgxICogbjI7XG4gICAgICBfcFs2XSA9IGUxICogYzIgKyBmMSAqIGcyICsgZzEgKiBrMiArIGgxICogbzI7XG4gICAgICBfcFs3XSA9IGUxICogZDIgKyBmMSAqIGgyICsgZzEgKiBsMiArIGgxICogcDI7XG4gICAgICBfcFs4XSA9IGkxICogYTIgKyBqMSAqIGUyICsgazEgKiBpMiArIGwxICogbTI7XG4gICAgICBfcFs5XSA9IGkxICogYjIgKyBqMSAqIGYyICsgazEgKiBqMiArIGwxICogbjI7XG4gICAgICBfcFsxMF0gPSBpMSAqIGMyICsgajEgKiBnMiArIGsxICogazIgKyBsMSAqIG8yO1xuICAgICAgX3BbMTFdID0gaTEgKiBkMiArIGoxICogaDIgKyBrMSAqIGwyICsgbDEgKiBwMjtcbiAgICAgIF9wWzEyXSA9IG0xICogYTIgKyBuMSAqIGUyICsgbzEgKiBpMiArIHAxICogbTI7XG4gICAgICBfcFsxM10gPSBtMSAqIGIyICsgbjEgKiBmMiArIG8xICogajIgKyBwMSAqIG4yO1xuICAgICAgX3BbMTRdID0gbTEgKiBjMiArIG4xICogZzIgKyBvMSAqIGsyICsgcDEgKiBvMjtcbiAgICAgIF9wWzE1XSA9IG0xICogZDIgKyBuMSAqIGgyICsgbzEgKiBsMiArIHAxICogcDI7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuICAgICAgdmFyIG1hdHJpeFByb3BzID0gbWF0cml4LnByb3BzO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG1hdHJpeFByb3BzWzBdLCBtYXRyaXhQcm9wc1sxXSwgbWF0cml4UHJvcHNbMl0sIG1hdHJpeFByb3BzWzNdLCBtYXRyaXhQcm9wc1s0XSwgbWF0cml4UHJvcHNbNV0sIG1hdHJpeFByb3BzWzZdLCBtYXRyaXhQcm9wc1s3XSwgbWF0cml4UHJvcHNbOF0sIG1hdHJpeFByb3BzWzldLCBtYXRyaXhQcm9wc1sxMF0sIG1hdHJpeFByb3BzWzExXSwgbWF0cml4UHJvcHNbMTJdLCBtYXRyaXhQcm9wc1sxM10sIG1hdHJpeFByb3BzWzE0XSwgbWF0cml4UHJvcHNbMTVdKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0lkZW50aXR5KCkge1xuICAgICAgaWYgKCF0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQpIHtcbiAgICAgICAgdGhpcy5faWRlbnRpdHkgPSAhKHRoaXMucHJvcHNbMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxXSAhPT0gMCB8fCB0aGlzLnByb3BzWzJdICE9PSAwIHx8IHRoaXMucHJvcHNbM10gIT09IDAgfHwgdGhpcy5wcm9wc1s0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzVdICE9PSAxIHx8IHRoaXMucHJvcHNbNl0gIT09IDAgfHwgdGhpcy5wcm9wc1s3XSAhPT0gMCB8fCB0aGlzLnByb3BzWzhdICE9PSAwIHx8IHRoaXMucHJvcHNbOV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxMV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMl0gIT09IDAgfHwgdGhpcy5wcm9wc1sxM10gIT09IDAgfHwgdGhpcy5wcm9wc1sxNF0gIT09IDAgfHwgdGhpcy5wcm9wc1sxNV0gIT09IDEpO1xuICAgICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBpZiAobWF0ci5wcm9wc1tpXSAhPT0gdGhpcy5wcm9wc1tpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUobWF0cikge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIG1hdHIucHJvcHNbaV0gPSB0aGlzLnByb3BzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9uZUZyb21Qcm9wcyhwcm9wcykge1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvcHNbaV0gPSBwcm9wc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvUG9pbnQoeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXG4gICAgICAgIHk6IHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxuICAgICAgICB6OiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1cbiAgICAgIH07XG4gICAgICAvKiByZXR1cm4ge1xyXG4gICAgICAgICAgIHg6IHggKiBtZS5hICsgeSAqIG1lLmMgKyBtZS5lLFxyXG4gICAgICAgICAgIHk6IHggKiBtZS5iICsgeSAqIG1lLmQgKyBtZS5mXHJcbiAgICAgICAgICAgfTsgKi9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRvWCh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1koeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SW52ZXJzZU1hdHJpeCgpIHtcbiAgICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzVdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbNF07XG4gICAgICB2YXIgYSA9IHRoaXMucHJvcHNbNV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBiID0gLXRoaXMucHJvcHNbMV0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBjID0gLXRoaXMucHJvcHNbNF0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBkID0gdGhpcy5wcm9wc1swXSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGUgPSAodGhpcy5wcm9wc1s0XSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1s1XSAqIHRoaXMucHJvcHNbMTJdKSAvIGRldGVybWluYW50O1xuICAgICAgdmFyIGYgPSAtKHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzEzXSAtIHRoaXMucHJvcHNbMV0gKiB0aGlzLnByb3BzWzEyXSkgLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1swXSA9IGE7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzFdID0gYjtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbNF0gPSBjO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1s1XSA9IGQ7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEyXSA9IGU7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzEzXSA9IGY7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZlcnNlUG9pbnQocHQpIHtcbiAgICAgIHZhciBpbnZlcnNlTWF0cml4ID0gdGhpcy5nZXRJbnZlcnNlTWF0cml4KCk7XG4gICAgICByZXR1cm4gaW52ZXJzZU1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShwdFswXSwgcHRbMV0sIHB0WzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgICAgdmFyIHJldFB0cyA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmV0UHRzW2ldID0gaW52ZXJzZVBvaW50KHB0c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRQdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUb1RyaXBsZVBvaW50cyhwdDEsIHB0MiwgcHQzKSB7XG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDYpO1xuXG4gICAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgYXJyWzBdID0gcHQxWzBdO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMV07XG4gICAgICAgIGFyclsyXSA9IHB0MlswXTtcbiAgICAgICAgYXJyWzNdID0gcHQyWzFdO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF07XG4gICAgICAgIGFycls1XSA9IHB0M1sxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMucHJvcHNbMF07XG4gICAgICAgIHZhciBwMSA9IHRoaXMucHJvcHNbMV07XG4gICAgICAgIHZhciBwNCA9IHRoaXMucHJvcHNbNF07XG4gICAgICAgIHZhciBwNSA9IHRoaXMucHJvcHNbNV07XG4gICAgICAgIHZhciBwMTIgPSB0aGlzLnByb3BzWzEyXTtcbiAgICAgICAgdmFyIHAxMyA9IHRoaXMucHJvcHNbMTNdO1xuICAgICAgICBhcnJbMF0gPSBwdDFbMF0gKiBwMCArIHB0MVsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbMV0gPSBwdDFbMF0gKiBwMSArIHB0MVsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbMl0gPSBwdDJbMF0gKiBwMCArIHB0MlsxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbM10gPSBwdDJbMF0gKiBwMSArIHB0MlsxXSAqIHA1ICsgcDEzO1xuICAgICAgICBhcnJbNF0gPSBwdDNbMF0gKiBwMCArIHB0M1sxXSAqIHA0ICsgcDEyO1xuICAgICAgICBhcnJbNV0gPSBwdDNbMF0gKiBwMSArIHB0M1sxXSAqIHA1ICsgcDEzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludEFycmF5KHgsIHksIHopIHtcbiAgICAgIHZhciBhcnI7XG5cbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICBhcnIgPSBbeCwgeSwgel07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIgPSBbeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sIHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLCB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICByZXR1cm4geCArICcsJyArIHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCgoeCAqIF9wWzBdICsgeSAqIF9wWzRdICsgX3BbMTJdKSAqIDEwMCkgLyAxMDAgKyAnLCcgKyBNYXRoLnJvdW5kKCh4ICogX3BbMV0gKyB5ICogX3BbNV0gKyBfcFsxM10pICogMTAwKSAvIDEwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0NTUygpIHtcbiAgICAgIC8vIERvZXNuJ3QgbWFrZSBtdWNoIHNlbnNlIHRvIGFkZCB0aGlzIG9wdGltaXphdGlvbi4gSWYgaXQgaXMgYW4gaWRlbnRpdHkgbWF0cml4LCBpdCdzIHZlcnkgbGlrZWx5IHRoaXMgd2lsbCBnZXQgY2FsbGVkIG9ubHkgb25jZSBzaW5jZSBpdCB3b24ndCBiZSBrZXlmcmFtZWQuXG5cbiAgICAgIC8qIGlmKHRoaXMuaXNJZGVudGl0eSgpKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgfSAqL1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgIHZhciBjc3NWYWx1ZSA9ICdtYXRyaXgzZCgnO1xuICAgICAgdmFyIHYgPSAxMDAwMDtcblxuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBjc3NWYWx1ZSArPSBfcm5kKHByb3BzW2ldICogdikgLyB2O1xuICAgICAgICBjc3NWYWx1ZSArPSBpID09PSAxNSA/ICcpJyA6ICcsJztcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3NzVmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRNYXRyaXhQcm9wZXJ0eSh2YWwpIHtcbiAgICAgIHZhciB2ID0gMTAwMDA7XG5cbiAgICAgIGlmICh2YWwgPCAwLjAwMDAwMSAmJiB2YWwgPiAwIHx8IHZhbCA+IC0wLjAwMDAwMSAmJiB2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBfcm5kKHZhbCAqIHYpIC8gdjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0bzJkQ1NTKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cblxuICAgICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgICB9ICovXG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgICB2YXIgX2EgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzBdKTtcblxuICAgICAgdmFyIF9iID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxXSk7XG5cbiAgICAgIHZhciBfYyA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbNF0pO1xuXG4gICAgICB2YXIgX2QgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzVdKTtcblxuICAgICAgdmFyIF9lID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxMl0pO1xuXG4gICAgICB2YXIgX2YgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzEzXSk7XG5cbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyBfYSArICcsJyArIF9iICsgJywnICsgX2MgKyAnLCcgKyBfZCArICcsJyArIF9lICsgJywnICsgX2YgKyAnKSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldDtcbiAgICAgIHRoaXMucm90YXRlID0gcm90YXRlO1xuICAgICAgdGhpcy5yb3RhdGVYID0gcm90YXRlWDtcbiAgICAgIHRoaXMucm90YXRlWSA9IHJvdGF0ZVk7XG4gICAgICB0aGlzLnJvdGF0ZVogPSByb3RhdGVaO1xuICAgICAgdGhpcy5za2V3ID0gc2tldztcbiAgICAgIHRoaXMuc2tld0Zyb21BeGlzID0gc2tld0Zyb21BeGlzO1xuICAgICAgdGhpcy5zaGVhciA9IHNoZWFyO1xuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0gPSBzZXRUcmFuc2Zvcm07XG4gICAgICB0aGlzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbiAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5tdWx0aXBseSA9IG11bHRpcGx5O1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnQgPSBhcHBseVRvUG9pbnQ7XG4gICAgICB0aGlzLmFwcGx5VG9YID0gYXBwbHlUb1g7XG4gICAgICB0aGlzLmFwcGx5VG9ZID0gYXBwbHlUb1k7XG4gICAgICB0aGlzLmFwcGx5VG9aID0gYXBwbHlUb1o7XG4gICAgICB0aGlzLmFwcGx5VG9Qb2ludEFycmF5ID0gYXBwbHlUb1BvaW50QXJyYXk7XG4gICAgICB0aGlzLmFwcGx5VG9UcmlwbGVQb2ludHMgPSBhcHBseVRvVHJpcGxlUG9pbnRzO1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnRTdHJpbmdpZmllZCA9IGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkO1xuICAgICAgdGhpcy50b0NTUyA9IHRvQ1NTO1xuICAgICAgdGhpcy50bzJkQ1NTID0gdG8yZENTUztcbiAgICAgIHRoaXMuY2xvbmUgPSBjbG9uZTtcbiAgICAgIHRoaXMuY2xvbmVGcm9tUHJvcHMgPSBjbG9uZUZyb21Qcm9wcztcbiAgICAgIHRoaXMuZXF1YWxzID0gZXF1YWxzO1xuICAgICAgdGhpcy5pbnZlcnNlUG9pbnRzID0gaW52ZXJzZVBvaW50cztcbiAgICAgIHRoaXMuaW52ZXJzZVBvaW50ID0gaW52ZXJzZVBvaW50O1xuICAgICAgdGhpcy5nZXRJbnZlcnNlTWF0cml4ID0gZ2V0SW52ZXJzZU1hdHJpeDtcbiAgICAgIHRoaXMuX3QgPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHRoaXMuaXNJZGVudGl0eSA9IGlzSWRlbnRpdHk7XG4gICAgICB0aGlzLl9pZGVudGl0eSA9IHRydWU7XG4gICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucHJvcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMTYpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDMob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMyA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDMgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQzKG9iaik7IH1cbiAgdmFyIGxvdHRpZSA9IHt9O1xuICB2YXIgc3RhbmRhbG9uZSA9ICdfX1tTVEFOREFMT05FXV9fJztcbiAgdmFyIGFuaW1hdGlvbkRhdGEgPSAnX19bQU5JTUFUSU9OREFUQV1fXyc7XG4gIHZhciByZW5kZXJlciA9ICcnO1xuXG4gIGZ1bmN0aW9uIHNldExvY2F0aW9uKGhyZWYpIHtcbiAgICBzZXRMb2NhdGlvbkhyZWYoaHJlZik7XG4gIH1cblxuICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKCkge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoYW5pbWF0aW9uRGF0YSwgc3RhbmRhbG9uZSwgcmVuZGVyZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTdWJmcmFtZVJlbmRlcmluZyhmbGFnKSB7XG4gICAgc2V0U3ViZnJhbWVFbmFibGVkKGZsYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuICAgIHNldElkUHJlZml4KHByZWZpeCk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgIGlmIChzdGFuZGFsb25lID09PSB0cnVlKSB7XG4gICAgICBwYXJhbXMuYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuaW1hdGlvbk1hbmFnZXIubG9hZEFuaW1hdGlvbihwYXJhbXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0UXVhbGl0eSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY2FzZSAnbWVkaXVtJzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyg1MCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbG93JzpcbiAgICAgICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cygxMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4odmFsdWUpICYmIHZhbHVlID4gMSkge1xuICAgICAgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpID49IDUwKSB7XG4gICAgICByb3VuZFZhbHVlcyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kVmFsdWVzKHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUGx1Z2luKHR5cGUsIHBsdWdpbikge1xuICAgIGlmICh0eXBlID09PSAnZXhwcmVzc2lvbnMnKSB7XG4gICAgICBzZXRFeHByZXNzaW9uc1BsdWdpbihwbHVnaW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZhY3RvcnkobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAncHJvcGVydHlGYWN0b3J5JzpcbiAgICAgICAgcmV0dXJuIFByb3BlcnR5RmFjdG9yeTtcblxuICAgICAgY2FzZSAnc2hhcGVQcm9wZXJ0eUZhY3RvcnknOlxuICAgICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG5cbiAgICAgIGNhc2UgJ21hdHJpeCc6XG4gICAgICAgIHJldHVybiBNYXRyaXg7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGxvdHRpZS5wbGF5ID0gYW5pbWF0aW9uTWFuYWdlci5wbGF5O1xuICBsb3R0aWUucGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnBhdXNlO1xuICBsb3R0aWUuc2V0TG9jYXRpb25IcmVmID0gc2V0TG9jYXRpb247XG4gIGxvdHRpZS50b2dnbGVQYXVzZSA9IGFuaW1hdGlvbk1hbmFnZXIudG9nZ2xlUGF1c2U7XG4gIGxvdHRpZS5zZXRTcGVlZCA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0U3BlZWQ7XG4gIGxvdHRpZS5zZXREaXJlY3Rpb24gPSBhbmltYXRpb25NYW5hZ2VyLnNldERpcmVjdGlvbjtcbiAgbG90dGllLnN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLnN0b3A7XG4gIGxvdHRpZS5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcbiAgbG90dGllLnJlZ2lzdGVyQW5pbWF0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5yZWdpc3RlckFuaW1hdGlvbjtcbiAgbG90dGllLmxvYWRBbmltYXRpb24gPSBsb2FkQW5pbWF0aW9uO1xuICBsb3R0aWUuc2V0U3ViZnJhbWVSZW5kZXJpbmcgPSBzZXRTdWJmcmFtZVJlbmRlcmluZztcbiAgbG90dGllLnJlc2l6ZSA9IGFuaW1hdGlvbk1hbmFnZXIucmVzaXplOyAvLyBsb3R0aWUuc3RhcnQgPSBzdGFydDtcblxuICBsb3R0aWUuZ29Ub0FuZFN0b3AgPSBhbmltYXRpb25NYW5hZ2VyLmdvVG9BbmRTdG9wO1xuICBsb3R0aWUuZGVzdHJveSA9IGFuaW1hdGlvbk1hbmFnZXIuZGVzdHJveTtcbiAgbG90dGllLnNldFF1YWxpdHkgPSBzZXRRdWFsaXR5O1xuICBsb3R0aWUuaW5Ccm93c2VyID0gaW5Ccm93c2VyO1xuICBsb3R0aWUuaW5zdGFsbFBsdWdpbiA9IGluc3RhbGxQbHVnaW47XG4gIGxvdHRpZS5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLmZyZWV6ZTtcbiAgbG90dGllLnVuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci51bmZyZWV6ZTtcbiAgbG90dGllLnNldFZvbHVtZSA9IGFuaW1hdGlvbk1hbmFnZXIuc2V0Vm9sdW1lO1xuICBsb3R0aWUubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIubXV0ZTtcbiAgbG90dGllLnVubXV0ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5tdXRlO1xuICBsb3R0aWUuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMgPSBhbmltYXRpb25NYW5hZ2VyLmdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xuICBsb3R0aWUudXNlV2ViV29ya2VyID0gc2V0V2ViV29ya2VyO1xuICBsb3R0aWUuc2V0SURQcmVmaXggPSBzZXRQcmVmaXg7XG4gIGxvdHRpZS5fX2dldEZhY3RvcnkgPSBnZXRGYWN0b3J5O1xuICBsb3R0aWUudmVyc2lvbiA9ICc1LjEyLjInO1xuXG4gIGZ1bmN0aW9uIGNoZWNrUmVhZHkoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwpO1xuICAgICAgc2VhcmNoQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUpIHtcbiAgICB2YXIgdmFycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpO1xuXG4gICAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcXVlcnlTdHJpbmcgPSAnJztcblxuICBpZiAoc3RhbmRhbG9uZSkge1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHZhciBpbmRleCA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbXlTY3JpcHQgPSBzY3JpcHRzW2luZGV4XSB8fCB7XG4gICAgICBzcmM6ICcnXG4gICAgfTtcbiAgICBxdWVyeVN0cmluZyA9IG15U2NyaXB0LnNyYyA/IG15U2NyaXB0LnNyYy5yZXBsYWNlKC9eW15cXD9dK1xcPz8vLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuXG4gICAgcmVuZGVyZXIgPSBnZXRRdWVyeVZhcmlhYmxlKCdyZW5kZXJlcicpO1xuICB9XG5cbiAgdmFyIHJlYWR5U3RhdGVDaGVja0ludGVydmFsID0gc2V0SW50ZXJ2YWwoY2hlY2tSZWFkeSwgMTAwKTsgLy8gdGhpcyBhZGRzIGJvZHltb3ZpbiB0byB0aGUgd2luZG93IG9iamVjdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICB0cnkge1xuICAgIGlmICghKCh0eXBlb2YgZXhwb3J0cyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mJDMoZXhwb3J0cykpID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykgJiYgISh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICApIHtcbiAgICAgIHdpbmRvdy5ib2R5bW92aW4gPSBsb3R0aWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHsvL1xuICB9XG5cbiAgdmFyIFNoYXBlTW9kaWZpZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHt9O1xuICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICBvYi5yZWdpc3Rlck1vZGlmaWVyID0gcmVnaXN0ZXJNb2RpZmllcjtcbiAgICBvYi5nZXRNb2RpZmllciA9IGdldE1vZGlmaWVyO1xuXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSwgZmFjdG9yeSkge1xuICAgICAgaWYgKCFtb2RpZmllcnNbbm1dKSB7XG4gICAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1vZGlmaWVyKG5tLCBlbGVtLCBkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IG1vZGlmaWVyc1tubV0oZWxlbSwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpIHt9XG5cbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlVG9Nb2RpZmllciA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAvLyBBZGRpbmcgc2hhcGUgdG8gZHluYW1pYyBwcm9wZXJ0aWVzLiBJdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgYSBzaGFwZSBoYXMgbm8gZWZmZWN0cyBhcHBsaWVkLCB0byByZXNldCBpdCdzIF9tZGYgc3RhdGUgb24gZXZlcnkgdGljay5cbiAgICAgIGRhdGEuc2guY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShkYXRhLnNoKTtcbiAgICAgIHZhciBzaGFwZURhdGEgPSB7XG4gICAgICAgIHNoYXBlOiBkYXRhLnNoLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbjogc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGVEYXRhKTtcbiAgICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVyKHNoYXBlRGF0YSk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKSB7XG4gICAgICAgIGRhdGEuc2V0QXNBbmltYXRlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLCBkYXRhKTtcbiAgICB0aGlzLmZyYW1lSWQgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5rID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NLZXlzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTaGFwZU1vZGlmaWVyKTtcblxuICBmdW5jdGlvbiBUcmltTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFRyaW1Nb2RpZmllcik7XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLCB0aGlzKTtcbiAgICB0aGlzLnNWYWx1ZSA9IDA7XG4gICAgdGhpcy5lVmFsdWUgPSAwO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMubSA9IGRhdGEubTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCB8fCAhIXRoaXMuZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5vLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZVRvTW9kaWZpZXIgPSBmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XG4gICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IFtdO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVFZGdlcyA9IGZ1bmN0aW9uIChzLCBlLCBzaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICAgIGlmIChlIDw9IDEpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiBlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHMgPj0gMSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMgLSAxLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiBzLFxuICAgICAgICBlOiAxXG4gICAgICB9KTtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICBzOiAwLFxuICAgICAgICBlOiBlIC0gMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciBzZWdtZW50T2I7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHNlZ21lbnRPYiA9IHNlZ21lbnRzW2ldO1xuXG4gICAgICBpZiAoIShzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPCBhZGRlZExlbmd0aCB8fCBzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPiBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSkge1xuICAgICAgICB2YXIgc2hhcGVTO1xuICAgICAgICB2YXIgc2hhcGVFO1xuXG4gICAgICAgIGlmIChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPD0gYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZVMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPj0gYWRkZWRMZW5ndGggKyBzaGFwZUxlbmd0aCkge1xuICAgICAgICAgIHNoYXBlRSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVFID0gKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCAtIGFkZGVkTGVuZ3RoKSAvIHNoYXBlTGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVTZWdtZW50cy5wdXNoKFtzaGFwZVMsIHNoYXBlRV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hhcGVTZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbMCwgMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVNlZ21lbnRzO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucmVsZWFzZVBhdGhzRGF0YSA9IGZ1bmN0aW9uIChwYXRoc0RhdGEpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aHNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2VnbWVudHNMZW5ndGhQb29sLnJlbGVhc2UocGF0aHNEYXRhW2ldKTtcbiAgICB9XG5cbiAgICBwYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gcGF0aHNEYXRhO1xuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGU7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBvID0gdGhpcy5vLnYgJSAzNjAgLyAzNjA7XG5cbiAgICAgIGlmIChvIDwgMCkge1xuICAgICAgICBvICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMudiA+IDEpIHtcbiAgICAgICAgcyA9IDEgKyBvO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnMudiA8IDApIHtcbiAgICAgICAgcyA9IDAgKyBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcyA9IHRoaXMucy52ICsgbztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZS52ID4gMSkge1xuICAgICAgICBlID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZS52IDwgMCkge1xuICAgICAgICBlID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlID0gdGhpcy5lLnYgKyBvO1xuICAgICAgfVxuXG4gICAgICBpZiAocyA+IGUpIHtcbiAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgcyA9IGU7XG4gICAgICAgIGUgPSBfcztcbiAgICAgIH1cblxuICAgICAgcyA9IE1hdGgucm91bmQocyAqIDEwMDAwKSAqIDAuMDAwMTtcbiAgICAgIGUgPSBNYXRoLnJvdW5kKGUgKiAxMDAwMCkgKiAwLjAwMDE7XG4gICAgICB0aGlzLnNWYWx1ZSA9IHM7XG4gICAgICB0aGlzLmVWYWx1ZSA9IGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSB0aGlzLnNWYWx1ZTtcbiAgICAgIGUgPSB0aGlzLmVWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBwYXRoc0RhdGE7XG4gICAgdmFyIHBhdGhEYXRhO1xuICAgIHZhciB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgIHZhciB0b3RhbE1vZGlmaWVyTGVuZ3RoID0gMDtcblxuICAgIGlmIChlID09PSBzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUucGF0aHMgPSB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgICBpZiAodGhpcy5fbWRmKSB7XG4gICAgICAgICAgdGhpcy5zaGFwZXNbaV0ucGF0aHNEYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoZSA9PT0gMSAmJiBzID09PSAwIHx8IGUgPT09IDAgJiYgcyA9PT0gMSkpIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgdmFyIHNoYXBlRGF0YTtcbiAgICAgIHZhciBsb2NhbFNoYXBlQ29sbGVjdGlvbjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldOyAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcblxuICAgICAgICBpZiAoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUgJiYgdGhpcy5tICE9PSAyKSB7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlUGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoID0gMDtcblxuICAgICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgc2hhcGVEYXRhLnBhdGhzRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRvdGFsU2hhcGVMZW5ndGggPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aHNEYXRhID0gdGhpcy5yZWxlYXNlUGF0aHNEYXRhKHNoYXBlRGF0YS5wYXRoc0RhdGEpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcbiAgICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xuICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCA9IHRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgICBzaGFwZURhdGEucGF0aHNEYXRhID0gcGF0aHNEYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRvdGFsTW9kaWZpZXJMZW5ndGggKz0gdG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlUyA9IHM7XG4gICAgICB2YXIgc2hhcGVFID0gZTtcbiAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XG4gICAgICB2YXIgZWRnZXM7XG5cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmIChzaGFwZURhdGEuc2hhcGUuX21kZikge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTsgLy8gaWYgbSA9PT0gMiBtZWFucyBwYXRocyBhcmUgdHJpbW1lZCBpbmRpdmlkdWFsbHkgc28gZWRnZXMgbmVlZCB0byBiZSBmb3VuZCBmb3IgdGhpcyBzcGVjaWZpYyBzaGFwZSByZWxhdGl2ZSB0byB3aG9lbCBncm91cFxuXG4gICAgICAgICAgaWYgKHRoaXMubSA9PT0gMiAmJiBsZW4gPiAxKSB7XG4gICAgICAgICAgICBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2hhcGVFZGdlcyhzLCBlLCBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCwgYWRkZWRMZW5ndGgsIHRvdGFsTW9kaWZpZXJMZW5ndGgpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkZ2VzID0gW1tzaGFwZVMsIHNoYXBlRV1dO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGpMZW4gPSBlZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBzaGFwZVMgPSBlZGdlc1tqXVswXTtcbiAgICAgICAgICAgIHNoYXBlRSA9IGVkZ2VzW2pdWzFdO1xuICAgICAgICAgICAgc2VnbWVudHMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgaWYgKHNoYXBlRSA8PSAxKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVFXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzaGFwZVMgPj0gMSkge1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZVMgLSAxKSxcbiAgICAgICAgICAgICAgICBlOiBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZUUgLSAxKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVTLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMF0pO1xuXG4gICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ucyAhPT0gc2VnbWVudHNbMF0uZSkge1xuICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGVJbkNvbGxlY3Rpb24gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzW3NoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICBpZiAobGFzdFNoYXBlSW5Db2xsZWN0aW9uLmMpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGUgPSBuZXdTaGFwZXNEYXRhLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSwgbGFzdFNoYXBlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21kZikge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIC8vIFJlbGVhc2lnbiBUcmltIENhY2hlZCBwYXRocyBkYXRhIHdoZW4gbm8gdHJpbSBhcHBsaWVkIGluIGNhc2Ugc2hhcGVzIGFyZSBtb2RpZmllZCBpbmJldHdlZW4uXG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGlzIGV2ZW4gaWYgaXQncyBsb3NpbmcgY2FjaGVkIGluZm8uXG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRQYXRocyA9IGZ1bmN0aW9uIChuZXdQYXRocywgbG9jYWxTaGFwZUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gbmV3UGF0aHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZShuZXdQYXRoc1tpXSk7XG4gICAgfVxuICB9O1xuXG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MlswXSwgcHQyWzFdLCAnbycsIHBvcyk7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQzWzBdLCBwdDNbMV0sICdpJywgcG9zICsgMSk7XG5cbiAgICBpZiAobmV3U2hhcGUpIHtcbiAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MVswXSwgcHQxWzFdLCAndicsIHBvcyk7XG4gICAgfVxuXG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQ0WzBdLCBwdDRbMV0sICd2JywgcG9zICsgMSk7XG4gIH07XG5cbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50RnJvbUFycmF5ID0gZnVuY3Rpb24gKHBvaW50cywgc2hhcGVQYXRoLCBwb3MsIG5ld1NoYXBlKSB7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzFdLCBwb2ludHNbNV0sICdvJywgcG9zKTtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMl0sIHBvaW50c1s2XSwgJ2knLCBwb3MgKyAxKTtcblxuICAgIGlmIChuZXdTaGFwZSkge1xuICAgICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzBdLCBwb2ludHNbNF0sICd2JywgcG9zKTtcbiAgICB9XG5cbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcbiAgfTtcblxuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlcyA9IGZ1bmN0aW9uIChzaGFwZURhdGEsIHNoYXBlU2VnbWVudCwgc2hhcGVQYXRoKSB7XG4gICAgdmFyIHBhdGhzRGF0YSA9IHNoYXBlRGF0YS5wYXRoc0RhdGE7XG4gICAgdmFyIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgIHZhciBjdXJyZW50TGVuZ3RoRGF0YTtcbiAgICB2YXIgc2VnbWVudENvdW50O1xuICAgIHZhciBsZW5ndGhzO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBzaGFwZXMgPSBbXTtcbiAgICB2YXIgaW5pdFBvcztcbiAgICB2YXIgbmV3U2hhcGUgPSB0cnVlO1xuXG4gICAgaWYgKCFzaGFwZVBhdGgpIHtcbiAgICAgIHNoYXBlUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICBzZWdtZW50Q291bnQgPSAwO1xuICAgICAgaW5pdFBvcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlZ21lbnRDb3VudCA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgICAgaW5pdFBvcyA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgIH1cblxuICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGxlbmd0aHMgPSBwYXRoc0RhdGFbaV0ubGVuZ3RocztcbiAgICAgIHNoYXBlUGF0aC5jID0gc2hhcGVQYXRoc1tpXS5jO1xuICAgICAgakxlbiA9IHNoYXBlUGF0aHNbaV0uYyA/IGxlbmd0aHMubGVuZ3RoIDogbGVuZ3Rocy5sZW5ndGggKyAxO1xuXG4gICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTsgLy8gdGhpcy5hZGRTZWdtZW50KHNlZ21lbnQucHQxLCBzZWdtZW50LnB0Mywgc2VnbWVudC5wdDQsIHNlZ21lbnQucHQyLCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xuXG4gICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hhcGVQYXRoc1tpXS5jICYmIGxlbmd0aHMubGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRMZW5ndGhEYXRhID0gbGVuZ3Roc1tqIC0gMV07XG5cbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoIDw9IHNoYXBlU2VnbWVudC5lKSB7XG4gICAgICAgICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhzW2ogLSAxXS5hZGRlZExlbmd0aDtcblxuICAgICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7IC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcblxuICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFwZVBhdGguX2xlbmd0aCkge1xuICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltpbml0UG9zXVswXSwgc2hhcGVQYXRoLnZbaW5pdFBvc11bMV0sICdpJywgaW5pdFBvcyk7XG4gICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMF0sIHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMV0sICdvJywgc2hhcGVQYXRoLl9sZW5ndGggLSAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZGVkTGVuZ3RoID4gc2hhcGVTZWdtZW50LmUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICBzaGFwZVBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICBuZXdTaGFwZSA9IHRydWU7XG4gICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG4gICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlcztcbiAgfTtcblxuICBmdW5jdGlvbiBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtb3VudCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcblxuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbW91bnQpIHtcbiAgICB2YXIgcGVyY2VudCA9IGFtb3VudCAvIDEwMDtcbiAgICB2YXIgY2VudGVyUG9pbnQgPSBbMCwgMF07XG4gICAgdmFyIHBhdGhMZW5ndGggPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgY2VudGVyUG9pbnRbMF0gKz0gcGF0aC52W2ldWzBdO1xuICAgICAgY2VudGVyUG9pbnRbMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgIH1cblxuICAgIGNlbnRlclBvaW50WzBdIC89IHBhdGhMZW5ndGg7XG4gICAgY2VudGVyUG9pbnRbMV0gLz0gcGF0aExlbmd0aDtcbiAgICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdlggPSBwYXRoLnZbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLnZbaV1bMF0pICogcGVyY2VudDtcbiAgICAgIHZZID0gcGF0aC52W2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC52W2ldWzFdKSAqIHBlcmNlbnQ7XG4gICAgICBvWCA9IHBhdGgub1tpXVswXSArIChjZW50ZXJQb2ludFswXSAtIHBhdGgub1tpXVswXSkgKiAtcGVyY2VudDtcbiAgICAgIG9ZID0gcGF0aC5vW2ldWzFdICsgKGNlbnRlclBvaW50WzFdIC0gcGF0aC5vW2ldWzFdKSAqIC1wZXJjZW50O1xuICAgICAgaVggPSBwYXRoLmlbaV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLmlbaV1bMF0pICogLXBlcmNlbnQ7XG4gICAgICBpWSA9IHBhdGguaVtpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGguaVtpXVsxXSkgKiAtcGVyY2VudDtcbiAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQodlgsIHZZLCBvWCwgb1ksIGlYLCBpWSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcblxuICAgIGlmIChhbW91bnQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG5cbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZlY3RvciA9IFswLCAwXTtcblxuICAgIGZ1bmN0aW9uIGFwcGx5VG9NYXRyaXgobWF0KSB7XG4gICAgICB2YXIgX21kZiA9IHRoaXMuX21kZjtcbiAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gICAgICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgX21kZjtcblxuICAgICAgaWYgKHRoaXMuYSkge1xuICAgICAgICBtYXQudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnMpIHtcbiAgICAgICAgbWF0LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaykge1xuICAgICAgICBtYXQuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgbWF0LnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXlzKGZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRGlydHkpIHtcbiAgICAgICAgdGhpcy5wcmVjYWxjdWxhdGVNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuXG4gICAgICBpZiAodGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyKSB7XG4gICAgICAgIHZhciBmcmFtZVJhdGU7XG4gICAgICAgIHRoaXMudi5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcbiAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xuICAgICAgICAgIHRoaXMudi5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcbiAgICAgICAgICB0aGlzLnYuc2tld0Zyb21BeGlzKC10aGlzLnNrLnYsIHRoaXMuc2Eudik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgICB0aGlzLnYucm90YXRlKC10aGlzLnIudik7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgICAgdGhpcy52LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcbiAgICAgICAgICB2YXIgdjE7XG4gICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgIGZyYW1lUmF0ZSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLnAgJiYgdGhpcy5wLmtleWZyYW1lcyAmJiB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPD0gdGhpcy5wLmtleWZyYW1lc1swXS50KSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRoaXMucC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSA+PSB0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xuICAgICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDUpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHYxID0gdGhpcy5wLnB2O1xuICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHRoaXMucC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHggJiYgdGhpcy5weC5rZXlmcmFtZXMgJiYgdGhpcy5weS5rZXlmcmFtZXMgJiYgdGhpcy5weC5nZXRWYWx1ZUF0VGltZSAmJiB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICB2MSA9IFtdO1xuICAgICAgICAgICAgdjIgPSBbXTtcbiAgICAgICAgICAgIHZhciBweCA9IHRoaXMucHg7XG4gICAgICAgICAgICB2YXIgcHkgPSB0aGlzLnB5O1xuXG4gICAgICAgICAgICBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA8PSBweC5rZXlmcmFtZXNbMF0udCkge1xuICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjFbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUocHgua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1swXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSA+PSBweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQpIHtcbiAgICAgICAgICAgICAgdjFbMF0gPSBweC5nZXRWYWx1ZUF0VGltZShweC5rZXlmcmFtZXNbcHgua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKHB5LmtleWZyYW1lc1tweS5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdjEgPSBbcHgucHYsIHB5LnB2XTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHguX2NhY2hpbmcubGFzdEZyYW1lICsgcHgub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweC5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgICAgdjJbMV0gPSBweS5nZXRWYWx1ZUF0VGltZSgocHkuX2NhY2hpbmcubGFzdEZyYW1lICsgcHkub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCBweS5vZmZzZXRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdjIgPSBkZWZhdWx0VmVjdG9yO1xuICAgICAgICAgICAgdjEgPSB2MjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnYucm90YXRlKC1NYXRoLmF0YW4yKHYxWzFdIC0gdjJbMV0sIHYxWzBdIC0gdjJbMF0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGEucCAmJiB0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIC10aGlzLnB6LnYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVjYWxjdWxhdGVNYXRyaXgoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuICAgICAgdGhpcy5wcmUucmVzZXQoKTtcblxuICAgICAgaWYgKCF0aGlzLmEuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnNrLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMuc2EuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnIuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnJvdGF0ZSgtdGhpcy5yLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMucnouZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ4LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMub3IuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnByZS5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKS5yb3RhdGVZKHRoaXMub3IudlsxXSkucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGF1dG9PcmllbnQoKSB7Ly9cbiAgICAgIC8vIHZhciBwcmV2UCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgdGhpcy5fYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuXG4gICAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3RyYW5zZm9ybSc7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy52ID0gbmV3IE1hdHJpeCgpOyAvLyBQcmVjYWxjdWxhdGVkIG1hdHJpeCB3aXRoIG5vbiBhbmltYXRlZCBwcm9wZXJ0aWVzXG5cbiAgICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIgfHwgZWxlbSk7XG5cbiAgICAgIGlmIChkYXRhLnAgJiYgZGF0YS5wLnMpIHtcbiAgICAgICAgdGhpcy5weCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC54LCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5weSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucC55LCAwLCAwLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5wLnopIHtcbiAgICAgICAgICB0aGlzLnB6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLnosIDAsIDAsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAgfHwge1xuICAgICAgICAgIGs6IFswLCAwLCAwXVxuICAgICAgICB9LCAxLCAwLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMucnkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnJ6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcblxuICAgICAgICBpZiAoZGF0YS5vci5rWzBdLnRpKSB7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGxlbiA9IGRhdGEub3Iuay5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGRhdGEub3Iua1tpXS50byA9IG51bGw7XG4gICAgICAgICAgICBkYXRhLm9yLmtbaV0udGkgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpOyAvLyBzaCBJbmRpY2F0ZXMgaXQgbmVlZHMgdG8gYmUgY2FwcGVkIGJldHdlZW4gLTE4MCBhbmQgMTgwXG5cbiAgICAgICAgdGhpcy5vci5zaCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIgfHwge1xuICAgICAgICAgIGs6IDBcbiAgICAgICAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc2spIHtcbiAgICAgICAgdGhpcy5zayA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2ssIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMuc2EgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNhLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiBbMCwgMCwgMF1cbiAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHtcbiAgICAgICAgazogWzEwMCwgMTAwLCAxMDBdXG4gICAgICB9LCAxLCAwLjAxLCB0aGlzKTsgLy8gT3BhY2l0eSBpcyBub3QgcGFydCBvZiB0aGUgdHJhbnNmb3JtIHByb3BlcnRpZXMsIHRoYXQncyB3aHkgaXQgd29uJ3QgdXNlIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuIFRoYXQgd2F5IHRyYW5zZm9ybXMgd29uJ3QgZ2V0IHVwZGF0ZWQgaWYgb3BhY2l0eSBjaGFuZ2VzLlxuXG4gICAgICBpZiAoZGF0YS5vKSB7XG4gICAgICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgZWxlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm8gPSB7XG4gICAgICAgICAgX21kZjogZmFsc2UsXG4gICAgICAgICAgdjogMVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcblxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZSA9IHtcbiAgICAgIGFwcGx5VG9NYXRyaXg6IGFwcGx5VG9NYXRyaXgsXG4gICAgICBnZXRWYWx1ZTogcHJvY2Vzc0tleXMsXG4gICAgICBwcmVjYWxjdWxhdGVNYXRyaXg6IHByZWNhbGN1bGF0ZU1hdHJpeCxcbiAgICAgIGF1dG9PcmllbnQ6IGF1dG9PcmllbnRcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVHJhbnNmb3JtUHJvcGVydHkpO1xuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHkgPSBhZGREeW5hbWljUHJvcGVydHk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLl9hZGREeW5hbWljUHJvcGVydHkgPSBEeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eTtcblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eTogZ2V0VHJhbnNmb3JtUHJvcGVydHlcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gUmVwZWF0ZXJNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUmVwZWF0ZXJNb2RpZmllcik7XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMudHIgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YS50ciwgdGhpcyk7XG4gICAgdGhpcy5zbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuc28sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnRyLmVvLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB0aGlzLnBNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5yTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuc01hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnRNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHBNYXRyaXgsIHJNYXRyaXgsIHNNYXRyaXgsIHRyYW5zZm9ybSwgcGVyYywgaW52KSB7XG4gICAgdmFyIGRpciA9IGludiA/IC0xIDogMTtcbiAgICB2YXIgc2NhbGVYID0gdHJhbnNmb3JtLnMudlswXSArICgxIC0gdHJhbnNmb3JtLnMudlswXSkgKiAoMSAtIHBlcmMpO1xuICAgIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XG4gICAgcE1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLnAudlswXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMV0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzJdKTtcbiAgICByTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICAgIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XG4gICAgck1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gICAgc01hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcbiAgICBzTWF0cml4LnNjYWxlKGludiA/IDEgLyBzY2FsZVggOiBzY2FsZVgsIGludiA/IDEgLyBzY2FsZVkgOiBzY2FsZVkpO1xuICAgIHNNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgYXJyLCBwb3MsIGVsZW1zRGF0YSkge1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5lbGVtc0RhdGEgPSBlbGVtc0RhdGE7XG4gICAgdGhpcy5fY3VycmVudENvcGllcyA9IDA7XG4gICAgdGhpcy5fZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9ncm91cHMgPSBbXTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGFycltwb3NdKTtcblxuICAgIHdoaWxlIChwb3MgPiAwKSB7XG4gICAgICBwb3MgLT0gMTsgLy8gdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnIuc3BsaWNlKHBvcywxKVswXSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyW3Bvc10pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucmVzZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnRzW2ldLl9wcm9jZXNzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMucmVzZXRFbGVtZW50cyhlbGVtZW50c1tpXS5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnRzKSk7XG4gICAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuY2hhbmdlR3JvdXBSZW5kZXIgPSBmdW5jdGlvbiAoZWxlbWVudHMsIHJlbmRlckZsYWcpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50c1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcblxuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIoZWxlbWVudHNbaV0uaXQsIHJlbmRlckZsYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgaXRlbXM7XG4gICAgdmFyIGl0ZW1zVHJhbnNmb3JtO1xuICAgIHZhciBpO1xuICAgIHZhciBkaXI7XG4gICAgdmFyIGNvbnQ7XG4gICAgdmFyIGhhc1JlbG9hZGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBjb3BpZXMgPSBNYXRoLmNlaWwodGhpcy5jLnYpO1xuXG4gICAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICB3aGlsZSAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICAgIGl0OiB0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxuICAgICAgICAgICAgdHk6ICdncidcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwLml0LnB1c2goe1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMSxcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm06ICdUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgbzoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNyxcbiAgICAgICAgICAgICAgazogMTAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMixcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICBpeDogNixcbiAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IDAsXG4gICAgICAgICAgICAgICAgdDogMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICBlOiAwLFxuICAgICAgICAgICAgICAgIHQ6IDFcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAzLFxuICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgaXg6IDUsXG4gICAgICAgICAgICAgIGs6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzazoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNCxcbiAgICAgICAgICAgICAgazogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5OiAndHInXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hcnIuc3BsaWNlKDAsIDAsIGdyb3VwKTtcblxuICAgICAgICAgIHRoaXMuX2dyb3Vwcy5zcGxpY2UoMCwgMCwgZ3JvdXApO1xuXG4gICAgICAgICAgdGhpcy5fY3VycmVudENvcGllcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtLnJlbG9hZFNoYXBlcygpO1xuICAgICAgICBoYXNSZWxvYWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnQgPSAwO1xuICAgICAgdmFyIHJlbmRlckZsYWc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gdGhpcy5fZ3JvdXBzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICByZW5kZXJGbGFnID0gY29udCA8IGNvcGllcztcbiAgICAgICAgdGhpcy5fZ3JvdXBzW2ldLl9yZW5kZXIgPSByZW5kZXJGbGFnO1xuICAgICAgICB0aGlzLmNoYW5nZUdyb3VwUmVuZGVyKHRoaXMuX2dyb3Vwc1tpXS5pdCwgcmVuZGVyRmxhZyk7XG5cbiAgICAgICAgaWYgKCFyZW5kZXJGbGFnKSB7XG4gICAgICAgICAgdmFyIGVsZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ICE9PSAwKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybURhdGEudHJhbnNmb3JtLm9wLnYgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC5fbWRmID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udCArPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gY29waWVzOyAvLy8gL1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vLnY7XG4gICAgICB2YXIgb2Zmc2V0TW9kdWxvID0gb2Zmc2V0ICUgMTtcbiAgICAgIHZhciByb3VuZE9mZnNldCA9IG9mZnNldCA+IDAgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLmNlaWwob2Zmc2V0KTtcbiAgICAgIHZhciBwUHJvcHMgPSB0aGlzLnBNYXRyaXgucHJvcHM7XG4gICAgICB2YXIgclByb3BzID0gdGhpcy5yTWF0cml4LnByb3BzO1xuICAgICAgdmFyIHNQcm9wcyA9IHRoaXMuc01hdHJpeC5wcm9wcztcbiAgICAgIHRoaXMucE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5yTWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLnNNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMudE1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xuXG4gICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICB3aGlsZSAoaXRlcmF0aW9uIDwgcm91bmRPZmZzZXQpIHtcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IG9mZnNldE1vZHVsbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPiByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9mZnNldE1vZHVsbykge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIC1vZmZzZXRNb2R1bG8sIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSBvZmZzZXRNb2R1bG87XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSA9IHRoaXMuZGF0YS5tID09PSAxID8gMCA6IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxO1xuICAgICAgZGlyID0gdGhpcy5kYXRhLm0gPT09IDEgPyAxIDogLTE7XG4gICAgICBjb250ID0gdGhpcy5fY3VycmVudENvcGllcztcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBqTGVuID0gaXRlbXNUcmFuc2Zvcm0ubGVuZ3RoO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSB0cnVlO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC52ID0gdGhpcy5fY3VycmVudENvcGllcyA9PT0gMSA/IHRoaXMuc28udiA6IHRoaXMuc28udiArICh0aGlzLmVvLnYgLSB0aGlzLnNvLnYpICogKGkgLyAodGhpcy5fY3VycmVudENvcGllcyAtIDEpKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgaWYgKGkgIT09IDAgJiYgZGlyID09PSAxIHx8IGkgIT09IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxICYmIGRpciA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oclByb3BzWzBdLCByUHJvcHNbMV0sIHJQcm9wc1syXSwgclByb3BzWzNdLCByUHJvcHNbNF0sIHJQcm9wc1s1XSwgclByb3BzWzZdLCByUHJvcHNbN10sIHJQcm9wc1s4XSwgclByb3BzWzldLCByUHJvcHNbMTBdLCByUHJvcHNbMTFdLCByUHJvcHNbMTJdLCByUHJvcHNbMTNdLCByUHJvcHNbMTRdLCByUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oc1Byb3BzWzBdLCBzUHJvcHNbMV0sIHNQcm9wc1syXSwgc1Byb3BzWzNdLCBzUHJvcHNbNF0sIHNQcm9wc1s1XSwgc1Byb3BzWzZdLCBzUHJvcHNbN10sIHNQcm9wc1s4XSwgc1Byb3BzWzldLCBzUHJvcHNbMTBdLCBzUHJvcHNbMTFdLCBzUHJvcHNbMTJdLCBzUHJvcHNbMTNdLCBzUHJvcHNbMTRdLCBzUHJvcHNbMTVdKTtcbiAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0ocFByb3BzWzBdLCBwUHJvcHNbMV0sIHBQcm9wc1syXSwgcFByb3BzWzNdLCBwUHJvcHNbNF0sIHBQcm9wc1s1XSwgcFByb3BzWzZdLCBwUHJvcHNbN10sIHBQcm9wc1s4XSwgcFByb3BzWzldLCBwUHJvcHNbMTBdLCBwUHJvcHNbMTFdLCBwUHJvcHNbMTJdLCBwUHJvcHNbMTNdLCBwUHJvcHNbMTRdLCBwUHJvcHNbMTVdKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtW2pdID0gdGhpcy5tYXRyaXgucHJvcHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IHRoaXMuX2N1cnJlbnRDb3BpZXM7XG4gICAgICBpID0gMDtcbiAgICAgIGRpciA9IDE7XG5cbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGFzUmVsb2FkZWQ7XG4gIH07XG5cbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuXG4gIFJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLnJkID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLnJkLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJvdW5kKSB7XG4gICAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgIGNsb25lZFBhdGguYyA9IHBhdGguYztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjdXJyZW50VjtcbiAgICB2YXIgY3VycmVudEk7XG4gICAgdmFyIGN1cnJlbnRPO1xuICAgIHZhciBjbG9zZXJWO1xuICAgIHZhciBkaXN0YW5jZTtcbiAgICB2YXIgbmV3UG9zUGVyYztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjdXJyZW50ViA9IHBhdGgudltpXTtcbiAgICAgIGN1cnJlbnRPID0gcGF0aC5vW2ldO1xuICAgICAgY3VycmVudEkgPSBwYXRoLmlbaV07XG5cbiAgICAgIGlmIChjdXJyZW50VlswXSA9PT0gY3VycmVudE9bMF0gJiYgY3VycmVudFZbMV0gPT09IGN1cnJlbnRPWzFdICYmIGN1cnJlbnRWWzBdID09PSBjdXJyZW50SVswXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudElbMV0pIHtcbiAgICAgICAgaWYgKChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpICYmICFwYXRoLmMpIHtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KGN1cnJlbnRWWzBdLCBjdXJyZW50VlsxXSwgY3VycmVudE9bMF0sIGN1cnJlbnRPWzFdLCBjdXJyZW50SVswXSwgY3VycmVudElbMV0sIGluZGV4KTtcbiAgICAgICAgICAvKiBjbG9uZWRQYXRoLnZbaW5kZXhdID0gY3VycmVudFY7XHJcbiAgICAgICAgICAgICAgICAgIGNsb25lZFBhdGgub1tpbmRleF0gPSBjdXJyZW50TztcclxuICAgICAgICAgICAgICAgICAgY2xvbmVkUGF0aC5pW2luZGV4XSA9IGN1cnJlbnRJOyAqL1xuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltsZW4gLSAxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpIC0gMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIGlYID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBpWDtcbiAgICAgICAgICBpWSA9IGN1cnJlbnRWWzFdIC0gKGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gaVk7XG4gICAgICAgICAgb1ggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIG9ZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuXG4gICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlclYgPSBwYXRoLnZbaSArIDFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KGN1cnJlbnRWWzBdIC0gY2xvc2VyVlswXSwgMikgKyBNYXRoLnBvdyhjdXJyZW50VlsxXSAtIGNsb3NlclZbMV0sIDIpKTtcbiAgICAgICAgICBuZXdQb3NQZXJjID0gZGlzdGFuY2UgPyBNYXRoLm1pbihkaXN0YW5jZSAvIDIsIHJvdW5kKSAvIGRpc3RhbmNlIDogMDtcbiAgICAgICAgICBvWCA9IGN1cnJlbnRWWzBdICsgKGNsb3NlclZbMF0gLSBjdXJyZW50VlswXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZYID0gb1g7XG4gICAgICAgICAgb1kgPSBjdXJyZW50VlsxXSArIChjbG9zZXJWWzFdIC0gY3VycmVudFZbMV0pICogbmV3UG9zUGVyYztcbiAgICAgICAgICB2WSA9IG9ZO1xuICAgICAgICAgIGlYID0gdlggLSAodlggLSBjdXJyZW50VlswXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBpWSA9IHZZIC0gKHZZIC0gY3VycmVudFZbMV0pICogcm91bmRDb3JuZXI7XG4gICAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdCh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBpbmRleCk7XG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmVkUGF0aC5zZXRUcmlwbGVBdChwYXRoLnZbaV1bMF0sIHBhdGgudltpXVsxXSwgcGF0aC5vW2ldWzBdLCBwYXRoLm9baV1bMV0sIHBhdGguaVtpXVswXSwgcGF0aC5pW2ldWzFdLCBpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG5cbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHJkID0gdGhpcy5yZC52O1xuXG4gICAgaWYgKHJkICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCByZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZmxvYXRFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSAqIDEwMDAwMCA8PSBNYXRoLm1pbihNYXRoLmFicyhhKSwgTWF0aC5hYnMoYikpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxvYXRaZXJvKGYpIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoZikgPD0gMC4wMDAwMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnAocDAsIHAxLCBhbW91bnQpIHtcbiAgICByZXR1cm4gcDAgKiAoMSAtIGFtb3VudCkgKyBwMSAqIGFtb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlcnBQb2ludChwMCwgcDEsIGFtb3VudCkge1xuICAgIHJldHVybiBbbGVycChwMFswXSwgcDFbMF0sIGFtb3VudCksIGxlcnAocDBbMV0sIHAxWzFdLCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YWRSb290cyhhLCBiLCBjKSB7XG4gICAgLy8gbm8gcm9vdFxuICAgIGlmIChhID09PSAwKSByZXR1cm4gW107XG4gICAgdmFyIHMgPSBiICogYiAtIDQgKiBhICogYzsgLy8gQ29tcGxleCByb290c1xuXG4gICAgaWYgKHMgPCAwKSByZXR1cm4gW107XG4gICAgdmFyIHNpbmdsZVJvb3QgPSAtYiAvICgyICogYSk7IC8vIDEgcm9vdFxuXG4gICAgaWYgKHMgPT09IDApIHJldHVybiBbc2luZ2xlUm9vdF07XG4gICAgdmFyIGRlbHRhID0gTWF0aC5zcXJ0KHMpIC8gKDIgKiBhKTsgLy8gMiByb290c1xuXG4gICAgcmV0dXJuIFtzaW5nbGVSb290IC0gZGVsdGEsIHNpbmdsZVJvb3QgKyBkZWx0YV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIFstcDAgKyAzICogcDEgLSAzICogcDIgKyBwMywgMyAqIHAwIC0gNiAqIHAxICsgMyAqIHAyLCAtMyAqIHAwICsgMyAqIHAxLCBwMF07XG4gIH1cblxuICBmdW5jdGlvbiBzaW5nbGVQb2ludChwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAsIHAsIHAsIHAsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMsIGxpbmVhcml6ZSkge1xuICAgIGlmIChsaW5lYXJpemUgJiYgcG9pbnRFcXVhbChwMCwgcDEpKSB7XG4gICAgICBwMSA9IGxlcnBQb2ludChwMCwgcDMsIDEgLyAzKTtcbiAgICB9XG5cbiAgICBpZiAobGluZWFyaXplICYmIHBvaW50RXF1YWwocDIsIHAzKSkge1xuICAgICAgcDIgPSBsZXJwUG9pbnQocDAsIHAzLCAyIC8gMyk7XG4gICAgfVxuXG4gICAgdmFyIGNvZWZmeCA9IHBvbHlub21pYWxDb2VmZmljaWVudHMocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgIHZhciBjb2VmZnkgPSBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICB0aGlzLmEgPSBbY29lZmZ4WzBdLCBjb2VmZnlbMF1dO1xuICAgIHRoaXMuYiA9IFtjb2VmZnhbMV0sIGNvZWZmeVsxXV07XG4gICAgdGhpcy5jID0gW2NvZWZmeFsyXSwgY29lZmZ5WzJdXTtcbiAgICB0aGlzLmQgPSBbY29lZmZ4WzNdLCBjb2VmZnlbM11dO1xuICAgIHRoaXMucG9pbnRzID0gW3AwLCBwMSwgcDIsIHAzXTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gWygodGhpcy5hWzBdICogdCArIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdKSAqIHQgKyB0aGlzLmRbMF0sICgodGhpcy5hWzFdICogdCArIHRoaXMuYlsxXSkgKiB0ICsgdGhpcy5jWzFdKSAqIHQgKyB0aGlzLmRbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmRlcml2YXRpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKDMgKiB0ICogdGhpcy5hWzBdICsgMiAqIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdLCAoMyAqIHQgKiB0aGlzLmFbMV0gKyAyICogdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV1dO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLnRhbmdlbnRBbmdsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocFsxXSwgcFswXSk7XG4gIH07XG5cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUubm9ybWFsQW5nbGUgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBbMF0sIHBbMV0pO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmluZmxlY3Rpb25Qb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlbm9tID0gdGhpcy5hWzFdICogdGhpcy5iWzBdIC0gdGhpcy5hWzBdICogdGhpcy5iWzFdO1xuICAgIGlmIChmbG9hdFplcm8oZGVub20pKSByZXR1cm4gW107XG4gICAgdmFyIHRjdXNwID0gLTAuNSAqICh0aGlzLmFbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmFbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgdmFyIHNxdWFyZSA9IHRjdXNwICogdGN1c3AgLSAxIC8gMyAqICh0aGlzLmJbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmJbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgaWYgKHNxdWFyZSA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgcm9vdCA9IE1hdGguc3FydChzcXVhcmUpO1xuXG4gICAgaWYgKGZsb2F0WmVybyhyb290KSkge1xuICAgICAgaWYgKHJvb3QgPiAwICYmIHJvb3QgPCAxKSByZXR1cm4gW3RjdXNwXTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gW3RjdXNwIC0gcm9vdCwgdGN1c3AgKyByb290XS5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiByID4gMCAmJiByIDwgMTtcbiAgICB9KTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIFtzaW5nbGVQb2ludCh0aGlzLnBvaW50c1swXSksIHRoaXNdO1xuICAgIGlmICh0ID49IDEpIHJldHVybiBbdGhpcywgc2luZ2xlUG9pbnQodGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0pXTtcbiAgICB2YXIgcDEwID0gbGVycFBvaW50KHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSwgdCk7XG4gICAgdmFyIHAxMSA9IGxlcnBQb2ludCh0aGlzLnBvaW50c1sxXSwgdGhpcy5wb2ludHNbMl0sIHQpO1xuICAgIHZhciBwMTIgPSBsZXJwUG9pbnQodGhpcy5wb2ludHNbMl0sIHRoaXMucG9pbnRzWzNdLCB0KTtcbiAgICB2YXIgcDIwID0gbGVycFBvaW50KHAxMCwgcDExLCB0KTtcbiAgICB2YXIgcDIxID0gbGVycFBvaW50KHAxMSwgcDEyLCB0KTtcbiAgICB2YXIgcDMgPSBsZXJwUG9pbnQocDIwLCBwMjEsIHQpO1xuICAgIHJldHVybiBbbmV3IFBvbHlub21pYWxCZXppZXIodGhpcy5wb2ludHNbMF0sIHAxMCwgcDIwLCBwMywgdHJ1ZSksIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAzLCBwMjEsIHAxMiwgdGhpcy5wb2ludHNbM10sIHRydWUpXTtcbiAgfTtcblxuICBmdW5jdGlvbiBleHRyZW1hKGJleiwgY29tcCkge1xuICAgIHZhciBtaW4gPSBiZXoucG9pbnRzWzBdW2NvbXBdO1xuICAgIHZhciBtYXggPSBiZXoucG9pbnRzW2Jlei5wb2ludHMubGVuZ3RoIC0gMV1bY29tcF07XG5cbiAgICBpZiAobWluID4gbWF4KSB7XG4gICAgICB2YXIgZSA9IG1heDtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IGU7XG4gICAgfSAvLyBEZXJpdmF0aXZlIHJvb3RzIHRvIGZpbmQgbWluL21heFxuXG5cbiAgICB2YXIgZiA9IHF1YWRSb290cygzICogYmV6LmFbY29tcF0sIDIgKiBiZXouYltjb21wXSwgYmV6LmNbY29tcF0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBpZiAoZltpXSA+IDAgJiYgZltpXSA8IDEpIHtcbiAgICAgICAgdmFyIHZhbCA9IGJlei5wb2ludChmW2ldKVtjb21wXTtcbiAgICAgICAgaWYgKHZhbCA8IG1pbikgbWluID0gdmFsO2Vsc2UgaWYgKHZhbCA+IG1heCkgbWF4ID0gdmFsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW46IG1pbixcbiAgICAgIG1heDogbWF4XG4gICAgfTtcbiAgfVxuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXh0cmVtYSh0aGlzLCAwKSxcbiAgICAgIHk6IGV4dHJlbWEodGhpcywgMSlcbiAgICB9O1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBib3VuZHMgPSB0aGlzLmJvdW5kcygpO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0OiBib3VuZHMueC5taW4sXG4gICAgICByaWdodDogYm91bmRzLngubWF4LFxuICAgICAgdG9wOiBib3VuZHMueS5taW4sXG4gICAgICBib3R0b206IGJvdW5kcy55Lm1heCxcbiAgICAgIHdpZHRoOiBib3VuZHMueC5tYXggLSBib3VuZHMueC5taW4sXG4gICAgICBoZWlnaHQ6IGJvdW5kcy55Lm1heCAtIGJvdW5kcy55Lm1pbixcbiAgICAgIGN4OiAoYm91bmRzLngubWF4ICsgYm91bmRzLngubWluKSAvIDIsXG4gICAgICBjeTogKGJvdW5kcy55Lm1heCArIGJvdW5kcy55Lm1pbikgLyAyXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRlcnNlY3REYXRhKGJleiwgdDEsIHQyKSB7XG4gICAgdmFyIGJveCA9IGJlei5ib3VuZGluZ0JveCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjeDogYm94LmN4LFxuICAgICAgY3k6IGJveC5jeSxcbiAgICAgIHdpZHRoOiBib3gud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJveC5oZWlnaHQsXG4gICAgICBiZXo6IGJleixcbiAgICAgIHQ6ICh0MSArIHQyKSAvIDIsXG4gICAgICB0MTogdDEsXG4gICAgICB0MjogdDJcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3BsaXREYXRhKGRhdGEpIHtcbiAgICB2YXIgc3BsaXQgPSBkYXRhLmJlei5zcGxpdCgwLjUpO1xuICAgIHJldHVybiBbaW50ZXJzZWN0RGF0YShzcGxpdFswXSwgZGF0YS50MSwgZGF0YS50KSwgaW50ZXJzZWN0RGF0YShzcGxpdFsxXSwgZGF0YS50LCBkYXRhLnQyKV07XG4gIH1cblxuICBmdW5jdGlvbiBib3hJbnRlcnNlY3QoYjEsIGIyKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGIxLmN4IC0gYjIuY3gpICogMiA8IGIxLndpZHRoICsgYjIud2lkdGggJiYgTWF0aC5hYnMoYjEuY3kgLSBiMi5jeSkgKiAyIDwgYjEuaGVpZ2h0ICsgYjIuaGVpZ2h0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0c0ltcGwoZDEsIGQyLCBkZXB0aCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pIHtcbiAgICBpZiAoIWJveEludGVyc2VjdChkMSwgZDIpKSByZXR1cm47XG5cbiAgICBpZiAoZGVwdGggPj0gbWF4UmVjdXJzaW9uIHx8IGQxLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMS5oZWlnaHQgPD0gdG9sZXJhbmNlICYmIGQyLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMi5oZWlnaHQgPD0gdG9sZXJhbmNlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goW2QxLnQsIGQyLnRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZDFzID0gc3BsaXREYXRhKGQxKTtcbiAgICB2YXIgZDJzID0gc3BsaXREYXRhKGQyKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMF0sIGQyc1swXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzBdLCBkMnNbMV0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1sxXSwgZDJzWzBdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMV0sIGQyc1sxXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gIH1cblxuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gKG90aGVyLCB0b2xlcmFuY2UsIG1heFJlY3Vyc2lvbikge1xuICAgIGlmICh0b2xlcmFuY2UgPT09IHVuZGVmaW5lZCkgdG9sZXJhbmNlID0gMjtcbiAgICBpZiAobWF4UmVjdXJzaW9uID09PSB1bmRlZmluZWQpIG1heFJlY3Vyc2lvbiA9IDc7XG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICBpbnRlcnNlY3RzSW1wbChpbnRlcnNlY3REYXRhKHRoaXMsIDAsIDEpLCBpbnRlcnNlY3REYXRhKG90aGVyLCAwLCAxKSwgMCwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuXG4gIFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50ID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W2luZGV4XSwgc2hhcGVQYXRoLm9baW5kZXhdLCBzaGFwZVBhdGguaVtuZXh0SW5kZXhdLCBzaGFwZVBhdGgudltuZXh0SW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W25leHRJbmRleF0sIHNoYXBlUGF0aC5pW25leHRJbmRleF0sIHNoYXBlUGF0aC5vW2luZGV4XSwgc2hhcGVQYXRoLnZbaW5kZXhdLCB0cnVlKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcm9zc1Byb2R1Y3QoYSwgYikge1xuICAgIHJldHVybiBbYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSwgYVsyXSAqIGJbMF0gLSBhWzBdICogYlsyXSwgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXV07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgdmFyIHYxID0gW3N0YXJ0MVswXSwgc3RhcnQxWzFdLCAxXTtcbiAgICB2YXIgdjIgPSBbZW5kMVswXSwgZW5kMVsxXSwgMV07XG4gICAgdmFyIHYzID0gW3N0YXJ0MlswXSwgc3RhcnQyWzFdLCAxXTtcbiAgICB2YXIgdjQgPSBbZW5kMlswXSwgZW5kMlsxXSwgMV07XG4gICAgdmFyIHIgPSBjcm9zc1Byb2R1Y3QoY3Jvc3NQcm9kdWN0KHYxLCB2MiksIGNyb3NzUHJvZHVjdCh2MywgdjQpKTtcbiAgICBpZiAoZmxvYXRaZXJvKHJbMl0pKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gW3JbMF0gLyByWzJdLCByWzFdIC8gclsyXV07XG4gIH1cblxuICBmdW5jdGlvbiBwb2xhck9mZnNldChwLCBhbmdsZSwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFtwWzBdICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLCBwWzFdIC0gTWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvaW50RGlzdGFuY2UocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QocDFbMF0gLSBwMlswXSwgcDFbMV0gLSBwMlsxXSk7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludEVxdWFsKHAxLCBwMikge1xuICAgIHJldHVybiBmbG9hdEVxdWFsKHAxWzBdLCBwMlswXSkgJiYgZmxvYXRFcXVhbChwMVsxXSwgcDJbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gWmlnWmFnTW9kaWZpZXIoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFppZ1phZ01vZGlmaWVyKTtcblxuICBaaWdaYWdNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5hbXBsaXR1ZGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZnJlcXVlbmN5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLnBvaW50c1R5cGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnB0LCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbXBsaXR1ZGUuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMCB8fCB0aGlzLmZyZXF1ZW5jeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwIHx8IHRoaXMucG9pbnRzVHlwZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgb3V0QW1wbGl0dWRlLCBpbkFtcGxpdHVkZSkge1xuICAgIHZhciBhbmdPID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgYW5nSSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgdmFyIHB4ID0gcG9pbnRbMF0gKyBNYXRoLmNvcyhhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgdmFyIHB5ID0gcG9pbnRbMV0gLSBNYXRoLnNpbihhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHB4LCBweSwgcHggKyBNYXRoLmNvcyhhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHkgLSBNYXRoLnNpbihhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHggKyBNYXRoLmNvcyhhbmdJKSAqIGluQW1wbGl0dWRlLCBweSAtIE1hdGguc2luKGFuZ0kpICogaW5BbXBsaXR1ZGUsIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQZXJwZW5kaWN1bGFyVmVjdG9yKHB0MSwgcHQyKSB7XG4gICAgdmFyIHZlY3RvciA9IFtwdDJbMF0gLSBwdDFbMF0sIHB0MlsxXSAtIHB0MVsxXV07XG4gICAgdmFyIHJvdCA9IC1NYXRoLlBJICogMC41O1xuICAgIHZhciByb3RhdGVkVmVjdG9yID0gW01hdGguY29zKHJvdCkgKiB2ZWN0b3JbMF0gLSBNYXRoLnNpbihyb3QpICogdmVjdG9yWzFdLCBNYXRoLnNpbihyb3QpICogdmVjdG9yWzBdICsgTWF0aC5jb3Mocm90KSAqIHZlY3RvclsxXV07XG4gICAgcmV0dXJuIHJvdGF0ZWRWZWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKSB7XG4gICAgdmFyIHByZXZJbmRleCA9IGN1ciA9PT0gMCA/IHBhdGgubGVuZ3RoKCkgLSAxIDogY3VyIC0gMTtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGN1ciArIDEpICUgcGF0aC5sZW5ndGgoKTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W3ByZXZJbmRleF07XG4gICAgdmFyIG5leHRQb2ludCA9IHBhdGgudltuZXh0SW5kZXhdO1xuICAgIHZhciBwVmVjdG9yID0gZ2V0UGVycGVuZGljdWxhclZlY3RvcihwcmV2UG9pbnQsIG5leHRQb2ludCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoMCwgMSkgLSBNYXRoLmF0YW4yKHBWZWN0b3JbMV0sIHBWZWN0b3JbMF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gemlnWmFnQ29ybmVyKG91dHB1dEJlemllciwgcGF0aCwgY3VyLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgYW5nbGUgPSBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKTtcbiAgICB2YXIgcG9pbnQgPSBwYXRoLnZbY3VyICUgcGF0aC5fbGVuZ3RoXTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W2N1ciA9PT0gMCA/IHBhdGguX2xlbmd0aCAtIDEgOiBjdXIgLSAxXTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52WyhjdXIgKyAxKSAlIHBhdGguX2xlbmd0aF07XG4gICAgdmFyIHByZXZEaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WzBdIC0gcHJldlBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gcHJldlBvaW50WzFdLCAyKSkgOiAwO1xuICAgIHZhciBuZXh0RGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhwb2ludFswXSAtIG5leHRQb2ludFswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIG5leHRQb2ludFsxXSwgMikpIDogMDtcbiAgICBzZXRQb2ludChvdXRwdXRCZXppZXIsIHBhdGgudltjdXIgJSBwYXRoLl9sZW5ndGhdLCBhbmdsZSwgZGlyZWN0aW9uLCBhbXBsaXR1ZGUsIG5leHREaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwcmV2RGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHppZ1phZ1NlZ21lbnQob3V0cHV0QmV6aWVyLCBzZWdtZW50LCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyZXF1ZW5jeTsgaSArPSAxKSB7XG4gICAgICB2YXIgdCA9IChpICsgMSkgLyAoZnJlcXVlbmN5ICsgMSk7XG4gICAgICB2YXIgZGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhzZWdtZW50LnBvaW50c1szXVswXSAtIHNlZ21lbnQucG9pbnRzWzBdWzBdLCAyKSArIE1hdGgucG93KHNlZ21lbnQucG9pbnRzWzNdWzFdIC0gc2VnbWVudC5wb2ludHNbMF1bMV0sIDIpKSA6IDA7XG4gICAgICB2YXIgYW5nbGUgPSBzZWdtZW50Lm5vcm1hbEFuZ2xlKHQpO1xuICAgICAgdmFyIHBvaW50ID0gc2VnbWVudC5wb2ludCh0KTtcbiAgICAgIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgZGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgICAgIGRpcmVjdGlvbiA9IC1kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgfVxuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSB7XG4gICAgdmFyIGNvdW50ID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XG5cbiAgICBpZiAoIXBhdGguYykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHJldHVybiBjbG9uZWRQYXRoO1xuICAgIHZhciBkaXJlY3Rpb24gPSAtMTtcbiAgICB2YXIgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KHBhdGgsIDApO1xuICAgIHppZ1phZ0Nvcm5lcihjbG9uZWRQYXRoLCBwYXRoLCAwLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBkaXJlY3Rpb24gPSB6aWdaYWdTZWdtZW50KGNsb25lZFBhdGgsIHNlZ21lbnQsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIC1kaXJlY3Rpb24pO1xuXG4gICAgICBpZiAoaSA9PT0gY291bnQgLSAxICYmICFwYXRoLmMpIHtcbiAgICAgICAgc2VnbWVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQocGF0aCwgKGkgKyAxKSAlIGNvdW50KTtcbiAgICAgIH1cblxuICAgICAgemlnWmFnQ29ybmVyKGNsb25lZFBhdGgsIHBhdGgsIGkgKyAxLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZWRQYXRoO1xuICB9O1xuXG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBhbXBsaXR1ZGUgPSB0aGlzLmFtcGxpdHVkZS52O1xuICAgIHZhciBmcmVxdWVuY3kgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHRoaXMuZnJlcXVlbmN5LnYpKTtcbiAgICB2YXIgcG9pbnRUeXBlID0gdGhpcy5wb2ludHNUeXBlLnY7XG5cbiAgICBpZiAoYW1wbGl0dWRlICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBsaW5lYXJPZmZzZXQocDEsIHAyLCBhbW91bnQpIHtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHAyWzBdIC0gcDFbMF0sIHAyWzFdIC0gcDFbMV0pO1xuICAgIHJldHVybiBbcG9sYXJPZmZzZXQocDEsIGFuZ2xlLCBhbW91bnQpLCBwb2xhck9mZnNldChwMiwgYW5nbGUsIGFtb3VudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0U2VnbWVudChzZWdtZW50LCBhbW91bnQpIHtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxYTtcbiAgICB2YXIgcDFiO1xuICAgIHZhciBwMmI7XG4gICAgdmFyIHAyYTtcbiAgICB2YXIgcDM7XG4gICAgdmFyIGU7XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1swXSwgc2VnbWVudC5wb2ludHNbMV0sIGFtb3VudCk7XG4gICAgcDAgPSBlWzBdO1xuICAgIHAxYSA9IGVbMV07XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1sxXSwgc2VnbWVudC5wb2ludHNbMl0sIGFtb3VudCk7XG4gICAgcDFiID0gZVswXTtcbiAgICBwMmIgPSBlWzFdO1xuICAgIGUgPSBsaW5lYXJPZmZzZXQoc2VnbWVudC5wb2ludHNbMl0sIHNlZ21lbnQucG9pbnRzWzNdLCBhbW91bnQpO1xuICAgIHAyYSA9IGVbMF07XG4gICAgcDMgPSBlWzFdO1xuICAgIHZhciBwMSA9IGxpbmVJbnRlcnNlY3Rpb24ocDAsIHAxYSwgcDFiLCBwMmIpO1xuICAgIGlmIChwMSA9PT0gbnVsbCkgcDEgPSBwMWE7XG4gICAgdmFyIHAyID0gbGluZUludGVyc2VjdGlvbihwMmEsIHAzLCBwMWIsIHAyYik7XG4gICAgaWYgKHAyID09PSBudWxsKSBwMiA9IHAyYTtcbiAgICByZXR1cm4gbmV3IFBvbHlub21pYWxCZXppZXIocDAsIHAxLCBwMiwgcDMpO1xuICB9XG5cbiAgZnVuY3Rpb24gam9pbkxpbmVzKG91dHB1dEJlemllciwgc2VnMSwgc2VnMiwgbGluZUpvaW4sIG1pdGVyTGltaXQpIHtcbiAgICB2YXIgcDAgPSBzZWcxLnBvaW50c1szXTtcbiAgICB2YXIgcDEgPSBzZWcyLnBvaW50c1swXTsgLy8gQmV2ZWxcblxuICAgIGlmIChsaW5lSm9pbiA9PT0gMykgcmV0dXJuIHAwOyAvLyBDb25uZWN0ZWQsIHRoZXkgZG9uJ3QgbmVlZCBhIGpvaW50XG5cbiAgICBpZiAocG9pbnRFcXVhbChwMCwgcDEpKSByZXR1cm4gcDA7IC8vIFJvdW5kXG5cbiAgICBpZiAobGluZUpvaW4gPT09IDIpIHtcbiAgICAgIHZhciBhbmdsZU91dCA9IC1zZWcxLnRhbmdlbnRBbmdsZSgxKTtcbiAgICAgIHZhciBhbmdsZUluID0gLXNlZzIudGFuZ2VudEFuZ2xlKDApICsgTWF0aC5QSTtcbiAgICAgIHZhciBjZW50ZXIgPSBsaW5lSW50ZXJzZWN0aW9uKHAwLCBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQgKyBNYXRoLlBJIC8gMiwgMTAwKSwgcDEsIHBvbGFyT2Zmc2V0KHAxLCBhbmdsZU91dCArIE1hdGguUEkgLyAyLCAxMDApKTtcbiAgICAgIHZhciByYWRpdXMgPSBjZW50ZXIgPyBwb2ludERpc3RhbmNlKGNlbnRlciwgcDApIDogcG9pbnREaXN0YW5jZShwMCwgcDEpIC8gMjtcbiAgICAgIHZhciB0YW4gPSBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQsIDIgKiByYWRpdXMgKiByb3VuZENvcm5lcik7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0WFlBdCh0YW5bMF0sIHRhblsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHRhbiA9IHBvbGFyT2Zmc2V0KHAxLCBhbmdsZUluLCAyICogcmFkaXVzICogcm91bmRDb3JuZXIpO1xuICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHAxWzBdLCBwMVsxXSwgcDFbMF0sIHAxWzFdLCB0YW5bMF0sIHRhblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBwMTtcbiAgICB9IC8vIE1pdGVyXG5cblxuICAgIHZhciB0MCA9IHBvaW50RXF1YWwocDAsIHNlZzEucG9pbnRzWzJdKSA/IHNlZzEucG9pbnRzWzBdIDogc2VnMS5wb2ludHNbMl07XG4gICAgdmFyIHQxID0gcG9pbnRFcXVhbChwMSwgc2VnMi5wb2ludHNbMV0pID8gc2VnMi5wb2ludHNbM10gOiBzZWcyLnBvaW50c1sxXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbih0MCwgcDAsIHAxLCB0MSk7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uICYmIHBvaW50RGlzdGFuY2UoaW50ZXJzZWN0aW9uLCBwMCkgPCBtaXRlckxpbWl0KSB7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0sIGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdLCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBpbnRlcnNlY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaW50ZXJzZWN0ID0gYS5pbnRlcnNlY3Rpb25zKGIpO1xuICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoICYmIGZsb2F0RXF1YWwoaW50ZXJzZWN0WzBdWzBdLCAxKSkgaW50ZXJzZWN0LnNoaWZ0KCk7XG4gICAgaWYgKGludGVyc2VjdC5sZW5ndGgpIHJldHVybiBpbnRlcnNlY3RbMF07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oYSwgYikge1xuICAgIHZhciBvdXRhID0gYS5zbGljZSgpO1xuICAgIHZhciBvdXRiID0gYi5zbGljZSgpO1xuICAgIHZhciBpbnRlcnNlY3QgPSBnZXRJbnRlcnNlY3Rpb24oYVthLmxlbmd0aCAtIDFdLCBiWzBdKTtcblxuICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgIG91dGFbYS5sZW5ndGggLSAxXSA9IGFbYS5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdO1xuICAgICAgb3V0YlswXSA9IGJbMF0uc3BsaXQoaW50ZXJzZWN0WzFdKVsxXTtcbiAgICB9XG5cbiAgICBpZiAoYS5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkge1xuICAgICAgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0aW9uKGFbMF0sIGJbYi5sZW5ndGggLSAxXSk7XG5cbiAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgcmV0dXJuIFtbYVswXS5zcGxpdChpbnRlcnNlY3RbMF0pWzBdXSwgW2JbYi5sZW5ndGggLSAxXS5zcGxpdChpbnRlcnNlY3RbMV0pWzFdXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtvdXRhLCBvdXRiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lSW50ZXJzZWN0aW9ucyhzZWdtZW50cykge1xuICAgIHZhciBlO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZSA9IHBydW5lU2VnbWVudEludGVyc2VjdGlvbihzZWdtZW50c1tpIC0gMV0sIHNlZ21lbnRzW2ldKTtcbiAgICAgIHNlZ21lbnRzW2kgLSAxXSA9IGVbMF07XG4gICAgICBzZWdtZW50c1tpXSA9IGVbMV07XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGUgPSBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIHNlZ21lbnRzWzBdKTtcbiAgICAgIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdID0gZVswXTtcbiAgICAgIHNlZ21lbnRzWzBdID0gZVsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cblxuICBmdW5jdGlvbiBvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSB7XG4gICAgLypcclxuICAgICAgV2Ugc3BsaXQgZWFjaCBiZXppZXIgc2VnbWVudCBpbnRvIHNtYWxsZXIgcGllY2VzIGJhc2VkXHJcbiAgICAgIG9uIGluZmxlY3Rpb24gcG9pbnRzLCB0aGlzIGVuc3VyZXMgdGhlIGNvbnRyb2wgcG9pbnRcclxuICAgICAgcG9seWdvbiBpcyBjb252ZXguXHJcbiAgICAgICAgKEEgY3ViaWMgYmV6aWVyIGNhbiBoYXZlIG5vbmUsIG9uZSwgb3IgdHdvIGluZmxlY3Rpb24gcG9pbnRzKVxyXG4gICAgKi9cbiAgICB2YXIgZmxleCA9IHNlZ21lbnQuaW5mbGVjdGlvblBvaW50cygpO1xuICAgIHZhciBsZWZ0O1xuICAgIHZhciByaWdodDtcbiAgICB2YXIgc3BsaXQ7XG4gICAgdmFyIG1pZDtcblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMSB8fCBmbG9hdEVxdWFsKGZsZXhbMV0sIDEpKSB7XG4gICAgICBzcGxpdCA9IHNlZ21lbnQuc3BsaXQoZmxleFswXSk7XG4gICAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgICByaWdodCA9IHNwbGl0WzFdO1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQocmlnaHQsIGFtb3VudCldO1xuICAgIH1cblxuICAgIHNwbGl0ID0gc2VnbWVudC5zcGxpdChmbGV4WzBdKTtcbiAgICBsZWZ0ID0gc3BsaXRbMF07XG4gICAgdmFyIHQgPSAoZmxleFsxXSAtIGZsZXhbMF0pIC8gKDEgLSBmbGV4WzBdKTtcbiAgICBzcGxpdCA9IHNwbGl0WzFdLnNwbGl0KHQpO1xuICAgIG1pZCA9IHNwbGl0WzBdO1xuICAgIHJpZ2h0ID0gc3BsaXRbMV07XG4gICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KGxlZnQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQobWlkLCBhbW91bnQpLCBvZmZzZXRTZWdtZW50KHJpZ2h0LCBhbW91bnQpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIE9mZnNldFBhdGhNb2RpZmllcigpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgT2Zmc2V0UGF0aE1vZGlmaWVyKTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMuYW1vdW50ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5hLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm1pdGVyTGltaXQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm1sLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmxpbmVKb2luID0gZGF0YS5sajtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAhPT0gMDtcbiAgfTtcblxuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKGlucHV0QmV6aWVyLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSB7XG4gICAgdmFyIG91dHB1dEJlemllciA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgb3V0cHV0QmV6aWVyLmMgPSBpbnB1dEJlemllci5jO1xuICAgIHZhciBjb3VudCA9IGlucHV0QmV6aWVyLmxlbmd0aCgpO1xuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBqO1xuICAgIHZhciBzZWdtZW50O1xuICAgIHZhciBtdWx0aVNlZ21lbnRzID0gW107XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KGlucHV0QmV6aWVyLCBpKTtcbiAgICAgIG11bHRpU2VnbWVudHMucHVzaChvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnB1dEJlemllci5jKSB7XG4gICAgICBmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSBQb2x5bm9taWFsQmV6aWVyLnNoYXBlU2VnbWVudEludmVydGVkKGlucHV0QmV6aWVyLCBpKTtcbiAgICAgICAgbXVsdGlTZWdtZW50cy5wdXNoKG9mZnNldFNlZ21lbnRTcGxpdChzZWdtZW50LCBhbW91bnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtdWx0aVNlZ21lbnRzID0gcHJ1bmVJbnRlcnNlY3Rpb25zKG11bHRpU2VnbWVudHMpOyAvLyBBZGQgYmV6aWVyIHNlZ21lbnRzIHRvIHRoZSBvdXRwdXQgYW5kIGFwcGx5IGxpbmUgam9pbnRzXG5cbiAgICB2YXIgbGFzdFBvaW50ID0gbnVsbDtcbiAgICB2YXIgbGFzdFNlZyA9IG51bGw7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbXVsdGlTZWdtZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG11bHRpU2VnbWVudCA9IG11bHRpU2VnbWVudHNbaV07XG4gICAgICBpZiAobGFzdFNlZykgbGFzdFBvaW50ID0gam9pbkxpbmVzKG91dHB1dEJlemllciwgbGFzdFNlZywgbXVsdGlTZWdtZW50WzBdLCBsaW5lSm9pbiwgbWl0ZXJMaW1pdCk7XG4gICAgICBsYXN0U2VnID0gbXVsdGlTZWdtZW50W211bHRpU2VnbWVudC5sZW5ndGggLSAxXTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IG11bHRpU2VnbWVudC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBzZWdtZW50ID0gbXVsdGlTZWdtZW50W2pdO1xuXG4gICAgICAgIGlmIChsYXN0UG9pbnQgJiYgcG9pbnRFcXVhbChzZWdtZW50LnBvaW50c1swXSwgbGFzdFBvaW50KSkge1xuICAgICAgICAgIG91dHB1dEJlemllci5zZXRYWUF0KHNlZ21lbnQucG9pbnRzWzFdWzBdLCBzZWdtZW50LnBvaW50c1sxXVsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXRCZXppZXIuc2V0VHJpcGxlQXQoc2VnbWVudC5wb2ludHNbMF1bMF0sIHNlZ21lbnQucG9pbnRzWzBdWzFdLCBzZWdtZW50LnBvaW50c1sxXVswXSwgc2VnbWVudC5wb2ludHNbMV1bMV0sIHNlZ21lbnQucG9pbnRzWzBdWzBdLCBzZWdtZW50LnBvaW50c1swXVsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dEJlemllci5zZXRUcmlwbGVBdChzZWdtZW50LnBvaW50c1szXVswXSwgc2VnbWVudC5wb2ludHNbM11bMV0sIHNlZ21lbnQucG9pbnRzWzNdWzBdLCBzZWdtZW50LnBvaW50c1szXVsxXSwgc2VnbWVudC5wb2ludHNbMl1bMF0sIHNlZ21lbnQucG9pbnRzWzJdWzFdLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkpO1xuICAgICAgICBsYXN0UG9pbnQgPSBzZWdtZW50LnBvaW50c1szXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobXVsdGlTZWdtZW50cy5sZW5ndGgpIGpvaW5MaW5lcyhvdXRwdXRCZXppZXIsIGxhc3RTZWcsIG11bHRpU2VnbWVudHNbMF1bMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICByZXR1cm4gb3V0cHV0QmV6aWVyO1xuICB9O1xuXG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcbiAgICB2YXIgbWl0ZXJMaW1pdCA9IHRoaXMubWl0ZXJMaW1pdC52O1xuICAgIHZhciBsaW5lSm9pbiA9IHRoaXMubGluZUpvaW47XG5cbiAgICBpZiAoYW1vdW50ICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuXG4gICAgICAgIGlmICghKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XG4gICAgICAgICAgakxlbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5fbGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSkge1xuICAgIHZhciBzdHlsZXMgPSBmb250RGF0YS5mU3R5bGUgPyBmb250RGF0YS5mU3R5bGUuc3BsaXQoJyAnKSA6IFtdO1xuICAgIHZhciBmV2VpZ2h0ID0gJ25vcm1hbCc7XG4gICAgdmFyIGZTdHlsZSA9ICdub3JtYWwnO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZU5hbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZU5hbWUgPSBzdHlsZXNbaV0udG9Mb3dlckNhc2UoKTtcblxuICAgICAgc3dpdGNoIChzdHlsZU5hbWUpIHtcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICBmU3R5bGUgPSAnaXRhbGljJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdib2xkJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzcwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYmxhY2snOlxuICAgICAgICAgIGZXZWlnaHQgPSAnOTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNTAwJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZWd1bGFyJzpcbiAgICAgICAgY2FzZSAnbm9ybWFsJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzQwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbGlnaHQnOlxuICAgICAgICBjYXNlICd0aGluJzpcbiAgICAgICAgICBmV2VpZ2h0ID0gJzIwMCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGU6IGZTdHlsZSxcbiAgICAgIHdlaWdodDogZm9udERhdGEuZldlaWdodCB8fCBmV2VpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHZhciBGb250TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4V2FpdGluZ1RpbWUgPSA1MDAwO1xuICAgIHZhciBlbXB0eUNoYXIgPSB7XG4gICAgICB3OiAwLFxuICAgICAgc2l6ZTogMCxcbiAgICAgIHNoYXBlczogW10sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHNoYXBlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBjb21iaW5lZENoYXJhY3RlcnMgPSBbXTsgLy8gSGluZGkgY2hhcmFjdGVyc1xuXG4gICAgY29tYmluZWRDaGFyYWN0ZXJzID0gY29tYmluZWRDaGFyYWN0ZXJzLmNvbmNhdChbMjMwNCwgMjMwNSwgMjMwNiwgMjMwNywgMjM2MiwgMjM2MywgMjM2NCwgMjM2NCwgMjM2NiwgMjM2NywgMjM2OCwgMjM2OSwgMjM3MCwgMjM3MSwgMjM3MiwgMjM3MywgMjM3NCwgMjM3NSwgMjM3NiwgMjM3NywgMjM3OCwgMjM3OSwgMjM4MCwgMjM4MSwgMjM4MiwgMjM4MywgMjM4NywgMjM4OCwgMjM4OSwgMjM5MCwgMjM5MSwgMjQwMiwgMjQwM10pO1xuICAgIHZhciBCTEFDS19GTEFHX0NPREVfUE9JTlQgPSAxMjc5ODg7XG4gICAgdmFyIENBTkNFTF9UQUdfQ09ERV9QT0lOVCA9IDkxNzYzMTtcbiAgICB2YXIgQV9UQUdfQ09ERV9QT0lOVCA9IDkxNzYwMTtcbiAgICB2YXIgWl9UQUdfQ09ERV9QT0lOVCA9IDkxNzYyNjtcbiAgICB2YXIgVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQgPSA2NTAzOTtcbiAgICB2YXIgWkVST19XSURUSF9KT0lORVJfQ09ERV9QT0lOVCA9IDgyMDU7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9BX0NPREVfUE9JTlQgPSAxMjc0NjI7XG4gICAgdmFyIFJFR0lPTkFMX0NIQVJBQ1RFUl9aX0NPREVfUE9JTlQgPSAxMjc0ODc7XG4gICAgdmFyIHN1cnJvZ2F0ZU1vZGlmaWVycyA9IFsnZDgzY2RmZmInLCAnZDgzY2RmZmMnLCAnZDgzY2RmZmQnLCAnZDgzY2RmZmUnLCAnZDgzY2RmZmYnXTtcblxuICAgIGZ1bmN0aW9uIHRyaW1Gb250T3B0aW9ucyhmb250KSB7XG4gICAgICB2YXIgZmFtaWx5QXJyYXkgPSBmb250LnNwbGl0KCcsJyk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmYW1pbHlBcnJheS5sZW5ndGg7XG4gICAgICB2YXIgZW5hYmxlZEZhbWlsaWVzID0gW107XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZmFtaWx5QXJyYXlbaV0gIT09ICdzYW5zLXNlcmlmJyAmJiBmYW1pbHlBcnJheVtpXSAhPT0gJ21vbm9zcGFjZScpIHtcbiAgICAgICAgICBlbmFibGVkRmFtaWxpZXMucHVzaChmYW1pbHlBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVuYWJsZWRGYW1pbGllcy5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0VXBOb2RlKGZvbnQsIGZhbWlseSkge1xuICAgICAgdmFyIHBhcmVudE5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gTm9kZSBpcyBpbnZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuXG5cbiAgICAgIHBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5mb250RmFtaWx5ID0gZmFtaWx5O1xuICAgICAgdmFyIG5vZGUgPSBjcmVhdGVUYWcoJ3NwYW4nKTsgLy8gQ2hhcmFjdGVycyB0aGF0IHZhcnkgc2lnbmlmaWNhbnRseSBhbW9uZyBkaWZmZXJlbnQgZm9udHNcblxuICAgICAgbm9kZS5pbm5lclRleHQgPSAnZ2lJdFQxV1F5QCEtLyMnOyAvLyBWaXNpYmxlIC0gc28gd2UgY2FuIG1lYXN1cmUgaXQgLSBidXQgbm90IG9uIHRoZSBzY3JlZW5cblxuICAgICAgcGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmxlZnQgPSAnLTEwMDAwcHgnO1xuICAgICAgcGFyZW50Tm9kZS5zdHlsZS50b3AgPSAnLTEwMDAwcHgnOyAvLyBMYXJnZSBmb250IHNpemUgbWFrZXMgZXZlbiBzdWJ0bGUgY2hhbmdlcyBvYnZpb3VzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFNpemUgPSAnMzAwcHgnOyAvLyBSZXNldCBhbnkgZm9udCBwcm9wZXJ0aWVzXG5cbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFZhcmlhbnQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFN0eWxlID0gJ25vcm1hbCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGV0dGVyU3BhY2luZyA9ICcwJztcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpOyAvLyBSZW1lbWJlciB3aWR0aCB3aXRoIG5vIGFwcGxpZWQgd2ViIGZvbnRcblxuICAgICAgdmFyIHdpZHRoID0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseSA9IHRyaW1Gb250T3B0aW9ucyhmb250KSArICcsICcgKyBmYW1pbHk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkRm9udHMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHc7XG4gICAgICB2YXIgbG9hZGVkQ291bnQgPSBsZW47XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5sb2FkZWQpIHtcbiAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udHNbaV0uZk9yaWdpbiA9PT0gJ24nIHx8IHRoaXMuZm9udHNbaV0ub3JpZ2luID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLm5vZGU7XG4gICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UudztcblxuICAgICAgICAgIGlmIChub2RlLm9mZnNldFdpZHRoICE9PSB3KSB7XG4gICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlID0gdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5ub2RlO1xuICAgICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UudztcblxuICAgICAgICAgICAgaWYgKG5vZGUub2Zmc2V0V2lkdGggIT09IHcpIHtcbiAgICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcbiAgICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5wYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxvYWRlZENvdW50ICE9PSAwICYmIERhdGUubm93KCkgLSB0aGlzLmluaXRUaW1lIDwgbWF4V2FpdGluZ1RpbWUpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHNCaW5kZWQsIDIwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zZXRJc0xvYWRlZEJpbmRlZCwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUhlbHBlcihmb250RGF0YSwgZGVmKSB7XG4gICAgICB2YXIgZW5naW5lID0gZG9jdW1lbnQuYm9keSAmJiBkZWYgPyAnc3ZnJyA6ICdjYW52YXMnO1xuICAgICAgdmFyIGhlbHBlcjtcbiAgICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG5cbiAgICAgIGlmIChlbmdpbmUgPT09ICdzdmcnKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICAgICAgdEhlbHBlci5zdHlsZS5mb250U2l6ZSA9ICcxMDBweCc7IC8vIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG5cbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZm9udFByb3BzLnN0eWxlKTtcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywgZm9udFByb3BzLndlaWdodCk7XG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnMSc7XG5cbiAgICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9ICdpbmhlcml0JztcbiAgICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XG4gICAgICAgIGhlbHBlciA9IHRIZWxwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdENhbnZhc0hlbHBlciA9IG5ldyBPZmZzY3JlZW5DYW52YXMoNTAwLCA1MDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRDYW52YXNIZWxwZXIuZm9udCA9IGZvbnRQcm9wcy5zdHlsZSArICcgJyArIGZvbnRQcm9wcy53ZWlnaHQgKyAnIDEwMHB4ICcgKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICBoZWxwZXIgPSB0Q2FudmFzSGVscGVyO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBtZWFzdXJlKHRleHQpIHtcbiAgICAgICAgaWYgKGVuZ2luZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBoZWxwZXIudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgIHJldHVybiBoZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaGVscGVyLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRGb250cyhmb250RGF0YSwgZGVmcykge1xuICAgICAgaWYgKCFmb250RGF0YSkge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mb250cyA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBmb250RGF0YS5saXN0LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihkYXRhKTtcbiAgICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZm9udEFyciA9IGZvbnREYXRhLmxpc3Q7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBmb250QXJyLmxlbmd0aDtcbiAgICAgIHZhciBfcGVuZGluZ0ZvbnRzID0gbGVuO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNob3VsZExvYWRGb250ID0gdHJ1ZTtcbiAgICAgICAgdmFyIGxvYWRlZFNlbGVjdG9yO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgZm9udEFycltpXS5tb25vQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdtb25vc3BhY2UnKTtcbiAgICAgICAgZm9udEFycltpXS5zYW5zQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksICdzYW5zLXNlcmlmJyk7XG5cbiAgICAgICAgaWYgKCFmb250QXJyW2ldLmZQYXRoKSB7XG4gICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIF9wZW5kaW5nRm9udHMgLT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMykge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZi1mb3JpZ2luPVwicFwiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdLCBzdHlsZVtmLW9yaWdpbj1cIjNcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXScpO1xuXG4gICAgICAgICAgaWYgKGxvYWRlZFNlbGVjdG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgcyA9IGNyZWF0ZVRhZygnc3R5bGUnKTtcbiAgICAgICAgICAgIHMuc2V0QXR0cmlidXRlKCdmLWZvcmlnaW4nLCBmb250QXJyW2ldLmZPcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2Ytb3JpZ2luJywgZm9udEFycltpXS5vcmlnaW4pO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZmFtaWx5JywgZm9udEFycltpXS5mRmFtaWx5KTtcbiAgICAgICAgICAgIHMudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBzLmlubmVyVGV4dCA9ICdAZm9udC1mYWNlIHtmb250LWZhbWlseTogJyArIGZvbnRBcnJbaV0uZkZhbWlseSArIFwiOyBmb250LXN0eWxlOiBub3JtYWw7IHNyYzogdXJsKCdcIiArIGZvbnRBcnJbaV0uZlBhdGggKyBcIicpO31cIjtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnRBcnJbaV0uZk9yaWdpbiA9PT0gJ2cnIHx8IGZvbnRBcnJbaV0ub3JpZ2luID09PSAxKSB7XG4gICAgICAgICAgbG9hZGVkU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2YtZm9yaWdpbj1cImdcIl0sIGxpbmtbZi1vcmlnaW49XCIxXCJdJyk7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3RvcltqXS5ocmVmLmluZGV4T2YoZm9udEFycltpXS5mUGF0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBsID0gY3JlYXRlVGFnKCdsaW5rJyk7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIGwuc2V0QXR0cmlidXRlKCdmLW9yaWdpbicsIGZvbnRBcnJbaV0ub3JpZ2luKTtcbiAgICAgICAgICAgIGwudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBsLnJlbCA9ICdzdHlsZXNoZWV0JztcbiAgICAgICAgICAgIGwuaHJlZiA9IGZvbnRBcnJbaV0uZlBhdGg7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICd0JyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMikge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W2YtZm9yaWdpbj1cInRcIl0sIHNjcmlwdFtmLW9yaWdpbj1cIjJcIl0nKTtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsb2FkZWRTZWxlY3Rvci5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgaWYgKGZvbnRBcnJbaV0uZlBhdGggPT09IGxvYWRlZFNlbGVjdG9yW2pdLnNyYykge1xuICAgICAgICAgICAgICAvLyBGb250IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgIHNob3VsZExvYWRGb250ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBmb250QXJyW2ldLmZQYXRoKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvbnRBcnJbaV0uaGVscGVyID0gY3JlYXRlSGVscGVyKGZvbnRBcnJbaV0sIGRlZnMpO1xuICAgICAgICBmb250QXJyW2ldLmNhY2hlID0ge307XG4gICAgICAgIHRoaXMuZm9udHMucHVzaChmb250QXJyW2ldKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9wZW5kaW5nRm9udHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbiBzb21lIGNhc2VzIGV2ZW4gaWYgdGhlIGZvbnQgaXMgbG9hZGVkLCBpdCB3b24ndCBsb2FkIGNvcnJlY3RseSB3aGVuIG1lYXN1cmluZyB0ZXh0IG9uIGNhbnZhcy5cbiAgICAgICAgLy8gQWRkaW5nIHRoaXMgdGltZW91dCBzZWVtcyB0byBmaXggaXRcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKSwgMTAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDaGFycyhjaGFycykge1xuICAgICAgaWYgKCFjaGFycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5jaGFycykge1xuICAgICAgICB0aGlzLmNoYXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcbiAgICAgIHZhciBmb3VuZDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIHdoaWxlIChqIDwgakxlbikge1xuICAgICAgICAgIGlmICh0aGlzLmNoYXJzW2pdLnN0eWxlID09PSBjaGFyc1tpXS5zdHlsZSAmJiB0aGlzLmNoYXJzW2pdLmZGYW1pbHkgPT09IGNoYXJzW2ldLmZGYW1pbHkgJiYgdGhpcy5jaGFyc1tqXS5jaCA9PT0gY2hhcnNbaV0uY2gpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBqTGVuICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDaGFyRGF0YShfY2hhciwgc3R5bGUsIGZvbnQpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhcnNbaV0uY2ggPT09IF9jaGFyICYmIHRoaXMuY2hhcnNbaV0uc3R5bGUgPT09IHN0eWxlICYmIHRoaXMuY2hhcnNbaV0uZkZhbWlseSA9PT0gZm9udCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNoYXJzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoKHR5cGVvZiBfY2hhciA9PT0gJ3N0cmluZycgJiYgX2NoYXIuY2hhckNvZGVBdCgwKSAhPT0gMTMgfHwgIV9jaGFyKSAmJiBjb25zb2xlICYmIGNvbnNvbGUud2FybiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICYmICF0aGlzLl93YXJuZWQpIHtcbiAgICAgICAgdGhpcy5fd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGNoYXJhY3RlciBmcm9tIGV4cG9ydGVkIGNoYXJhY3RlcnMgbGlzdDogJywgX2NoYXIsIHN0eWxlLCBmb250KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlbXB0eUNoYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHQoX2NoYXIyLCBmb250TmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnREYXRhID0gdGhpcy5nZXRGb250QnlOYW1lKGZvbnROYW1lKTsgLy8gVXNpbmcgdGhlIGNoYXIgaW5zdGVhZCBvZiBjaGFyLmNoYXJDb2RlQXQoMClcbiAgICAgIC8vIHRvIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlcXVhbCBjaGFyc1xuXG4gICAgICB2YXIgaW5kZXggPSBfY2hhcjI7XG5cbiAgICAgIGlmICghZm9udERhdGEuY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gZm9udERhdGEuaGVscGVyO1xuXG4gICAgICAgIGlmIChfY2hhcjIgPT09ICcgJykge1xuICAgICAgICAgIHZhciBkb3VibGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfCcgKyBfY2hhcjIgKyAnfCcpO1xuICAgICAgICAgIHZhciBzaW5nbGVTaXplID0gdEhlbHBlci5tZWFzdXJlVGV4dCgnfHwnKTtcbiAgICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleF0gPSAoZG91YmxlU2l6ZSAtIHNpbmdsZVNpemUpIC8gMTAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvbnREYXRhLmNhY2hlW2luZGV4XSA9IHRIZWxwZXIubWVhc3VyZVRleHQoX2NoYXIyKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZm9udERhdGEuY2FjaGVbaW5kZXhdICogc2l6ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGb250QnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udHNbaV0uZk5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mb250c1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29kZVBvaW50KHN0cmluZykge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IDA7XG4gICAgICB2YXIgZmlyc3QgPSBzdHJpbmcuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGZpcnN0ID49IDB4RDgwMCAmJiBmaXJzdCA8PSAweERCRkYpIHtcbiAgICAgICAgdmFyIHNlY29uZCA9IHN0cmluZy5jaGFyQ29kZUF0KDEpO1xuXG4gICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfSAvLyBTa2luIHRvbmUgbW9kaWZpZXJzXG5cblxuICAgIGZ1bmN0aW9uIGlzTW9kaWZpZXIoZmlyc3RDaGFyQ29kZSwgc2Vjb25kQ2hhckNvZGUpIHtcbiAgICAgIHZhciBzdW0gPSBmaXJzdENoYXJDb2RlLnRvU3RyaW5nKDE2KSArIHNlY29uZENoYXJDb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBzdXJyb2dhdGVNb2RpZmllcnMuaW5kZXhPZihzdW0pICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkge1xuICAgICAgcmV0dXJuIGNoYXJDb2RlID09PSBaRVJPX1dJRFRIX0pPSU5FUl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhpcyBjb2RlcG9pbnQgbWF5IGNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICAvLyBJZiB0aGF0IGlzIGEgc3ltYm9sLCBkaW5nYmF0IG9yIGVtb2ppLCBVK0ZFMEYgZm9yY2VzIGl0IHRvIGJlIHJlbmRlcmVkXG4gICAgLy8gYXMgYSBjb2xvcmZ1bCBpbWFnZSBhcyBjb21wYXJlZCB0byBhIG1vbm9jaHJvbWUgdGV4dCB2YXJpYW50LlxuXG5cbiAgICBmdW5jdGlvbiBpc1ZhcmlhdGlvblNlbGVjdG9yKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gY2hhckNvZGUgPT09IFZBUklBVElPTl9TRUxFQ1RPUl8xNl9DT0RFX1BPSU5UO1xuICAgIH0gLy8gVGhlIHJlZ2lvbmFsIGluZGljYXRvciBzeW1ib2xzIGFyZSBhIHNldCBvZiAyNiBhbHBoYWJldGljIFVuaWNvZGVcbiAgICAvLy8gY2hhcmFjdGVycyAoQeKAk1opIGludGVuZGVkIHRvIGJlIHVzZWQgdG8gZW5jb2RlIElTTyAzMTY2LTEgYWxwaGEtMlxuICAgIC8vIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlcyBpbiBhIHdheSB0aGF0IGFsbG93cyBvcHRpb25hbCBzcGVjaWFsIHRyZWF0bWVudC5cblxuXG4gICAgZnVuY3Rpb24gaXNSZWdpb25hbENvZGUoc3RyaW5nKSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0Q29kZVBvaW50KHN0cmluZyk7XG5cbiAgICAgIGlmIChjb2RlUG9pbnQgPj0gUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCAmJiBjb2RlUG9pbnQgPD0gUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gU29tZSBFbW9qaSBpbXBsZW1lbnRhdGlvbnMgcmVwcmVzZW50IGNvbWJpbmF0aW9ucyBvZlxuICAgIC8vIHR3byDigJxyZWdpb25hbCBpbmRpY2F0b3LigJ0gbGV0dGVycyBhcyBhIHNpbmdsZSBmbGFnIHN5bWJvbC5cblxuXG4gICAgZnVuY3Rpb24gaXNGbGFnRW1vamkoc3RyaW5nKSB7XG4gICAgICByZXR1cm4gaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigwLCAyKSkgJiYgaXNSZWdpb25hbENvZGUoc3RyaW5nLnN1YnN0cigyLCAyKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDb21iaW5lZENoYXJhY3RlcihfY2hhcjMpIHtcbiAgICAgIHJldHVybiBjb21iaW5lZENoYXJhY3RlcnMuaW5kZXhPZihfY2hhcjMpICE9PSAtMTtcbiAgICB9IC8vIFJlZ2lvbmFsIGZsYWdzIHN0YXJ0IHdpdGggYSBCTEFDS19GTEFHX0NPREVfUE9JTlRcbiAgICAvLyBmb2xvd2VkIGJ5IDUgY2hhcnMgaW4gdGhlIFRBRyByYW5nZVxuICAgIC8vIGFuZCBlbmQgd2l0aCBhIENBTkNFTF9UQUdfQ09ERV9QT0lOVFxuXG5cbiAgICBmdW5jdGlvbiBpc1JlZ2lvbmFsRmxhZyh0ZXh0LCBpbmRleCkge1xuICAgICAgdmFyIGNvZGVQb2ludCA9IGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpO1xuXG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBCTEFDS19GTEFHX0NPREVfUE9JTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgd2hpbGUgKGNvdW50IDwgNSkge1xuICAgICAgICBjb2RlUG9pbnQgPSBnZXRDb2RlUG9pbnQodGV4dC5zdWJzdHIoaW5kZXgsIDIpKTtcblxuICAgICAgICBpZiAoY29kZVBvaW50IDwgQV9UQUdfQ09ERV9QT0lOVCB8fCBjb2RlUG9pbnQgPiBaX1RBR19DT0RFX1BPSU5UKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpID09PSBDQU5DRUxfVEFHX0NPREVfUE9JTlQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0SXNMb2FkZWQoKSB7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgRm9udCA9IGZ1bmN0aW9uIEZvbnQoKSB7XG4gICAgICB0aGlzLmZvbnRzID0gW107XG4gICAgICB0aGlzLmNoYXJzID0gbnVsbDtcbiAgICAgIHRoaXMudHlwZWtpdExvYWRlZCA9IDA7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl93YXJuZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW5pdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgdGhpcy5zZXRJc0xvYWRlZEJpbmRlZCA9IHRoaXMuc2V0SXNMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY2hlY2tMb2FkZWRGb250c0JpbmRlZCA9IHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpO1xuICAgIH07XG5cbiAgICBGb250LmlzTW9kaWZpZXIgPSBpc01vZGlmaWVyO1xuICAgIEZvbnQuaXNaZXJvV2lkdGhKb2luZXIgPSBpc1plcm9XaWR0aEpvaW5lcjtcbiAgICBGb250LmlzRmxhZ0Vtb2ppID0gaXNGbGFnRW1vamk7XG4gICAgRm9udC5pc1JlZ2lvbmFsQ29kZSA9IGlzUmVnaW9uYWxDb2RlO1xuICAgIEZvbnQuaXNDb21iaW5lZENoYXJhY3RlciA9IGlzQ29tYmluZWRDaGFyYWN0ZXI7XG4gICAgRm9udC5pc1JlZ2lvbmFsRmxhZyA9IGlzUmVnaW9uYWxGbGFnO1xuICAgIEZvbnQuaXNWYXJpYXRpb25TZWxlY3RvciA9IGlzVmFyaWF0aW9uU2VsZWN0b3I7XG4gICAgRm9udC5CTEFDS19GTEFHX0NPREVfUE9JTlQgPSBCTEFDS19GTEFHX0NPREVfUE9JTlQ7XG4gICAgdmFyIGZvbnRQcm90b3R5cGUgPSB7XG4gICAgICBhZGRDaGFyczogYWRkQ2hhcnMsXG4gICAgICBhZGRGb250czogYWRkRm9udHMsXG4gICAgICBnZXRDaGFyRGF0YTogZ2V0Q2hhckRhdGEsXG4gICAgICBnZXRGb250QnlOYW1lOiBnZXRGb250QnlOYW1lLFxuICAgICAgbWVhc3VyZVRleHQ6IG1lYXN1cmVUZXh0LFxuICAgICAgY2hlY2tMb2FkZWRGb250czogY2hlY2tMb2FkZWRGb250cyxcbiAgICAgIHNldElzTG9hZGVkOiBzZXRJc0xvYWRlZFxuICAgIH07XG4gICAgRm9udC5wcm90b3R5cGUgPSBmb250UHJvdG90eXBlO1xuICAgIHJldHVybiBGb250O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2xvdE1hbmFnZXIoYW5pbWF0aW9uRGF0YSkge1xuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1hdGlvbkRhdGE7XG4gIH1cblxuICBTbG90TWFuYWdlci5wcm90b3R5cGUuZ2V0UHJvcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90cyAmJiB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdLnApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNsb3RGYWN0b3J5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNsb3RNYW5hZ2VyKGFuaW1hdGlvbkRhdGEpO1xuICB9XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZUVsZW1lbnQoKSB7fVxuXG4gIFJlbmRlcmFibGVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24gaW5pdFJlbmRlcmFibGUoKSB7XG4gICAgICAvLyBsYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcbiAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7IC8vIGxheWVyJ3MgZGlzcGxheSBzdGF0ZVxuXG4gICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlOyAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxuXG4gICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTsgLy8gbGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXG5cbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMgPSBbXTtcbiAgICB9LFxuICAgIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uIGFkZFJlbmRlcmFibGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5zcGxpY2UodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlbmRlcmFibGVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllckxpbWl0cyhudW0pO1xuICAgIH0sXG4gICAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uIGNoZWNrVHJhbnNwYXJlbmN5KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52IDw9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNwYXJlbnQgJiYgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgICAqIEBmdW5jdGlvblxyXG4gICAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXHJcbiAgICAgICAqXHJcbiAgICAgICAqL1xuICAgIGNoZWNrTGF5ZXJMaW1pdHM6IGZ1bmN0aW9uIGNoZWNrTGF5ZXJMaW1pdHMobnVtKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLmlwIC0gdGhpcy5kYXRhLnN0IDw9IG51bSAmJiB0aGlzLmRhdGEub3AgLSB0aGlzLmRhdGEuc3QgPiBudW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJblJhbmdlICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyUmVuZGVyYWJsZTogZnVuY3Rpb24gcmVuZGVyUmVuZGVyYWJsZSgpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgICAgLyogdGhpcy5tYXNrTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XHJcbiAgICAgICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpOyAqL1xuXG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB3aWR0aDogMTAwLFxuICAgICAgICBoZWlnaHQ6IDEwMFxuICAgICAgfTtcbiAgICB9LFxuICAgIGdldExheWVyU2l6ZTogZnVuY3Rpb24gZ2V0TGF5ZXJTaXplKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHc6IHRoaXMuZGF0YS50ZXh0RGF0YS53aWR0aCxcbiAgICAgICAgICBoOiB0aGlzLmRhdGEudGV4dERhdGEuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHRoaXMuZGF0YS53aWR0aCxcbiAgICAgICAgaDogdGhpcy5kYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEJsZW5kTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XG4gICAgICAwOiAnc291cmNlLW92ZXInLFxuICAgICAgMTogJ211bHRpcGx5JyxcbiAgICAgIDI6ICdzY3JlZW4nLFxuICAgICAgMzogJ292ZXJsYXknLFxuICAgICAgNDogJ2RhcmtlbicsXG4gICAgICA1OiAnbGlnaHRlbicsXG4gICAgICA2OiAnY29sb3ItZG9kZ2UnLFxuICAgICAgNzogJ2NvbG9yLWJ1cm4nLFxuICAgICAgODogJ2hhcmQtbGlnaHQnLFxuICAgICAgOTogJ3NvZnQtbGlnaHQnLFxuICAgICAgMTA6ICdkaWZmZXJlbmNlJyxcbiAgICAgIDExOiAnZXhjbHVzaW9uJyxcbiAgICAgIDEyOiAnaHVlJyxcbiAgICAgIDEzOiAnc2F0dXJhdGlvbicsXG4gICAgICAxNDogJ2NvbG9yJyxcbiAgICAgIDE1OiAnbHVtaW5vc2l0eSdcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgcmV0dXJuIGJsZW5kTW9kZUVudW1zW21vZGVdIHx8ICcnO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbGlkZXJFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQW5nbGVFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29sb3JFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gUG9pbnRFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTGF5ZXJJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cblxuICBmdW5jdGlvbiBNYXNrSW5kZXhFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gQ2hlY2tib3hFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gTm9WYWx1ZUVmZmVjdCgpIHtcbiAgICB0aGlzLnAgPSB7fTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVmZmVjdHNNYW5hZ2VyKGRhdGEsIGVsZW1lbnQpIHtcbiAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWYgfHwgW107XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlZmZlY3RzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0SXRlbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZWZmZWN0SXRlbSA9IG5ldyBHcm91cEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50KTtcbiAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmZlY3RJdGVtKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBHcm91cEVmZmVjdChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5pbml0KGRhdGEsIGVsZW1lbnQpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBHcm91cEVmZmVjdCk7XG4gIEdyb3VwRWZmZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IEdyb3VwRWZmZWN0LnByb3RvdHlwZS5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XG5cbiAgR3JvdXBFZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtZW50KTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmVmLmxlbmd0aDtcbiAgICB2YXIgZWZmO1xuICAgIHZhciBlZmZlY3RzID0gdGhpcy5kYXRhLmVmO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmYgPSBudWxsO1xuXG4gICAgICBzd2l0Y2ggKGVmZmVjdHNbaV0udHkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGVmZiA9IG5ldyBTbGlkZXJFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGVmZiA9IG5ldyBBbmdsZUVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZWZmID0gbmV3IENvbG9yRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBlZmYgPSBuZXcgUG9pbnRFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgZWZmID0gbmV3IENoZWNrYm94RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgZWZmID0gbmV3IExheWVySW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBlZmYgPSBuZXcgTWFza0luZGV4RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBlZmYgPSBuZXcgRWZmZWN0c01hbmFnZXIoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGNhc2UgNjpcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVmZiA9IG5ldyBOb1ZhbHVlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmKSB7XG4gICAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmYpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBCYXNlRWxlbWVudCgpIHt9XG5cbiAgQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGNoZWNrTWFza3M6IGZ1bmN0aW9uIGNoZWNrTWFza3MoKSB7XG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicgJiYgdGhpcy5kYXRhLm1hc2tzUHJvcGVydGllc1tpXS5jbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaW5pdEV4cHJlc3Npb25zOiBmdW5jdGlvbiBpbml0RXhwcmVzc2lvbnMoKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKTtcblxuICAgICAgaWYgKCFleHByZXNzaW9uc0ludGVyZmFjZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdsYXllcicpO1xuICAgICAgdmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdlZmZlY3RzJyk7XG4gICAgICB2YXIgU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdzaGFwZScpO1xuICAgICAgdmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCd0ZXh0Jyk7XG4gICAgICB2YXIgQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2NvbXAnKTtcbiAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UgPSBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzayAmJiB0aGlzLm1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJNYXNrSW50ZXJmYWNlKHRoaXMubWFza01hbmFnZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWZmZWN0c0ludGVyZmFjZSA9IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLmNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UodGhpcywgdGhpcy5sYXllckludGVyZmFjZSk7XG4gICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzSW50ZXJmYWNlKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCB8fCB0aGlzLmRhdGEueHQpIHtcbiAgICAgICAgdGhpcy5jb21wSW50ZXJmYWNlID0gQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNCkge1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlID0gU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLmNvbnRlbnQgPSB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHkgPT09IDUpIHtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlID0gVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dCA9IHRoaXMubGF5ZXJJbnRlcmZhY2UudGV4dEludGVyZmFjZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24gc2V0QmxlbmRNb2RlKCkge1xuICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICBlbGVtLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gYmxlbmRNb2RlVmFsdWU7XG4gICAgfSxcbiAgICBpbml0QmFzZURhdGE6IGZ1bmN0aW9uIGluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgICB0aGlzLmdsb2JhbERhdGEgPSBnbG9iYWxEYXRhO1xuICAgICAgdGhpcy5jb21wID0gY29tcDtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICB0aGlzLmxheWVySWQgPSBjcmVhdGVFbGVtZW50SUQoKTsgLy8gU3RyZXRjaCBmYWN0b3IgZm9yIG9sZCBhbmltYXRpb25zIG1pc3NpbmcgdGhpcyBwcm9wZXJ0eS5cblxuICAgICAgaWYgKCF0aGlzLmRhdGEuc3IpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyID0gMTtcbiAgICAgIH0gLy8gZWZmZWN0cyBtYW5hZ2VyXG5cblxuICAgICAgdGhpcy5lZmZlY3RzTWFuYWdlciA9IG5ldyBFZmZlY3RzTWFuYWdlcih0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge31cbiAgfTtcblxuICAvKipcclxuICAgKiBAZmlsZVxyXG4gICAqIEhhbmRsZXMgZWxlbWVudCdzIGxheWVyIGZyYW1lIHVwZGF0ZS5cclxuICAgKiBDaGVja3MgbGF5ZXIgaW4gcG9pbnQgYW5kIG91dCBwb2ludFxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEZyYW1lRWxlbWVudCgpIHt9XG5cbiAgRnJhbWVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIEluaXRpYWxpemVzIGZyYW1lIHJlbGF0ZWQgcHJvcGVydGllcy5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEZyYW1lOiBmdW5jdGlvbiBpbml0RnJhbWUoKSB7XG4gICAgICAvLyBzZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcbiAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlOyAvLyBsaXN0IG9mIGFuaW1hdGVkIHByb3BlcnRpZXNcblxuICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdOyAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcblxuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogQ2FsY3VsYXRlcyBhbGwgZHluYW1pYyB2YWx1ZXNcclxuICAgICAgICpcclxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICAgKiBjdXJyZW50IGZyYW1lIG51bWJlciBpbiBMYXllcidzIHRpbWVcclxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpc1Zpc2libGVcclxuICAgICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBwcmVwYXJlUHJvcGVydGllczogZnVuY3Rpb24gcHJlcGFyZVByb3BlcnRpZXMobnVtLCBpc1Zpc2libGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCB0aGlzLl9pc1BhcmVudCAmJiB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLnByb3BUeXBlID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcblxuICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEZvb3RhZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmFibGUoKTtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuZm9vdGFnZURhdGEgPSBnbG9iYWxEYXRhLmltYWdlTG9hZGVyLmdldEFzc2V0KHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgRm9vdGFnZUVsZW1lbnQpO1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4cHJlc3Npb25zSW50ZXJmYWNlcyA9IGdldEV4cHJlc3Npb25JbnRlcmZhY2VzKCk7XG5cbiAgICBpZiAoIWV4cHJlc3Npb25zSW50ZXJmYWNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBGb290YWdlSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdmb290YWdlJyk7XG4gICAgdGhpcy5sYXllckludGVyZmFjZSA9IEZvb3RhZ2VJbnRlcmZhY2UodGhpcyk7XG4gIH07XG5cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLmdldEZvb3RhZ2VEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmZvb3RhZ2VEYXRhO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEF1ZGlvRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmF1ZGlvID0gdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlci5jcmVhdGVBdWRpbyhhc3NldFBhdGgpO1xuICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICB0aGlzLmdsb2JhbERhdGEuYXVkaW9Db250cm9sbGVyLmFkZEF1ZGlvKHRoaXMpO1xuICAgIHRoaXMuX3ZvbHVtZU11bHRpcGxpZXIgPSAxO1xuICAgIHRoaXMuX3ZvbHVtZSA9IDE7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSBudWxsO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLmx2ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5hdSAmJiBkYXRhLmF1Lmx2ID8gZGF0YS5hdS5sdiA6IHtcbiAgICAgIGs6IFsxMDBdXG4gICAgfSwgMSwgMC4wMSwgdGhpcyk7XG4gIH1cblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtLCB0cnVlKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG5cbiAgICBpZiAoIXRoaXMudG0uX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgdGltZVJlbWFwcGVkID0gdGhpcy50bS52O1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cblxuICAgIHRoaXMuX3ZvbHVtZSA9IHRoaXMubHYudlswXTtcbiAgICB2YXIgdG90YWxWb2x1bWUgPSB0aGlzLl92b2x1bWUgKiB0aGlzLl92b2x1bWVNdWx0aXBsaWVyO1xuXG4gICAgaWYgKHRoaXMuX3ByZXZpb3VzVm9sdW1lICE9PSB0b3RhbFZvbHVtZSkge1xuICAgICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB0b3RhbFZvbHVtZTtcbiAgICAgIHRoaXMuYXVkaW8udm9sdW1lKHRvdGFsVm9sdW1lKTtcbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEF1ZGlvRWxlbWVudCk7XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0luUmFuZ2UgJiYgdGhpcy5fY2FuUGxheSkge1xuICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcbiAgICAgICAgdGhpcy5hdWRpby5wbGF5KCk7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5hdWRpby5wbGF5aW5nKCkgfHwgTWF0aC5hYnModGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlIC0gdGhpcy5hdWRpby5zZWVrKCkpID4gMC4xKSB7XG4gICAgICAgIHRoaXMuYXVkaW8uc2Vlayh0aGlzLl9jdXJyZW50VGltZSAvIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7Ly8gdGhpcy5hdWRpby5wbGF5KClcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICB9O1xuXG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NhblBsYXkgPSBmYWxzZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYW5QbGF5ID0gdHJ1ZTtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNldFJhdGUgPSBmdW5jdGlvbiAocmF0ZVZhbHVlKSB7XG4gICAgdGhpcy5hdWRpby5yYXRlKHJhdGVWYWx1ZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAodm9sdW1lVmFsdWUpIHtcbiAgICB0aGlzLl92b2x1bWVNdWx0aXBsaWVyID0gdm9sdW1lVmFsdWU7XG4gICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB2b2x1bWVWYWx1ZSAqIHRoaXMuX3ZvbHVtZTtcbiAgICB0aGlzLmF1ZGlvLnZvbHVtZSh0aGlzLl9wcmV2aW91c1ZvbHVtZSk7XG4gIH07XG5cbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIEJhc2VSZW5kZXJlcigpIHt9XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jaGVja0xheWVycyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIHZhciBkYXRhO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0cnVlO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICBkYXRhID0gdGhpcy5sYXllcnNbaV07XG5cbiAgICAgICAgaWYgKGRhdGEuaXAgLSBkYXRhLnN0IDw9IG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0ICYmIGRhdGEub3AgLSBkYXRhLnN0ID4gbnVtIC0gdGhpcy5sYXllcnNbaV0uc3QpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdGhpcy5lbGVtZW50c1tpXSA/IHRoaXMuY29tcGxldGVMYXllcnMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNoZWNrUGVuZGluZ0VsZW1lbnRzKCk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJdGVtID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgc3dpdGNoIChsYXllci50eSkge1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZShsYXllcik7XG5cbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tcChsYXllcik7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU29saWQobGF5ZXIpO1xuXG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXBlKGxheWVyKTtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUZXh0KGxheWVyKTtcblxuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBdWRpbyhsYXllcik7XG5cbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbWVyYShsYXllcik7XG5cbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZvb3RhZ2UobGF5ZXIpO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOdWxsKGxheWVyKTtcbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQXVkaW8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQXVkaW9FbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVGb290YWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEZvb3RhZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmluY2x1ZGVMYXllcnMgPSBmdW5jdGlvbiAobmV3TGF5ZXJzKSB7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBqID0gMDtcblxuICAgICAgd2hpbGUgKGogPCBqTGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmxheWVyc1tqXS5pZCA9PT0gbmV3TGF5ZXJzW2ldLmlkKSB7XG4gICAgICAgICAgdGhpcy5sYXllcnNbal0gPSBuZXdMYXllcnNbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBqICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvamVjdEludGVyZmFjZSA9IGZ1bmN0aW9uIChwSW50ZXJmYWNlKSB7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UgPSBwSW50ZXJmYWNlO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCkge1xuICAgICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XG4gICAgfVxuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5hbWUsIGhpZXJhcmNoeSkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAobGF5ZXJzW2ldLmluZCA9PSBwYXJlbnROYW1lKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIGlmICghZWxlbWVudHNbaV0gfHwgZWxlbWVudHNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICBlbGVtZW50c1tpXS5zZXRBc1BhcmVudCgpO1xuXG4gICAgICAgICAgaWYgKGxheWVyc1tpXS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEVsZW1lbnRQYXJlbnRpbmcoZWxlbWVudCwgbGF5ZXJzW2ldLnBhcmVudCwgaGllcmFyY2h5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRIaWVyYXJjaHkoaGllcmFyY2h5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFBlbmRpbmdFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2VhcmNoRXh0cmFDb21wb3NpdGlvbnMgPSBmdW5jdGlvbiAoYXNzZXRzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldKTtcbiAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRFbGVtZW50QnlQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgcGF0aFZhbHVlID0gcGF0aC5zaGlmdCgpO1xuICAgIHZhciBlbGVtZW50O1xuXG4gICAgaWYgKHR5cGVvZiBwYXRoVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1twYXRoVmFsdWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEubm0gPT09IHBhdGhWYWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudC5nZXRFbGVtZW50QnlQYXRoKHBhdGgpO1xuICB9O1xuXG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24gKGFuaW1EYXRhLCBmb250c0NvbnRhaW5lcikge1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcigpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5zbG90TWFuYWdlciA9IHNsb3RGYWN0b3J5KGFuaW1EYXRhKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoYW5pbURhdGEuY2hhcnMpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhhbmltRGF0YS5mb250cywgZm9udHNDb250YWluZXIpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldHNQYXRoLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuaW1hZ2VMb2FkZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uaW1hZ2VQcmVsb2FkZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5hdWRpb0NvbnRyb2xsZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgPSBhbmltRGF0YS5mcjtcbiAgICB0aGlzLmdsb2JhbERhdGEubm0gPSBhbmltRGF0YS5ubTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XG4gICAgICB3OiBhbmltRGF0YS53LFxuICAgICAgaDogYW5pbURhdGEuaFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGVmZmVjdFR5cGVzID0ge1xuICAgIFRSQU5TRk9STV9FRkZFQ1Q6ICd0cmFuc2Zvcm1FRmZlY3QnXG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWxlbWVudCgpIHt9XG5cbiAgVHJhbnNmb3JtRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFRyYW5zZm9ybTogZnVuY3Rpb24gaW5pdFRyYW5zZm9ybSgpIHtcbiAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xuICAgICAgICBtUHJvcDogdGhpcy5kYXRhLmtzID8gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIHRoaXMuZGF0YS5rcywgdGhpcykgOiB7XG4gICAgICAgICAgbzogMFxuICAgICAgICB9LFxuICAgICAgICBfbWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX2xvY2FsTWF0TWRmOiBmYWxzZSxcbiAgICAgICAgX29wTWRmOiBmYWxzZSxcbiAgICAgICAgbWF0OiBtYXQsXG4gICAgICAgIGxvY2FsTWF0OiBtYXQsXG4gICAgICAgIGxvY2FsT3BhY2l0eTogMVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5hbykge1xuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmF1dG9PcmllbnRlZCA9IHRydWU7XG4gICAgICB9IC8vIFRPRE86IGNoZWNrIFRZUEUgMTE6IEd1aWRlZCBlbGVtZW50c1xuXG5cbiAgICAgIGlmICh0aGlzLmRhdGEudHkgIT09IDExKSB7Ly8gdGhpcy5jcmVhdGVFbGVtZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJUcmFuc2Zvcm0oKSB7XG4gICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICB2YXIgbWF0O1xuICAgICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyAvLyBDaGVja2luZyBpZiBhbnkgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGluIHRoZSBoaWVyYXJjaHkgY2hhaW4gaGFzIGNoYW5nZWQuXG5cbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLl9tZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgICAgbWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xuICAgICAgICAgIGZpbmFsTWF0LmNsb25lRnJvbVByb3BzKG1hdCk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZpbmFsTWF0Lm11bHRpcGx5KHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckxvY2FsVHJhbnNmb3JtOiBmdW5jdGlvbiByZW5kZXJMb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtcykge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmxvY2FsVHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuXG4gICAgICAgIGlmICghdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgfHwgIXRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxvY2FsVHJhbnNmb3Jtc1tpXS5fbWRmKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9vcE1kZiAmJiAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgICAgdmFyIGxvY2FsTWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdDtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3Jtc1swXS5tYXRyaXguY2xvbmUobG9jYWxNYXQpO1xuXG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbG1hdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLm1hdHJpeDtcbiAgICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KGxtYXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICAgIHZhciBsb2NhbE9wID0gdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxvY2FsT3AgKj0gdGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0ub3BhY2l0eSAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSBsb2NhbE9wO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zOiBmdW5jdGlvbiBzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCkge1xuICAgICAgaWYgKHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtRWZmZWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3JtcyA9IFtdO1xuICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1FZmZlY3RzLmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm1FZmZlY3RzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwocHQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG4gICAgICB0cmFuc2Zvcm1zLnB1c2godGhpcy5maW5hbFRyYW5zZm9ybSk7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcblxuICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgaWYgKGNvbXAuZmluYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBpZiAoY29tcC5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybXMuc3BsaWNlKDAsIDAsIGNvbXAuZmluYWxUcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbXAgPSBjb21wLmNvbXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIHB0TmV3O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheSgwLCAwLCAwKTsgLy8gcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheShwdFswXSxwdFsxXSxwdFsyXSk7XG5cbiAgICAgICAgcHQgPSBbcHRbMF0gLSBwdE5ld1swXSwgcHRbMV0gLSBwdE5ld1sxXSwgMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwdDtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQsIGdsb2JhbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcbiAgICB0aGlzLnN0b3JlZERhdGEgPSBbXTtcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMgPyB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGggOiAwO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgdGhpcy5zb2xpZFBhdGggPSAnJztcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMubWFza3NQcm9wZXJ0aWVzO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRNYXNrcyA9IFtdO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBsYXllcklkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIHJlY3Q7XG4gICAgdmFyIGV4cGFuc29yO1xuICAgIHZhciBmZU1vcnBoO1xuICAgIHZhciB4O1xuICAgIHZhciBtYXNrVHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgdmFyIG1hc2tSZWYgPSAnY2xpcC1wYXRoJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ2EnICYmIHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nIHx8IHByb3BlcnRpZXNbaV0uaW52IHx8IHByb3BlcnRpZXNbaV0uby5rICE9PSAxMDAgfHwgcHJvcGVydGllc1tpXS5vLngpIHtcbiAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgIG1hc2tSZWYgPSAnbWFzayc7XG4gICAgICB9XG5cbiAgICAgIGlmICgocHJvcGVydGllc1tpXS5tb2RlID09PSAncycgfHwgcHJvcGVydGllc1tpXS5tb2RlID09PSAnaScpICYmIGNvdW50ID09PSAwKSB7XG4gICAgICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEudyB8fCAwKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEuaCB8fCAwKTtcbiAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWN0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG5cbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICduJykge1xuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xuICAgICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ubywgMCwgMC4wMSwgdGhpcy5lbGVtZW50KSxcbiAgICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLCAzKSxcbiAgICAgICAgICBlbGVtOiBwYXRoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJ1xuICAgICAgICB9O1xuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdjbGlwLXJ1bGUnLCAnbm9uemVybycpO1xuICAgICAgICB2YXIgZmlsdGVySUQ7XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ueC5rICE9PSAwKSB7XG4gICAgICAgICAgbWFza1R5cGUgPSAnbWFzayc7XG4gICAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcbiAgICAgICAgICB4ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLngsIDAsIG51bGwsIHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgZmlsdGVySUQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBleHBhbnNvciA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgICAgICBleHBhbnNvci5zZXRBdHRyaWJ1dGUoJ2lkJywgZmlsdGVySUQpO1xuICAgICAgICAgIGZlTW9ycGggPSBjcmVhdGVOUygnZmVNb3JwaG9sb2d5Jyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywgJ2Vyb2RlJyk7XG4gICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgncmFkaXVzJywgJzAnKTtcbiAgICAgICAgICBleHBhbnNvci5hcHBlbmRDaGlsZChmZU1vcnBoKTtcbiAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGV4cGFuc29yKTtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcHJvcGVydGllc1tpXS5tb2RlID09PSAncycgPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZlTW9ycGggPSBudWxsO1xuICAgICAgICAgIHggPSBudWxsO1xuICAgICAgICB9IC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXG5cblxuICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIGV4cGFuOiBmZU1vcnBoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJyxcbiAgICAgICAgICBsYXN0T3BlcmF0b3I6ICcnLFxuICAgICAgICAgIGZpbHRlcklkOiBmaWx0ZXJJRCxcbiAgICAgICAgICBsYXN0UmFkaXVzOiAwXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ2knKSB7XG4gICAgICAgICAgakxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG4gICAgICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChjdXJyZW50TWFza3Nbal0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XG4gICAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCArICdfJyArIGNvdW50KTtcbiAgICAgICAgICBtYXNrLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnXycgKyBjb3VudCArICcpJyk7XG4gICAgICAgICAgY3VycmVudE1hc2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2goZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcGVydGllc1tpXS5pbnYgJiYgIXRoaXMuc29saWRQYXRoKSB7XG4gICAgICAgICAgdGhpcy5zb2xpZFBhdGggPSB0aGlzLmNyZWF0ZUxheWVyU29saWRQYXRoKCk7XG4gICAgICAgIH0gLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcblxuXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICBsYXN0UGF0aDogJycsXG4gICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS5vLCAwLCAwLjAxLCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgIHByb3A6IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0sIDMpLFxuICAgICAgICAgIGludlJlY3Q6IHJlY3RcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIXRoaXMudmlld0RhdGFbaV0ucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5kcmF3UGF0aChwcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gY3JlYXRlTlMobWFza1R5cGUpO1xuICAgIGxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMubWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICB0aGlzLm1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBsYXllcklkKTtcbiAgICAgIHRoaXMuZWxlbWVudC5tYXNrZWRFbGVtZW50LnNldEF0dHJpYnV0ZShtYXNrUmVmLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnKScpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZCh0aGlzLm1hc2tFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52aWV3RGF0YS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0RhdGFbcG9zXS5wcm9wO1xuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChpc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubWF0O1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLnByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5kcmF3UGF0aCh0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsIHRoaXMudmlld0RhdGFbaV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLnZpZXdEYXRhW2ldLm9wLnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdEYXRhW2ldLmludlJlY3QgJiYgKHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmludlJlY3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBmaW5hbE1hdC5nZXRJbnZlcnNlTWF0cml4KCkudG8yZENTUygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ueCAmJiAodGhpcy5zdG9yZWREYXRhW2ldLnguX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgdmFyIGZlTW9ycGggPSB0aGlzLnN0b3JlZERhdGFbaV0uZXhwYW47XG5cbiAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZXJvZGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZXJvZGUnO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgdGhpcy5zdG9yZWREYXRhW2ldLmZpbHRlcklkICsgJyknKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsIC10aGlzLnN0b3JlZERhdGFbaV0ueC52KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdkaWxhdGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZGlsYXRlJztcbiAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWx0ZXInLCBudWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0b3JlZERhdGFbaV0ueC52ICogMik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrRWxlbWVudDtcbiAgfTtcblxuICBNYXNrRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlTGF5ZXJTb2xpZFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhdGggPSAnTTAsMCAnO1xuICAgIHBhdGggKz0gJyBoJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgIHBhdGggKz0gJyB2JyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHBhdGggKz0gJyBoLScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICBwYXRoICs9ICcgdi0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAnICc7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG5cbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBwYXRoTm9kZXMsIHZpZXdEYXRhKSB7XG4gICAgdmFyIHBhdGhTdHJpbmcgPSAnIE0nICsgcGF0aE5vZGVzLnZbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMudlswXVsxXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIGxlbiA9IHBhdGhOb2Rlcy5fbGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVtpXVsxXSArICcgJyArIHBhdGhOb2Rlcy52W2ldWzBdICsgJywnICsgcGF0aE5vZGVzLnZbaV1bMV07XG4gICAgfSAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbMF1bMF0rJywnK3BhdGhOb2Rlcy5pWzBdWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbMF1bMF0rJywnK3BhdGhOb2Rlcy52WzBdWzFdO1xuXG5cbiAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuID4gMSkge1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbMF1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVswXVsxXSArICcgJyArIHBhdGhOb2Rlcy52WzBdWzBdICsgJywnICsgcGF0aE5vZGVzLnZbMF1bMV07XG4gICAgfSAvLyBwYXRoTm9kZXMuX19yZW5kZXJlZFN0cmluZyA9IHBhdGhTdHJpbmc7XG5cblxuICAgIGlmICh2aWV3RGF0YS5sYXN0UGF0aCAhPT0gcGF0aFN0cmluZykge1xuICAgICAgdmFyIHBhdGhTaGFwZVZhbHVlID0gJyc7XG5cbiAgICAgIGlmICh2aWV3RGF0YS5lbGVtKSB7XG4gICAgICAgIGlmIChwYXRoTm9kZXMuYykge1xuICAgICAgICAgIHBhdGhTaGFwZVZhbHVlID0gcGF0aERhdGEuaW52ID8gdGhpcy5zb2xpZFBhdGggKyBwYXRoU3RyaW5nIDogcGF0aFN0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZpZXdEYXRhLmVsZW0uc2V0QXR0cmlidXRlKCdkJywgcGF0aFNoYXBlVmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB2aWV3RGF0YS5sYXN0UGF0aCA9IHBhdGhTdHJpbmc7XG4gICAgfVxuICB9O1xuXG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcbiAgICB0aGlzLm1hc2tFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xuICAgIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gbnVsbDtcbiAgfTtcblxuICB2YXIgZmlsdGVyc0ZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuY3JlYXRlRmlsdGVyID0gY3JlYXRlRmlsdGVyO1xuICAgIG9iLmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIgPSBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbElkLCBza2lwQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBmaWwgPSBjcmVhdGVOUygnZmlsdGVyJyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGZpbElkKTtcblxuICAgICAgaWYgKHNraXBDb29yZGluYXRlcyAhPT0gdHJ1ZSkge1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdmaWx0ZXJVbml0cycsICdvYmplY3RCb3VuZGluZ0JveCcpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd4JywgJzAlJyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3knLCAnMCUnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTAwJScpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMTAwJScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmlsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSB7XG4gICAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcbiAgICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBmZWF0dXJlU3VwcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBtYXNrVHlwZTogdHJ1ZSxcbiAgICAgIHN2Z0x1bWFIaWRkZW46IHRydWUsXG4gICAgICBvZmZzY3JlZW5DYW52YXM6IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnXG4gICAgfTtcblxuICAgIGlmICgvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL3J2OjExLjAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9FZGdlXFwvXFxkLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgIG9iLm1hc2tUeXBlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2Iuc3ZnTHVtYUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciByZWdpc3RlcmVkRWZmZWN0cyQxID0ge307XG4gIHZhciBpZFByZWZpeCA9ICdmaWx0ZXJfcmVzdWx0Xyc7XG5cbiAgZnVuY3Rpb24gU1ZHRWZmZWN0cyhlbGVtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHNvdXJjZSA9ICdTb3VyY2VHcmFwaGljJztcbiAgICB2YXIgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XG4gICAgdmFyIGZpbElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCwgdHJ1ZSk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0pIHtcbiAgICAgICAgdmFyIEVmZmVjdCA9IHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uZWZmZWN0O1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IEVmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0sIGlkUHJlZml4ICsgY291bnQsIHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IGlkUHJlZml4ICsgY291bnQ7XG5cbiAgICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzJDFbdHlwZV0uY291bnRzQXNFZmZlY3QpIHtcbiAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcbiAgICAgIGVsZW0ubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBmaWxJZCArICcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgIGVsZW0uYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0JDEoaWQsIGVmZmVjdCwgY291bnRzQXNFZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0cyQxW2lkXSA9IHtcbiAgICAgIGVmZmVjdDogZWZmZWN0LFxuICAgICAgY291bnRzQXNFZmZlY3Q6IGNvdW50c0FzRWZmZWN0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNWR0Jhc2VFbGVtZW50KCkge31cblxuICBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDsgLy8gSWYgdGhpcyBsYXllciBhY3RzIGFzIGEgbWFzayBmb3IgdGhlIGZvbGxvd2luZyBsYXllclxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgICB2YXIgZ2cgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5sYXllcklkKTtcbiAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBnZztcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEudHQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSB0aGlzLm1hdHRlRWxlbWVudDtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmxuKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmNsKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmRhdGEuY2wpO1xuICAgICAgfSAvLyBDbGlwcGluZyBjb21wb3NpdGlvbnMgdG8gaGlkZSBjb250ZW50IHRoYXQgZXhjZWVkcyBib3VuZGFyaWVzLiBJZiBjb2xsYXBzZWQgdHJhbnNmb3JtYXRpb25zIGlzIG9uLCBjb21wb25lbnQgc2hvdWxkIG5vdCBiZSBjbGlwcGVkXG5cblxuICAgICAgaWYgKHRoaXMuZGF0YS50eSA9PT0gMCAmJiAhdGhpcy5kYXRhLmhkKSB7XG4gICAgICAgIHZhciBjcCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgICAgICB2YXIgcHQgPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgICBwdC5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAsMCBMJyArIHRoaXMuZGF0YS53ICsgJywwIEwnICsgdGhpcy5kYXRhLncgKyAnLCcgKyB0aGlzLmRhdGEuaCArICcgTDAsJyArIHRoaXMuZGF0YS5oICsgJ3onKTtcbiAgICAgICAgdmFyIGNsaXBJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICBjcC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcElkKTtcbiAgICAgICAgY3AuYXBwZW5kQ2hpbGQocHQpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChjcCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2hlY2tNYXNrcygpKSB7XG4gICAgICAgICAgdmFyIGNwR3JvdXAgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIGNwR3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGNsaXBJZCArICcpJyk7XG4gICAgICAgICAgY3BHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBjcEdyb3VwO1xuXG4gICAgICAgICAgaWYgKGxheWVyRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudHJhbnNmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiByZW5kZXJFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdC50bzJkQ1NTKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveUJhc2VFbGVtZW50OiBmdW5jdGlvbiBkZXN0cm95QmFzZUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIGdldEJhc2VFbGVtZW50OiBmdW5jdGlvbiBnZXRCYXNlRWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBTVkdFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy5zZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCk7XG4gICAgfSxcbiAgICBnZXRNYXR0ZTogZnVuY3Rpb24gZ2V0TWF0dGUobWF0dGVUeXBlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgYSBjb21tb24gY2FzZS4gQnV0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSdsbCBjcmVhdGUgdGhlIG1hdHRlIG9iamVjdC5cbiAgICAgIC8vIEl0IHNvbHZlcyBhbmltYXRpb25zIHRoYXQgaGF2ZSB0d28gY29uc2VjdXRpdmUgbGF5ZXJzIG1hcmtlZCBhcyBtYXR0ZSBtYXNrcy5cbiAgICAgIC8vIFdoaWNoIGlzIGFuIHVuZGVmaW5lZCBiZWhhdmlvciBpbiBBRS5cbiAgICAgIGlmICghdGhpcy5tYXR0ZU1hc2tzKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMubWF0dGVNYXNrc1ttYXR0ZVR5cGVdKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMubGF5ZXJJZCArICdfJyArIG1hdHRlVHlwZTtcbiAgICAgICAgdmFyIGZpbElkO1xuICAgICAgICB2YXIgZmlsO1xuICAgICAgICB2YXIgdXNlRWxlbWVudDtcbiAgICAgICAgdmFyIGdnO1xuXG4gICAgICAgIGlmIChtYXR0ZVR5cGUgPT09IDEgfHwgbWF0dGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgbWF0dGVUeXBlID09PSAzID8gJ2x1bWluYW5jZScgOiAnYWxwaGEnKTtcbiAgICAgICAgICB1c2VFbGVtZW50ID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsICcjJyArIHRoaXMubGF5ZXJJZCk7XG4gICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XG5cbiAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIG1hdHRlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh1c2VFbGVtZW50KTtcbiAgICAgICAgICAgIG1hc2tlci5hcHBlbmRDaGlsZChnZyk7XG4gICAgICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXR0ZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwZXIgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XG4gICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpOyAvLy8gL1xuXG4gICAgICAgICAgdmFyIGZlQ1RyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICAgICAgICBmZUNUci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDVHIpO1xuICAgICAgICAgIHZhciBmZUZ1bmMgPSBjcmVhdGVOUygnZmVGdW5jQScpO1xuICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsICcxLjAgMC4wJyk7XG4gICAgICAgICAgZmVDVHIuYXBwZW5kQ2hpbGQoZmVGdW5jKTsgLy8vIC9cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICAgICAgdmFyIGFscGhhUmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXAuZGF0YS53KTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXAuZGF0YS5oKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd4JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICBtYXNrR3JvdXBlci5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XG4gICAgICAgICAgdXNlRWxlbWVudCA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICAgICAgICB1c2VFbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCAnIycgKyB0aGlzLmxheWVySWQpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSkge1xuICAgICAgICAgICAgbWFza0dyb3VwLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBtYXNrR3JvdXBlci5hcHBlbmRDaGlsZChhbHBoYVJlY3QpO1xuICAgICAgICAgICAgZ2cuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoZ2cpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tHcm91cCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXSA9IGlkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5tYXR0ZU1hc2tzW21hdHRlVHlwZV07XG4gICAgfSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoaWQpIHtcbiAgICAgIGlmICghdGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdHRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGlkICsgJyknKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXHJcbiAgICogQGZpbGVcclxuICAgKiBIYW5kbGVzIEFFJ3MgbGF5ZXIgcGFyZW50aW5nIHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoeUVsZW1lbnQoKSB7fVxuXG4gIEhpZXJhcmNoeUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogSW5pdGlhbGl6ZXMgaGllcmFyY2h5IHByb3BlcnRpZXNcclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgaW5pdEhpZXJhcmNoeTogZnVuY3Rpb24gaW5pdEhpZXJhcmNoeSgpIHtcbiAgICAgIC8vIGVsZW1lbnQncyBwYXJlbnQgbGlzdFxuICAgICAgdGhpcy5oaWVyYXJjaHkgPSBbXTsgLy8gaWYgZWxlbWVudCBpcyBwYXJlbnQgb2YgYW5vdGhlciBsYXllciBfaXNQYXJlbnQgd2lsbCBiZSB0cnVlXG5cbiAgICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cclxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGllcmFyY2hcclxuICAgICAgICogbGF5ZXIncyBwYXJlbnQgbGlzdFxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRIaWVyYXJjaHk6IGZ1bmN0aW9uIHNldEhpZXJhcmNoeShoaWVyYXJjaHkpIHtcbiAgICAgIHRoaXMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAgICogQGZ1bmN0aW9uXHJcbiAgICAgICAqIFNldHMgbGF5ZXIgYXMgcGFyZW50LlxyXG4gICAgICAgKlxyXG4gICAgICAgKi9cbiAgICBzZXRBc1BhcmVudDogZnVuY3Rpb24gc2V0QXNQYXJlbnQoKSB7XG4gICAgICB0aGlzLl9pc1BhcmVudCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICAgKiBAZnVuY3Rpb25cclxuICAgICAgICogU2VhcmNoZXMgbGF5ZXIncyBwYXJlbnRpbmcgY2hhaW5cclxuICAgICAgICpcclxuICAgICAgICovXG4gICAgY2hlY2tQYXJlbnRpbmc6IGZ1bmN0aW9uIGNoZWNrUGFyZW50aW5nKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNvbXAuYnVpbGRFbGVtZW50UGFyZW50aW5nKHRoaXMsIHRoaXMuZGF0YS5wYXJlbnQsIFtdKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gUmVuZGVyYWJsZURPTUVsZW1lbnQoKSB7fVxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcm90b3R5cGUgPSB7XG4gICAgICBpbml0RWxlbWVudDogZnVuY3Rpb24gaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgICAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgICAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICAgICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgICAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGVudCgpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnSElERScsIHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaGlkZGVuICYmICghdGhpcy5pc0luUmFuZ2UgfHwgdGhpcy5pc1RyYW5zcGFyZW50KSkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NIT1cnLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5oZCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoKSB7XG4gICAgICAgIC8vIElmIGl0IGlzIGV4cG9ydGVkIGFzIGhpZGRlbiAoZGF0YS5oZCA9PT0gdHJ1ZSkgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oZCB8fCB0aGlzLmhpZGRlbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMucmVuZGVyRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcklubmVyQ29udGVudDogZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KCkge30sXG4gICAgICBwcmVwYXJlRnJhbWU6IGZ1bmN0aW9uIHByZXBhcmVGcmFtZShudW0pIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgICAgICB0aGlzLmNoZWNrVHJhbnNwYXJlbmN5KCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbm5lckVsZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlUHJveHlGdW5jdGlvbihfcHJvdG90eXBlKV0sIFJlbmRlcmFibGVET01FbGVtZW50KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBJSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuXG4gICAgaWYgKHRoaXMuYXNzZXREYXRhICYmIHRoaXMuYXNzZXREYXRhLnNpZCkge1xuICAgICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLnNsb3RNYW5hZ2VyLmdldFByb3AodGhpcy5hc3NldERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5zb3VyY2VSZWN0ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiB0aGlzLmFzc2V0RGF0YS53LFxuICAgICAgaGVpZ2h0OiB0aGlzLmFzc2V0RGF0YS5oXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUltYWdlRWxlbWVudCk7XG5cbiAgSUltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHRoaXMuaW5uZXJFbGVtID0gY3JlYXRlTlMoJ2ltYWdlJyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICB0aGlzLmlubmVyRWxlbS5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbm5lckVsZW0pO1xuICB9O1xuXG4gIElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlUmVjdDtcbiAgfTtcblxuICBmdW5jdGlvbiBQcm9jZXNzZWRFbGVtZW50KGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbWVudDtcbiAgICB0aGlzLnBvcyA9IHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gSVNoYXBlRWxlbWVudCgpIHt9XG5cbiAgSVNoYXBlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgYWRkU2hhcGVUb01vZGlmaWVyczogZnVuY3Rpb24gYWRkU2hhcGVUb01vZGlmaWVycyhkYXRhKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnNbaV0uYWRkU2hhcGUoZGF0YSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1NoYXBlSW5BbmltYXRlZE1vZGlmaWVyczogZnVuY3Rpb24gaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnMoZGF0YSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5pc0FuaW1hdGVkV2l0aFNoYXBlKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVuZGVyTW9kaWZpZXJzOiBmdW5jdGlvbiByZW5kZXJNb2RpZmllcnMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2gucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XG4gICAgICB2YXIgc2hvdWxkQnJlYWtQcm9jZXNzO1xuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzaG91bGRCcmVha1Byb2Nlc3MgPSB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLnByb2Nlc3NTaGFwZXModGhpcy5faXNGaXJzdEZyYW1lKTsgLy8gd29ya2Fyb3VuZCB0byBmaXggY2FzZXMgd2hlcmUgYSByZXBlYXRlciByZXNldHMgdGhlIHNoYXBlIHNvIHRoZSBmb2xsb3dpbmcgcHJvY2Vzc2VzIGdldCBjYWxsZWQgdHdpY2VcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciBzb2x1dGlvbiBmb3IgdGhpc1xuXG4gICAgICAgIGlmIChzaG91bGRCcmVha1Byb2Nlc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChlbGVtKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGFkZFByb2Nlc3NlZEVsZW1lbnQ6IGZ1bmN0aW9uIGFkZFByb2Nlc3NlZEVsZW1lbnQoZWxlbSwgcG9zKSB7XG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xuICAgICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGkgLT0gMTtcblxuICAgICAgICBpZiAoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSkge1xuICAgICAgICAgIGVsZW1lbnRzW2ldLnBvcyA9IHBvcztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudHMucHVzaChuZXcgUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpKTtcbiAgICB9LFxuICAgIHByZXBhcmVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZUZyYW1lKG51bSkge1xuICAgICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGluZUNhcEVudW0gPSB7XG4gICAgMTogJ2J1dHQnLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ3NxdWFyZSdcbiAgfTtcbiAgdmFyIGxpbmVKb2luRW51bSA9IHtcbiAgICAxOiAnbWl0ZXInLFxuICAgIDI6ICdyb3VuZCcsXG4gICAgMzogJ2JldmVsJ1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1NoYXBlRGF0YSh0cmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZSkge1xuICAgIHRoaXMuY2FjaGVzID0gW107XG4gICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybWVycyA9IHRyYW5zZm9ybWVycztcbiAgICB0aGlzLmxTdHIgPSAnJztcbiAgICB0aGlzLnNoID0gc2hhcGU7XG4gICAgdGhpcy5sdmwgPSBsZXZlbDsgLy8gVE9ETyBmaW5kIGlmIHRoZXJlIGFyZSBzb21lIGNhc2VzIHdoZXJlIF9pc0FuaW1hdGVkIGNhbiBiZSBmYWxzZS5cbiAgICAvLyBGb3Igbm93LCBzaW5jZSBzaGFwZXMgYWRkIHVwIHdpdGggb3RoZXIgc2hhcGVzLiBUaGV5IGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBldmVyeSB0aW1lLlxuICAgIC8vIE9uZSB3YXkgb2YgZmluZGluZyBvdXQgaXMgY2hlY2tpbmcgaWYgYWxsIHN0eWxlcyBhc3NvY2lhdGVkIHRvIHRoaXMgc2hhcGUgZGVwZW5kIG9ubHkgb2YgdGhpcyBzaGFwZVxuXG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhc2hhcGUuazsgLy8gVE9ETzogY29tbWVudGluZyB0aGlzIGZvciBub3cgc2luY2UgYWxsIHNoYXBlcyBhcmUgYW5pbWF0ZWRcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdHJhbnNmb3JtZXJzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuICB9XG5cbiAgU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy50eXBlID0gZGF0YS50eTtcbiAgICB0aGlzLmQgPSAnJztcbiAgICB0aGlzLmx2bCA9IGxldmVsO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkID0gZGF0YS5oZCA9PT0gdHJ1ZTtcbiAgICB0aGlzLnBFbGVtID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICB0aGlzLm1zRWxlbSA9IG51bGw7XG4gIH1cblxuICBTVkdTdHlsZURhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICB0aGlzLmRhc2hBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xuICAgIHRoaXMuZGFzaG9mZnNldCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxKTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcHJvcDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgcHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGFbaV0udiwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLmsgPSBwcm9wLmsgfHwgdGhpcy5rO1xuICAgICAgdGhpcy5kYXRhUHJvcHNbaV0gPSB7XG4gICAgICAgIG46IGRhdGFbaV0ubixcbiAgICAgICAgcDogcHJvcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaykge1xuICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5rO1xuICB9XG5cbiAgRGFzaFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgIHRoaXMuX21kZiA9IHRoaXMuX21kZiB8fCBmb3JjZVJlbmRlcjtcblxuICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGFQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm9wc1tpXS5uICE9PSAnbycpIHtcbiAgICAgICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaFN0ciArPSAnICcgKyB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaEFycmF5W2ldID0gdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRhc2hvZmZzZXRbMF0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBEYXNoUHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHU3Ryb2tlU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAxLCAyNTUsIHRoaXMpO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdOb1N0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHTm9TdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmMgPSBjcmVhdGVUeXBlZEFycmF5KCd1aW50OGMnLCBkYXRhLnAgKiA0KTtcbiAgICB2YXIgY0xlbmd0aCA9IGRhdGEuay5rWzBdLnMgPyBkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCAqIDQgOiBkYXRhLmsuay5sZW5ndGggLSBkYXRhLnAgKiA0O1xuICAgIHRoaXMubyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBjTGVuZ3RoKTtcbiAgICB0aGlzLl9jbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fb21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NvbGxhcHNhYmxlID0gdGhpcy5jaGVja0NvbGxhcHNhYmxlKCk7XG4gICAgdGhpcy5faGFzT3BhY2l0eSA9IGNMZW5ndGg7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdGhpcy5wcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5rLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmsgPSB0aGlzLnByb3AuaztcbiAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICB9XG5cbiAgR3JhZGllbnRQcm9wZXJ0eS5wcm90b3R5cGUuY29tcGFyZVBvaW50cyA9IGZ1bmN0aW9uICh2YWx1ZXMsIHBvaW50cykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5vLmxlbmd0aCAvIDI7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgZGlmZiA9IE1hdGguYWJzKHZhbHVlc1tpICogNF0gLSB2YWx1ZXNbcG9pbnRzICogNCArIGkgKiAyXSk7XG5cbiAgICAgIGlmIChkaWZmID4gMC4wMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jaGVja0NvbGxhcHNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm8ubGVuZ3RoIC8gMiAhPT0gdGhpcy5jLmxlbmd0aCAvIDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmsua1swXS5zKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5kYXRhLmsuay5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wYXJlUG9pbnRzKHRoaXMuZGF0YS5rLmtbaV0ucywgdGhpcy5kYXRhLnApKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIHRoaXMucHJvcC5nZXRWYWx1ZSgpO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NtZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vbWRmID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5wcm9wLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5wICogNDtcbiAgICAgIHZhciBtdWx0O1xuICAgICAgdmFyIHZhbDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIG11bHQgPSBpICUgNCA9PT0gMCA/IDEwMCA6IDI1NTtcbiAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh0aGlzLnByb3AudltpXSAqIG11bHQpO1xuXG4gICAgICAgIGlmICh0aGlzLmNbaV0gIT09IHZhbCkge1xuICAgICAgICAgIHRoaXMuY1tpXSA9IHZhbDtcbiAgICAgICAgICB0aGlzLl9jbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm8ubGVuZ3RoKSB7XG4gICAgICAgIGxlbiA9IHRoaXMucHJvcC52Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSB0aGlzLmRhdGEucCAqIDQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIG11bHQgPSBpICUgMiA9PT0gMCA/IDEwMCA6IDE7XG4gICAgICAgICAgdmFsID0gaSAlIDIgPT09IDAgPyBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldICogMTAwKSA6IHRoaXMucHJvcC52W2ldO1xuXG4gICAgICAgICAgaWYgKHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSAhPT0gdmFsKSB7XG4gICAgICAgICAgICB0aGlzLm9baSAtIHRoaXMuZGF0YS5wICogNF0gPSB2YWw7XG4gICAgICAgICAgICB0aGlzLl9vbWRmID0gIWZvcmNlUmVuZGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JhZGllbnRQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMuaW5pdEdyYWRpZW50RGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKTtcbiAgfVxuXG4gIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuaW5pdEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDEsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuZSwgMSwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5oID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5oIHx8IHtcbiAgICAgIGs6IDBcbiAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgazogMFxuICAgIH0sIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5nID0gbmV3IEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YS5nLCB0aGlzKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgICB0aGlzLnN0b3BzID0gW107XG4gICAgdGhpcy5zZXRHcmFkaWVudERhdGEoc3R5bGVPYi5wRWxlbSwgZGF0YSk7XG4gICAgdGhpcy5zZXRHcmFkaWVudE9wYWNpdHkoZGF0YSwgc3R5bGVPYik7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoRWxlbWVudCwgZGF0YSkge1xuICAgIHZhciBncmFkaWVudElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGdmaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkaWVudElkKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgc3RvcDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICBqTGVuID0gZGF0YS5nLnAgKiA0O1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gNCkge1xuICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XG4gICAgICBnZmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgIHN0b3BzLnB1c2goc3RvcCk7XG4gICAgfVxuXG4gICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBncmFkaWVudElkICsgJyknKTtcbiAgICB0aGlzLmdmID0gZ2ZpbGw7XG4gICAgdGhpcy5jc3QgPSBzdG9wcztcbiAgfTtcblxuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChkYXRhLCBzdHlsZU9iKSB7XG4gICAgaWYgKHRoaXMuZy5faGFzT3BhY2l0eSAmJiAhdGhpcy5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgdmFyIHN0b3A7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgICAgdmFyIG9wYWNpdHlJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICAgIHZhciBvcEZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdpZCcsIG9wYWNpdHlJZCk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICBqTGVuID0gZGF0YS5nLmsua1swXS5zID8gZGF0YS5nLmsua1swXS5zLmxlbmd0aCA6IGRhdGEuZy5rLmsubGVuZ3RoO1xuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcztcblxuICAgICAgZm9yIChqID0gZGF0YS5nLnAgKiA0OyBqIDwgakxlbjsgaiArPSAyKSB7XG4gICAgICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xuICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoMjU1LDI1NSwyNTUpJyk7XG4gICAgICAgIG9wRmlsbC5hcHBlbmRDaGlsZChzdG9wKTtcbiAgICAgICAgc3RvcHMucHVzaChzdG9wKTtcbiAgICAgIH1cblxuICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGEudHkgPT09ICdnZicgPyAnZmlsbCcgOiAnc3Ryb2tlJywgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBvcGFjaXR5SWQgKyAnKScpO1xuXG4gICAgICBpZiAoZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xuXG4gICAgICAgIGlmIChkYXRhLmxqID09PSAxKSB7XG4gICAgICAgICAgbWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2YgPSBvcEZpbGw7XG4gICAgICB0aGlzLm1zID0gbWFzaztcbiAgICAgIHRoaXMub3N0ID0gc3RvcHM7XG4gICAgICB0aGlzLm1hc2tJZCA9IG1hc2tJZDtcbiAgICAgIHN0eWxlT2IubXNFbGVtID0gbWFza0VsZW1lbnQ7XG4gICAgfVxuICB9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW1NWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlR3JvdXBEYXRhKCkge1xuICAgIHRoaXMuaXQgPSBbXTtcbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuZ3IgPSBjcmVhdGVOUygnZycpO1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRGF0YShtUHJvcHMsIG9wLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHtcbiAgICAgIG1Qcm9wczogbVByb3BzLFxuICAgICAgb3A6IG9wLFxuICAgICAgY29udGFpbmVyOiBjb250YWluZXJcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy50cmFuc2Zvcm0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCB8fCB0aGlzLnRyYW5zZm9ybS5vcC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICB9XG5cbiAgdmFyIGJ1aWxkU2hhcGVTdHJpbmcgPSBmdW5jdGlvbiBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgbGVuZ3RoLCBjbG9zZWQsIG1hdCkge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICB2YXIgX28gPSBwYXRoTm9kZXMubztcbiAgICB2YXIgX2kgPSBwYXRoTm9kZXMuaTtcbiAgICB2YXIgX3YgPSBwYXRoTm9kZXMudjtcbiAgICB2YXIgaTtcbiAgICB2YXIgc2hhcGVTdHJpbmcgPSAnIE0nICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF92WzBdWzBdLCBfdlswXVsxXSk7XG5cbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pW2ldWzBdLCBfaVtpXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoY2xvc2VkICYmIGxlbmd0aCkge1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJyBDJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX2lbMF1bMF0sIF9pWzBdWzFdKSArICcgJyArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xuICAgICAgc2hhcGVTdHJpbmcgKz0gJ3onO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cmluZztcbiAgfTtcblxuICB2YXIgU1ZHRWxlbWVudHNSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgdmFyIF9tYXRyaXhIZWxwZXIgPSBuZXcgTWF0cml4KCk7XG5cbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVSZW5kZXJGdW5jdGlvbjogY3JlYXRlUmVuZGVyRnVuY3Rpb25cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSkge1xuICAgICAgc3dpdGNoIChkYXRhLnR5KSB7XG4gICAgICAgIGNhc2UgJ2ZsJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyRmlsbDtcblxuICAgICAgICBjYXNlICdnZic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xuXG4gICAgICAgIGNhc2UgJ2dzJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyR3JhZGllbnRTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc3QnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJTdHJva2U7XG5cbiAgICAgICAgY2FzZSAnc2gnOlxuICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgIGNhc2UgJ3JjJzpcbiAgICAgICAgY2FzZSAnc3InOlxuICAgICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xuXG4gICAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyQ29udGVudFRyYW5zZm9ybTtcblxuICAgICAgICBjYXNlICdubyc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlck5vb3A7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJDb250ZW50VHJhbnNmb3JtKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ub3AuX21kZikge1xuICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5vcC52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ubVByb3BzLl9tZGYpIHtcbiAgICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMudi50bzJkQ1NTKCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbmRlck5vb3AoKSB7fVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyUGF0aChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBqO1xuICAgICAgdmFyIGpMZW47XG4gICAgICB2YXIgcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgdmFyIHJlZHJhdztcbiAgICAgIHZhciBwYXRoTm9kZXM7XG4gICAgICB2YXIgbDtcbiAgICAgIHZhciBsTGVuID0gaXRlbURhdGEuc3R5bGVzLmxlbmd0aDtcbiAgICAgIHZhciBsdmwgPSBpdGVtRGF0YS5sdmw7XG4gICAgICB2YXIgcGF0aHM7XG4gICAgICB2YXIgbWF0O1xuICAgICAgdmFyIGl0ZXJhdGlvbnM7XG4gICAgICB2YXIgaztcblxuICAgICAgZm9yIChsID0gMDsgbCA8IGxMZW47IGwgKz0gMSkge1xuICAgICAgICByZWRyYXcgPSBpdGVtRGF0YS5zaC5fbWRmIHx8IGlzRmlyc3RGcmFtZTtcblxuICAgICAgICBpZiAoaXRlbURhdGEuc3R5bGVzW2xdLmx2bCA8IGx2bCkge1xuICAgICAgICAgIG1hdCA9IF9tYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICBrID0gaXRlbURhdGEudHJhbnNmb3JtZXJzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB3aGlsZSAoIXJlZHJhdyAmJiBpdGVyYXRpb25zID4gMCkge1xuICAgICAgICAgICAgcmVkcmF3ID0gaXRlbURhdGEudHJhbnNmb3JtZXJzW2tdLm1Qcm9wcy5fbWRmIHx8IHJlZHJhdztcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgLT0gMTtcbiAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICAgIGsgPSBpdGVtRGF0YS50cmFuc2Zvcm1lcnMubGVuZ3RoIC0gMTtcblxuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIG1hdC5tdWx0aXBseShpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLnYpO1xuICAgICAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XG4gICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ID0gX2lkZW50aXR5TWF0cml4O1xuICAgICAgICB9XG5cbiAgICAgICAgcGF0aHMgPSBpdGVtRGF0YS5zaC5wYXRocztcbiAgICAgICAgakxlbiA9IHBhdGhzLl9sZW5ndGg7XG5cbiAgICAgICAgaWYgKHJlZHJhdykge1xuICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9ICcnO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuXG4gICAgICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy5fbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLl9sZW5ndGgsIHBhdGhOb2Rlcy5jLCBtYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGl0ZW1EYXRhLmNhY2hlc1tsXSA9IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSBpdGVtRGF0YS5jYWNoZXNbbF07XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uZCArPSBzdHlsZURhdGEuaGQgPT09IHRydWUgPyAnJyA6IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGYgPSByZWRyYXcgfHwgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyRmlsbChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcblxuICAgICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnRTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVuZGVyR3JhZGllbnQoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgZ2ZpbGwgPSBpdGVtRGF0YS5nZjtcbiAgICAgIHZhciBoYXNPcGFjaXR5ID0gaXRlbURhdGEuZy5faGFzT3BhY2l0eTtcbiAgICAgIHZhciBwdDEgPSBpdGVtRGF0YS5zLnY7XG4gICAgICB2YXIgcHQyID0gaXRlbURhdGEuZS52O1xuXG4gICAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB2YXIgYXR0ciA9IHN0eWxlRGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsLW9wYWNpdHknIDogJ3N0cm9rZS1vcGFjaXR5JztcbiAgICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHZhciBhdHRyMSA9IHN0eWxlRGF0YS50ID09PSAxID8gJ3gxJyA6ICdjeCc7XG4gICAgICAgIHZhciBhdHRyMiA9IGF0dHIxID09PSAneDEnID8gJ3kxJyA6ICdjeSc7XG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIyLCBwdDFbMV0pO1xuXG4gICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMSwgcHQxWzBdKTtcbiAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoYXR0cjIsIHB0MVsxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0b3BzO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHN0b3A7XG5cbiAgICAgIGlmIChpdGVtRGF0YS5nLl9jbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBpdGVtRGF0YS5nLmM7XG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNWYWx1ZXNbaSAqIDRdICsgJyUnKTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsICdyZ2IoJyArIGNWYWx1ZXNbaSAqIDQgKyAxXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAyXSArICcsJyArIGNWYWx1ZXNbaSAqIDQgKyAzXSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc09wYWNpdHkgJiYgKGl0ZW1EYXRhLmcuX29tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcblxuICAgICAgICBpZiAoaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLm9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbiA9IHN0b3BzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG5cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0Jywgb1ZhbHVlc1tpICogMl0gKyAnJScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknLCBvVmFsdWVzW2kgKiAyICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuXG4gICAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3gyJywgcHQyWzBdKTtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZDtcblxuICAgICAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG5cbiAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW1EYXRhLmUuX21kZiB8fCBpdGVtRGF0YS5oLl9tZGYgfHwgaXRlbURhdGEuYS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGlmICghcmFkKSB7XG4gICAgICAgICAgICByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcblxuICAgICAgICAgIGlmIChwZXJjZW50ID49IDEpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA8PSAtMSkge1xuICAgICAgICAgICAgcGVyY2VudCA9IC0wLjk5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcbiAgICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xuICAgICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcblxuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgICB2YXIgZCA9IGl0ZW1EYXRhLmQ7XG5cbiAgICAgIGlmIChkICYmIChkLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSAmJiBkLmRhc2hTdHIpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGQuZGFzaFN0cik7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZC5kYXNob2Zmc2V0WzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLmMgJiYgKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JywgaXRlbURhdGEuby52KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgaXRlbURhdGEudy52KTtcblxuICAgICAgICBpZiAoc3R5bGVFbGVtLm1zRWxlbSkge1xuICAgICAgICAgIHN0eWxlRWxlbS5tc0VsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU1ZHU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAvLyBMaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXG4gICAgdGhpcy5zaGFwZXMgPSBbXTsgLy8gRnVsbCBzaGFwZSBkYXRhXG5cbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlczsgLy8gTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTsgLy8gTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXG5cbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTsgLy8gTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXG5cbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107IC8vIExpc3Qgb2YgYW5pbWF0ZWQgY29tcG9uZW50c1xuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzID0gW107XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTsgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcblxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107IC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudF0sIFNWR1NoYXBlRWxlbWVudCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0U2Vjb25kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5idWlsZEV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgfTtcbiAgLypcclxuICBUaGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgbXVsdGlwbGUgc2hhcGVzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIGVsZW1lbnQgYW5kIG9uZSBvZiB0aGVtIGlzIGFuaW1hdGVkXHJcbiAgKi9cblxuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZmlsdGVyVW5pcXVlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIHNoYXBlO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHRlbXBTaGFwZXMgPSBbXTtcbiAgICB2YXIgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIHN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2pdO1xuICAgICAgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgIHRlbXBTaGFwZXMubGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlID0gdGhpcy5zaGFwZXNbaV07XG5cbiAgICAgICAgaWYgKHNoYXBlLnN0eWxlcy5pbmRleE9mKHN0eWxlKSAhPT0gLTEpIHtcbiAgICAgICAgICB0ZW1wU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgIGFyZUFuaW1hdGVkID0gc2hhcGUuX2lzQW5pbWF0ZWQgfHwgYXJlQW5pbWF0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRlbXBTaGFwZXMubGVuZ3RoID4gMSAmJiBhcmVBbmltYXRlZCkge1xuICAgICAgICB0aGlzLnNldFNoYXBlc0FzQW5pbWF0ZWQodGVtcFNoYXBlcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0U2hhcGVzQXNBbmltYXRlZCA9IGZ1bmN0aW9uIChzaGFwZXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2hhcGVzW2ldLnNldEFzQW5pbWF0ZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgbGV2ZWwpIHtcbiAgICAvLyBUT0RPOiBwcmV2ZW50IGRyYXdpbmcgb2YgaGlkZGVuIHN0eWxlc1xuICAgIHZhciBlbGVtZW50RGF0YTtcbiAgICB2YXIgc3R5bGVPYiA9IG5ldyBTVkdTdHlsZURhdGEoZGF0YSwgbGV2ZWwpO1xuICAgIHZhciBwYXRoRWxlbWVudCA9IHN0eWxlT2IucEVsZW07XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0Jykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHU3Ryb2tlU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2ZsJykge1xuICAgICAgZWxlbWVudERhdGEgPSBuZXcgU1ZHRmlsbFN0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgdmFyIEdyYWRpZW50Q29uc3RydWN0b3IgPSBkYXRhLnR5ID09PSAnZ2YnID8gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIDogU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGE7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBHcmFkaWVudENvbnN0cnVjdG9yKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEuZ2YpO1xuXG4gICAgICBpZiAoZWxlbWVudERhdGEubWFza0lkKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm1zKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEub2YpO1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGVsZW1lbnREYXRhLm1hc2tJZCArICcpJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnbm8nKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdOb1N0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIGxpbmVKb2luRW51bVtkYXRhLmxqIHx8IDJdKTtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgJzAnKTtcblxuICAgICAgaWYgKGRhdGEubGogPT09IDEpIHtcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsIGRhdGEubWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhLnIgPT09IDIpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sbikge1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGRhdGEubG4pO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmNsKSB7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZGF0YS5jbCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cblxuICAgIHRoaXMuc3R5bGVzTGlzdC5wdXNoKHN0eWxlT2IpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTaGFwZUdyb3VwRGF0YSgpO1xuXG4gICAgaWYgKGRhdGEubG4pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5jbCkge1xuICAgICAgZWxlbWVudERhdGEuZ3Iuc2V0QXR0cmlidXRlKCdjbGFzcycsIGRhdGEuY2wpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJtKSB7XG4gICAgICBlbGVtZW50RGF0YS5nci5zdHlsZVsnbWl4LWJsZW5kLW1vZGUnXSA9IGdldEJsZW5kTW9kZShkYXRhLmJtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xuICAgIHZhciB0cmFuc2Zvcm1Qcm9wZXJ0eSA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSBuZXcgU1ZHVHJhbnNmb3JtRGF0YSh0cmFuc2Zvcm1Qcm9wZXJ0eSwgdHJhbnNmb3JtUHJvcGVydHkubywgY29udGFpbmVyKTtcbiAgICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU2hhcGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIG93blRyYW5zZm9ybWVycywgbGV2ZWwpIHtcbiAgICB2YXIgdHkgPSA0O1xuXG4gICAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcbiAgICAgIHR5ID0gNTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcbiAgICAgIHR5ID0gNjtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcbiAgICAgIHR5ID0gNztcbiAgICB9XG5cbiAgICB2YXIgc2hhcGVQcm9wZXJ0eSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLCBkYXRhLCB0eSwgdGhpcyk7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNWR1NoYXBlRGF0YShvd25UcmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZVByb3BlcnR5KTtcbiAgICB0aGlzLnNoYXBlcy5wdXNoKGVsZW1lbnREYXRhKTtcbiAgICB0aGlzLmFkZFNoYXBlVG9Nb2RpZmllcnMoZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUb0FuaW1hdGVkQ29udGVudHMgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRlZENvbnRlbnRzW2ldLmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xuICAgICAgZm46IFNWR0VsZW1lbnRzUmVuZGVyZXIuY3JlYXRlUmVuZGVyRnVuY3Rpb24oZGF0YSksXG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xuICAgIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3Rbal0uY2xvc2VkKSB7XG4gICAgICAgIGFyci5wdXNoKHRoaXMuc3R5bGVzTGlzdFtqXSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcbiAgICB9XG5cbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsIHRoaXMuaXRlbXNEYXRhLCB0aGlzLnByZXZWaWV3RGF0YSwgdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcbiAgICB0aGlzLmZpbHRlclVuaXF1ZVNoYXBlcygpO1xuICAgIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcikge1xuICAgIHZhciBvd25UcmFuc2Zvcm1lcnMgPSBbXS5jb25jYXQodHJhbnNmb3JtZXJzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgbW9kaWZpZXI7XG4gICAgdmFyIHByb2Nlc3NlZFBvcztcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3JlbmRlciA9IHJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJyB8fCBhcnJbaV0udHkgPT09ICdubycpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVN0eWxlRWxlbWVudChhcnJbaV0sIGxldmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcbiAgICAgICAgICBpZiAoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5zdHlsZS5wRWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIGl0ZW1zRGF0YVtpXS5nciwgbGV2ZWwgKyAxLCBvd25UcmFuc2Zvcm1lcnMsIHJlbmRlcik7XG5cbiAgICAgICAgaWYgKGFycltpXS5fcmVuZGVyKSB7XG4gICAgICAgICAgaWYgKGl0ZW1zRGF0YVtpXS5nci5wYXJlbnROb2RlICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtc0RhdGFbaV0uZ3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0cicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldLCBjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IGl0ZW1zRGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIG93blRyYW5zZm9ybWVycy5wdXNoKGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdzaCcgfHwgYXJyW2ldLnR5ID09PSAncmMnIHx8IGFycltpXS50eSA9PT0gJ2VsJyB8fCBhcnJbaV0udHkgPT09ICdzcicpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSB0aGlzLmNyZWF0ZVNoYXBlRWxlbWVudChhcnJbaV0sIG93blRyYW5zZm9ybWVycywgbGV2ZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGVzKGl0ZW1zRGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAnbXMnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICByZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgbGVuID0gb3duU3R5bGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duU3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5yZXNldCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyU2hhcGUoKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuc3R5bGVzTGlzdFtpXS5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbSkge1xuICAgICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0uc2V0QXR0cmlidXRlKCdkJywgdGhpcy5zdHlsZXNMaXN0W2ldLmQpOyAvLyBBZGRpbmcgTTAgMCBmaXhlcyBzYW1lIG1hc2sgYnVnIG9uIGFsbCBicm93c2Vyc1xuXG4gICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLmQgPSAnTTAgMCcgKyB0aGlzLnN0eWxlc0xpc3RbaV0uZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCB8fCAnTTAgMCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xuICAgIHZhciBhbmltYXRlZENvbnRlbnQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGFuaW1hdGVkQ29udGVudCA9IHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXTtcblxuICAgICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IG51bGw7XG4gICAgdGhpcy5pdGVtc0RhdGEgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIExldHRlclByb3BzKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcbiAgICB0aGlzLm8gPSBvO1xuICAgIHRoaXMuc3cgPSBzdztcbiAgICB0aGlzLnNjID0gc2M7XG4gICAgdGhpcy5mYyA9IGZjO1xuICAgIHRoaXMubSA9IG07XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLl9tZGYgPSB7XG4gICAgICBvOiB0cnVlLFxuICAgICAgc3c6ICEhc3csXG4gICAgICBzYzogISFzYyxcbiAgICAgIGZjOiAhIWZjLFxuICAgICAgbTogdHJ1ZSxcbiAgICAgIHA6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgTGV0dGVyUHJvcHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChvLCBzdywgc2MsIGZjLCBtLCBwKSB7XG4gICAgdGhpcy5fbWRmLm8gPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc3cgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuc2MgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYuZmMgPSBmYWxzZTtcbiAgICB0aGlzLl9tZGYubSA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5wID0gZmFsc2U7XG4gICAgdmFyIHVwZGF0ZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLm8gIT09IG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLl9tZGYubyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdyAhPT0gc3cpIHtcbiAgICAgIHRoaXMuc3cgPSBzdztcbiAgICAgIHRoaXMuX21kZi5zdyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zYyAhPT0gc2MpIHtcbiAgICAgIHRoaXMuc2MgPSBzYztcbiAgICAgIHRoaXMuX21kZi5zYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mYyAhPT0gZmMpIHtcbiAgICAgIHRoaXMuZmMgPSBmYztcbiAgICAgIHRoaXMuX21kZi5mYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5tICE9PSBtKSB7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5fbWRmLm0gPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHAubGVuZ3RoICYmICh0aGlzLnBbMF0gIT09IHBbMF0gfHwgdGhpcy5wWzFdICE9PSBwWzFdIHx8IHRoaXMucFs0XSAhPT0gcFs0XSB8fCB0aGlzLnBbNV0gIT09IHBbNV0gfHwgdGhpcy5wWzEyXSAhPT0gcFsxMl0gfHwgdGhpcy5wWzEzXSAhPT0gcFsxM10pKSB7XG4gICAgICB0aGlzLnAgPSBwO1xuICAgICAgdGhpcy5fbWRmLnAgPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLl9mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcbiAgICB0aGlzLnB2ID0gJyc7XG4gICAgdGhpcy52ID0gJyc7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YS5kICYmIGRhdGEuZC5zaWQpIHtcbiAgICAgIGRhdGEuZCA9IGVsZW0uZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKGRhdGEuZCk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29tcCA9IHRoaXMuZWxlbS5jb21wO1xuICAgIHRoaXMua2V5c0luZGV4ID0gMDtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IGZhbHNlO1xuICAgIHRoaXMubWluaW11bUZvbnRTaXplID0gMTtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xuICAgIHRoaXMuY3VycmVudERhdGEgPSB7XG4gICAgICBhc2NlbnQ6IDAsXG4gICAgICBib3hXaWR0aDogdGhpcy5kZWZhdWx0Qm94V2lkdGgsXG4gICAgICBmOiAnJyxcbiAgICAgIGZTdHlsZTogJycsXG4gICAgICBmV2VpZ2h0OiAnJyxcbiAgICAgIGZjOiAnJyxcbiAgICAgIGo6ICcnLFxuICAgICAganVzdGlmeU9mZnNldDogJycsXG4gICAgICBsOiBbXSxcbiAgICAgIGxoOiAwLFxuICAgICAgbGluZVdpZHRoczogW10sXG4gICAgICBsczogJycsXG4gICAgICBvZjogJycsXG4gICAgICBzOiAnJyxcbiAgICAgIHNjOiAnJyxcbiAgICAgIHN3OiAwLFxuICAgICAgdDogMCxcbiAgICAgIHRyOiAwLFxuICAgICAgc3o6IDAsXG4gICAgICBwczogbnVsbCxcbiAgICAgIGZpbGxDb2xvckFuaW06IGZhbHNlLFxuICAgICAgc3Ryb2tlQ29sb3JBbmltOiBmYWxzZSxcbiAgICAgIHN0cm9rZVdpZHRoQW5pbTogZmFsc2UsXG4gICAgICB5T2Zmc2V0OiAwLFxuICAgICAgZmluYWxTaXplOiAwLFxuICAgICAgZmluYWxUZXh0OiBbXSxcbiAgICAgIGZpbmFsTGluZUhlaWdodDogMCxcbiAgICAgIF9fY29tcGxldGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLmNvcHlEYXRhKHRoaXMuY3VycmVudERhdGEsIHRoaXMuZGF0YS5kLmtbMF0ucyk7XG5cbiAgICBpZiAoIXRoaXMuc2VhcmNoUHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgIH1cbiAgfVxuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdEJveFdpZHRoID0gWzAsIDBdO1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuY29weURhdGEgPSBmdW5jdGlvbiAob2JqLCBkYXRhKSB7XG4gICAgZm9yICh2YXIgcyBpbiBkYXRhKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIHMpKSB7XG4gICAgICAgIG9ialtzXSA9IGRhdGFbc107XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldEN1cnJlbnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIWRhdGEuX19jb21wbGV0ZSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xuICAgIHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggPSB0aGlzLmN1cnJlbnREYXRhLmJveFdpZHRoIHx8IHRoaXMuZGVmYXVsdEJveFdpZHRoO1xuICAgIHRoaXMuX21kZiA9IHRydWU7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaEtleWZyYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmtmID0gdGhpcy5kYXRhLmQuay5sZW5ndGggPiAxO1xuXG4gICAgaWYgKHRoaXMua2YpIHtcbiAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0S2V5ZnJhbWVWYWx1ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5rZjtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGZ1bmN0aW9uIChlZmZlY3RGdW5jdGlvbikge1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xuICAgIHRoaXMuZWxlbS5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChfZmluYWxWYWx1ZSkge1xuICAgIGlmICgodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkIHx8ICF0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpICYmICFfZmluYWxWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudERhdGEudCA9IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnMudDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5rZXlzSW5kZXg7XG5cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9jayA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgICB2YXIgZmluYWxWYWx1ZSA9IF9maW5hbFZhbHVlIHx8IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIC8vIENoZWNraW5nIGlmIGluZGV4IGNoYW5nZWQgdG8gcHJldmVudCBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgZXhwcmVzc2lvbiB1cGRhdGVzLlxuICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPT0gdGhpcy5rZXlzSW5kZXgpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUsIGZpbmFsVmFsdWUudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0odGhpcy5jdXJyZW50RGF0YSwgZmluYWxWYWx1ZS50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFZhbHVlICE9PSBmaW5hbFZhbHVlKSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnREYXRhKGZpbmFsVmFsdWUpO1xuICAgIH1cblxuICAgIHRoaXMudiA9IHRoaXMuY3VycmVudERhdGE7XG4gICAgdGhpcy5wdiA9IHRoaXMudjtcbiAgICB0aGlzLmxvY2sgPSBmYWxzZTtcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICB9O1xuXG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGV4dEtleXMgPSB0aGlzLmRhdGEuZC5rO1xuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0S2V5cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoaSA9PT0gbGVuIC0gMSB8fCB0ZXh0S2V5c1tpICsgMV0udCA+IGZyYW1lTnVtKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMua2V5c0luZGV4ICE9PSBpKSB7XG4gICAgICB0aGlzLmtleXNJbmRleCA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5idWlsZEZpbmFsVGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgdmFyIGNoYXJhY3RlcnNBcnJheSA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgdmFyIGNoYXJDb2RlO1xuICAgIHZhciBzZWNvbmRDaGFyQ29kZTtcbiAgICB2YXIgc2hvdWxkQ29tYmluZSA9IGZhbHNlO1xuICAgIHZhciBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50Q2hhcnMgPSAnJztcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBzaG91bGRDb21iaW5lID0gc2hvdWxkQ29tYmluZU5leHQ7XG4gICAgICBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzQ29tYmluZWRDaGFyYWN0ZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlOyAvLyBJdCdzIGEgcG90ZW50aWFsIHN1cnJvZ2F0ZSBwYWlyICh0aGlzIGlzIHRoZSBIaWdoIHN1cnJvZ2F0ZSlcbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNSZWdpb25hbEZsYWcodGV4dCwgaSkpIHtcbiAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAxNCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vjb25kQ2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpOyAvLyBJdCdzIGEgc3Vycm9nYXRlIHBhaXIgKHRoaXMgaXMgdGhlIExvdyBzdXJyb2dhdGUpXG5cbiAgICAgICAgICBpZiAoc2Vjb25kQ2hhckNvZGUgPj0gMHhEQzAwICYmIHNlY29uZENoYXJDb2RlIDw9IDB4REZGRikge1xuICAgICAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzTW9kaWZpZXIoY2hhckNvZGUsIHNlY29uZENoYXJDb2RlKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAyKTtcbiAgICAgICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEZvbnRNYW5hZ2VyLmlzRmxhZ0Vtb2ppKHRleHQuc3Vic3RyKGksIDQpKSkge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRDaGFycyA9IHRleHQuc3Vic3RyKGksIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA+IDB4REJGRikge1xuICAgICAgICBzZWNvbmRDaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpICsgMSk7XG5cbiAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpKSB7XG4gICAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoRm9udE1hbmFnZXIuaXNaZXJvV2lkdGhKb2luZXIoY2hhckNvZGUpKSB7XG4gICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlO1xuICAgICAgICBzaG91bGRDb21iaW5lTmV4dCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRDb21iaW5lKSB7XG4gICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gY3VycmVudENoYXJzO1xuICAgICAgICBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaChjdXJyZW50Q2hhcnMpO1xuICAgICAgfVxuXG4gICAgICBpICs9IGN1cnJlbnRDaGFycy5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJhY3RlcnNBcnJheTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XG4gICAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xuICAgIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBsZXR0ZXJzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbmV3TGluZUZsYWc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBhbmNob3JHcm91cGluZyA9IGRhdGEubS5nO1xuICAgIHZhciBjdXJyZW50U2l6ZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAwO1xuICAgIHZhciBjdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgZm9udERhdGEgPSBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcbiAgICB2YXIgY2hhckRhdGE7XG4gICAgdmFyIGNMZW5ndGggPSAwO1xuICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG4gICAgZG9jdW1lbnREYXRhLmZXZWlnaHQgPSBmb250UHJvcHMud2VpZ2h0O1xuICAgIGRvY3VtZW50RGF0YS5mU3R5bGUgPSBmb250UHJvcHMuc3R5bGU7XG4gICAgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA9IGRvY3VtZW50RGF0YS5zO1xuICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSB0aGlzLmJ1aWxkRmluYWxUZXh0KGRvY3VtZW50RGF0YS50KTtcbiAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcbiAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmxoO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciBjaGFyQ29kZTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgIHZhciBib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIHZhciBib3hIZWlnaHQgPSBkb2N1bWVudERhdGEuc3pbMV07XG4gICAgICB2YXIgY3VycmVudEhlaWdodDtcbiAgICAgIHZhciBmaW5hbFRleHQ7XG5cbiAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgIGZpbmFsVGV4dCA9IHRoaXMuYnVpbGRGaW5hbFRleHQoZG9jdW1lbnREYXRhLnQpO1xuICAgICAgICBjdXJyZW50SGVpZ2h0ID0gMDtcbiAgICAgICAgbGluZVdpZHRoID0gMDtcbiAgICAgICAgbGVuID0gZmluYWxUZXh0Lmxlbmd0aDtcbiAgICAgICAgdHJhY2tpbmdPZmZzZXQgPSBkb2N1bWVudERhdGEudHIgLyAxMDAwICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgdmFyIGxhc3RTcGFjZUluZGV4ID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBmaW5hbFRleHRbaV0uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKGZpbmFsVGV4dFtpXSA9PT0gJyAnKSB7XG4gICAgICAgICAgICBsYXN0U3BhY2VJbmRleCA9IGk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMTMgfHwgY2hhckNvZGUgPT09IDMpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgICAgICAgY0xlbmd0aCA9IG5ld0xpbmVGbGFnID8gMCA6IGNoYXJEYXRhLncgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICAgICAgY0xlbmd0aCA9IGZvbnRNYW5hZ2VyLm1lYXN1cmVUZXh0KGZpbmFsVGV4dFtpXSwgZG9jdW1lbnREYXRhLmYsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsaW5lV2lkdGggKyBjTGVuZ3RoID4gYm94V2lkdGggJiYgZmluYWxUZXh0W2ldICE9PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpID0gbGFzdFNwYWNlSW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgICAgICAgICAgZmluYWxUZXh0LnNwbGljZShpLCBsYXN0U3BhY2VJbmRleCA9PT0gaSA/IDEgOiAwLCAnXFxyJyk7IC8vIGZpbmFsVGV4dCA9IGZpbmFsVGV4dC5zdWJzdHIoMCxpKSArIFwiXFxyXCIgKyBmaW5hbFRleHQuc3Vic3RyKGkgPT09IGxhc3RTcGFjZUluZGV4ID8gaSArIDEgOiBpKTtcblxuICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSBjTGVuZ3RoO1xuICAgICAgICAgICAgbGluZVdpZHRoICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRIZWlnaHQgKz0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcblxuICAgICAgICBpZiAodGhpcy5jYW5SZXNpemUgJiYgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA+IHRoaXMubWluaW11bUZvbnRTaXplICYmIGJveEhlaWdodCA8IGN1cnJlbnRIZWlnaHQpIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxTaXplIC09IDE7XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiBkb2N1bWVudERhdGEubGggLyBkb2N1bWVudERhdGEucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxUZXh0ID0gZmluYWxUZXh0O1xuICAgICAgICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmVXaWR0aCA9IC10cmFja2luZ09mZnNldDtcbiAgICBjTGVuZ3RoID0gMDtcbiAgICB2YXIgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xuICAgIHZhciBjdXJyZW50Q2hhcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbmV3TGluZUZsYWcgPSBmYWxzZTtcbiAgICAgIGN1cnJlbnRDaGFyID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXTtcbiAgICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcblxuICAgICAgaWYgKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMykge1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgICAgICBtYXhMaW5lV2lkdGggPSBsaW5lV2lkdGggPiBtYXhMaW5lV2lkdGggPyBsaW5lV2lkdGggOiBtYXhMaW5lV2lkdGg7XG4gICAgICAgIGxpbmVXaWR0aCA9IC0yICogdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIHZhbCA9ICcnO1xuICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRMaW5lICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBjdXJyZW50Q2hhcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoY3VycmVudENoYXIsIGZvbnREYXRhLmZTdHlsZSwgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZhciBjaGFyV2lkdGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgLy8gdENhbnZhc0hlbHBlci5mb250ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnKyBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICB9IC8vXG5cblxuICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAnICcpIHtcbiAgICAgICAgdW5jb2xsYXBzZWRTcGFjZXMgKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVdpZHRoICs9IGNMZW5ndGggKyB0cmFja2luZ09mZnNldCArIHVuY29sbGFwc2VkU3BhY2VzO1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGxldHRlcnMucHVzaCh7XG4gICAgICAgIGw6IGNMZW5ndGgsXG4gICAgICAgIGFuOiBjTGVuZ3RoLFxuICAgICAgICBhZGQ6IGN1cnJlbnRTaXplLFxuICAgICAgICBuOiBuZXdMaW5lRmxhZyxcbiAgICAgICAgYW5JbmRleGVzOiBbXSxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIGxpbmU6IGN1cnJlbnRMaW5lLFxuICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDBcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMikge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICcgJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYW5jaG9yR3JvdXBpbmcgPT0gMykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xuXG4gICAgICAgIGlmICh2YWwgPT09ICcnIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgICBpZiAodmFsID09PSAnJykge1xuICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudFNpemUgPSAwO1xuICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlcnNbaW5kZXhdLmluZCA9IGluZGV4O1xuICAgICAgICBsZXR0ZXJzW2luZGV4XS5leHRyYSA9IDA7XG4gICAgICAgIGluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xuICAgIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcbiAgICBsaW5lV2lkdGhzLnB1c2gobGluZVdpZHRoKTtcblxuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnREYXRhLmJveFdpZHRoID0gbWF4TGluZVdpZHRoO1xuXG4gICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IC1kb2N1bWVudERhdGEuYm94V2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gLWRvY3VtZW50RGF0YS5ib3hXaWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZG9jdW1lbnREYXRhLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgIHZhciBhbmltYXRvcnMgPSBkYXRhLmE7XG4gICAgdmFyIGFuaW1hdG9yRGF0YTtcbiAgICB2YXIgbGV0dGVyRGF0YTtcbiAgICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICB2YXIgYmFzZWQ7XG4gICAgdmFyIGluZDtcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgYW5pbWF0b3JEYXRhID0gYW5pbWF0b3JzW2pdO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuc2MpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmltYXRvckRhdGEuYS5zdykge1xuICAgICAgICBkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuaW1hdG9yRGF0YS5hLmZjIHx8IGFuaW1hdG9yRGF0YS5hLmZoIHx8IGFuaW1hdG9yRGF0YS5hLmZzIHx8IGFuaW1hdG9yRGF0YS5hLmZiKSB7XG4gICAgICAgIGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaW5kID0gMDtcbiAgICAgIGJhc2VkID0gYW5pbWF0b3JEYXRhLnMuYjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGxldHRlckRhdGEgPSBsZXR0ZXJzW2ldO1xuICAgICAgICBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSA9IGluZDtcblxuICAgICAgICBpZiAoYmFzZWQgPT0gMSAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgfHwgYmFzZWQgPT0gMiAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJycgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcgJyB8fCBiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJyAnIHx8IGkgPT0gbGVuIC0gMSkgfHwgYmFzZWQgPT0gNCAmJiAobGV0dGVyRGF0YS5uIHx8IGkgPT0gbGVuIC0gMSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICAgIGlmIChhbmltYXRvckRhdGEucy5ybiA9PT0gMSkge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGluZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcbiAgICAgIHZhciBjdXJyZW50SW5kID0gLTE7XG4gICAgICB2YXIgbmV3SW5kO1xuXG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgbGV0dGVyRGF0YSA9IGxldHRlcnNbaV07XG5cbiAgICAgICAgICBpZiAoY3VycmVudEluZCAhPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcbiAgICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBuZXdJbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudERhdGEueU9mZnNldCA9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICBkb2N1bWVudERhdGEubHMgPSBkb2N1bWVudERhdGEubHMgfHwgMDtcbiAgICBkb2N1bWVudERhdGEuYXNjZW50ID0gZm9udERhdGEuYXNjZW50ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XG4gICAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XG4gICAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcbiAgICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XG4gICAgdGhpcy5zZXRDdXJyZW50RGF0YShkRGF0YSk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnJlY2FsY3VsYXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIGREYXRhID0gdGhpcy5kYXRhLmQua1tpbmRleF0ucztcbiAgICBkRGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzSW5kZXggPSAwO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5nZXRWYWx1ZShkRGF0YSk7XG4gIH07XG5cbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLmNhblJlc2l6ZSA9IF9jYW5SZXNpemU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVGV4dFNlbGVjdG9yUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgICBmdW5jdGlvbiBUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeShlbGVtLCBkYXRhKSB7XG4gICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IC0xO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZmluYWxTID0gMDtcbiAgICAgIHRoaXMuZmluYWxFID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucyB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuXG4gICAgICBpZiAoJ2UnIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZSA9IHtcbiAgICAgICAgICB2OiAxMDBcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5uZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubmUgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuc20gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNtIHx8IHtcbiAgICAgICAgazogMTAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFRleHRTZWxlY3RvclByb3BGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgIGdldE11bHQ6IGZ1bmN0aW9uIGdldE11bHQoaW5kKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGV4dExlbmd0aCAhPT0gdGhpcy5lbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIHZhciB4MiA9IDE7XG4gICAgICAgIHZhciB5MiA9IDE7XG5cbiAgICAgICAgaWYgKHRoaXMubmUudiA+IDApIHtcbiAgICAgICAgICB4MSA9IHRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkxID0gLXRoaXMubmUudiAvIDEwMC4wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMueGUudiA+IDApIHtcbiAgICAgICAgICB4MiA9IDEuMCAtIHRoaXMueGUudiAvIDEwMC4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHkyID0gMS4wICsgdGhpcy54ZS52IC8gMTAwLjA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWFzZXIgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyh4MSwgeTEsIHgyLCB5MikuZ2V0O1xuICAgICAgICB2YXIgbXVsdCA9IDA7XG4gICAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XG4gICAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDEgOiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSBpbmQgPj0gZSA/IDAgOiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtdWx0ID0gMSAtIG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcblxuICAgICAgICAgICAgaWYgKG11bHQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgbXVsdCAqPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbXVsdCA9IDEgLSAyICogKG11bHQgLSAwLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdG90ID0gZSAtIHM7XG4gICAgICAgICAgICAvKiBpbmQgKz0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IC00Lyh0b3QqdG90KSooaW5kKmluZCkrKDQvdG90KSppbmQ7ICovXG5cbiAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcbiAgICAgICAgICAgIHZhciB4ID0gLXRvdCAvIDIgKyBpbmQ7XG4gICAgICAgICAgICB2YXIgYSA9IHRvdCAvIDI7XG4gICAgICAgICAgICBtdWx0ID0gTWF0aC5zcXJ0KDEgLSB4ICogeCAvIChhICogYSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2KSB7XG4gICAgICAgICAgaWYgKGUgPT09IHMpIHtcbiAgICAgICAgICAgIG11bHQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsIGluZCArIDAuNSAtIHMpLCBlIC0gcyk7XG4gICAgICAgICAgICBtdWx0ID0gKDEgKyBNYXRoLmNvcyhNYXRoLlBJICsgTWF0aC5QSSAqIDIgKiBpbmQgLyAoZSAtIHMpKSkgLyAyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbmQgPj0gZmxvb3IocykpIHtcbiAgICAgICAgICAgIGlmIChpbmQgLSBzIDwgMCkge1xuICAgICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbihtaW4oZSwgMSkgLSAocyAtIGluZCksIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKGUgLSBpbmQsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gLy8gU21vb3RobmVzcyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gVGhlIHNtb290aG5lc3MgcmVwcmVzZW50cyBhIHJlZHVjZWQgcmFuZ2Ugb2YgdGhlIG9yaWdpbmFsIFswOyAxXSByYW5nZS5cbiAgICAgICAgLy8gaWYgc21vb3RobmVzcyBpcyAyNSUsIHRoZSBuZXcgcmFuZ2Ugd2lsbCBiZSBbMC4zNzU7IDAuNjI1XVxuICAgICAgICAvLyBTdGVwcyBhcmU6XG4gICAgICAgIC8vIC0gZmluZCB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIG5ldyByYW5nZSAodGhyZXNob2xkKVxuICAgICAgICAvLyAtIGlmIG11bHRpcGxpZXIgaXMgc21hbGxlciB0aGFuIHRoYXQgdmFsdWUsIGZsb29yIGl0IHRvIDBcbiAgICAgICAgLy8gLSBpZiBpdCBpcyBsYXJnZXIsXG4gICAgICAgIC8vICAgICAtIHN1YnRyYWN0IHRoZSB0aHJlc2hvbGRcbiAgICAgICAgLy8gICAgIC0gZGl2aWRlIGl0IGJ5IHRoZSBzbW9vdGhuZXNzICh0aGlzIHdpbGwgcmV0dXJuIHRoZSByYW5nZSB0byBbMDsgMV0pXG4gICAgICAgIC8vIE5vdGU6IElmIGl0IGRvZXNuJ3Qgd29yayBvbiBzb21lIHNjZW5hcmlvcywgY29uc2lkZXIgYXBwbHlpbmcgaXQgYmVmb3JlIHRoZSBlYXNlci5cblxuXG4gICAgICAgIGlmICh0aGlzLnNtLnYgIT09IDEwMCkge1xuICAgICAgICAgIHZhciBzbW9vdGhuZXNzID0gdGhpcy5zbS52ICogMC4wMTtcblxuICAgICAgICAgIGlmIChzbW9vdGhuZXNzID09PSAwKSB7XG4gICAgICAgICAgICBzbW9vdGhuZXNzID0gMC4wMDAwMDAwMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdGhyZXNob2xkID0gMC41IC0gc21vb3RobmVzcyAqIDAuNTtcblxuICAgICAgICAgIGlmIChtdWx0IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IChtdWx0IC0gdGhyZXNob2xkKSAvIHNtb290aG5lc3M7XG5cbiAgICAgICAgICAgIGlmIChtdWx0ID4gMSkge1xuICAgICAgICAgICAgICBtdWx0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbXVsdCAqIHRoaXMuYS52O1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZShuZXdDaGFyc0ZsYWcpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fbWRmID0gbmV3Q2hhcnNGbGFnIHx8IHRoaXMuX21kZjtcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoIHx8IDA7XG5cbiAgICAgICAgaWYgKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xuICAgICAgICAgIHRoaXMuZS52ID0gdGhpcy5fY3VycmVudFRleHRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGl2aXNvciA9IHRoaXMuZGF0YS5yID09PSAyID8gMSA6IDEwMCAvIHRoaXMuZGF0YS50b3RhbENoYXJzO1xuICAgICAgICB2YXIgbyA9IHRoaXMuby52IC8gZGl2aXNvcjtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnMudiAvIGRpdmlzb3IgKyBvO1xuICAgICAgICB2YXIgZSA9IHRoaXMuZS52IC8gZGl2aXNvciArIG87XG5cbiAgICAgICAgaWYgKHMgPiBlKSB7XG4gICAgICAgICAgdmFyIF9zID0gcztcbiAgICAgICAgICBzID0gZTtcbiAgICAgICAgICBlID0gX3M7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbmFsUyA9IHM7XG4gICAgICAgIHRoaXMuZmluYWxFID0gZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkpO1xuXG4gICAgZnVuY3Rpb24gZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBkYXRhLCBhcnIpIHtcbiAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSwgYXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VGV4dFNlbGVjdG9yUHJvcDogZ2V0VGV4dFNlbGVjdG9yUHJvcFxuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkoZWxlbSwgYW5pbWF0b3JQcm9wcywgY29udGFpbmVyKSB7XG4gICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgcHJvcFR5cGU6IGZhbHNlXG4gICAgfTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHZhciB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcyA9IGFuaW1hdG9yUHJvcHMuYTtcbiAgICB0aGlzLmEgPSB7XG4gICAgICByOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHJ4OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucngsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcnk6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzazogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2sgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNrLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHNhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2EsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucywgMSwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgYTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuYSwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgbzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMubywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucCwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc3c6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zdywgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc2M6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmg6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5maCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZnM6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mcywgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgZmI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5mYiwgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgdDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMudCwgMCwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhXG4gICAgfTtcbiAgICB0aGlzLnMgPSBUZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3AoZWxlbSwgYW5pbWF0b3JQcm9wcy5zLCBjb250YWluZXIpO1xuICAgIHRoaXMucy50ID0gYW5pbWF0b3JQcm9wcy5zLnQ7XG4gIH1cblxuICBmdW5jdGlvbiBUZXh0QW5pbWF0b3JQcm9wZXJ0eSh0ZXh0RGF0YSwgcmVuZGVyVHlwZSwgZWxlbSkge1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLl90ZXh0RGF0YSA9IHRleHREYXRhO1xuICAgIHRoaXMuX3JlbmRlclR5cGUgPSByZW5kZXJUeXBlO1xuICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xuICAgIHRoaXMuX2FuaW1hdG9yc0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX3RleHREYXRhLmEubGVuZ3RoKTtcbiAgICB0aGlzLl9wYXRoRGF0YSA9IHt9O1xuICAgIHRoaXMuX21vcmVPcHRpb25zID0ge1xuICAgICAgYWxpZ25tZW50OiB7fVxuICAgIH07XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBbXTtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgfVxuXG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aDtcbiAgICB2YXIgYW5pbWF0b3JQcm9wcztcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBhbmltYXRvclByb3BzID0gdGhpcy5fdGV4dERhdGEuYVtpXTtcbiAgICAgIHRoaXMuX2FuaW1hdG9yc0RhdGFbaV0gPSBuZXcgVGV4dEFuaW1hdG9yRGF0YVByb3BlcnR5KHRoaXMuX2VsZW0sIGFuaW1hdG9yUHJvcHMsIHRoaXMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZXh0RGF0YS5wICYmICdtJyBpbiB0aGlzLl90ZXh0RGF0YS5wKSB7XG4gICAgICB0aGlzLl9wYXRoRGF0YSA9IHtcbiAgICAgICAgYTogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmEsIDAsIDAsIHRoaXMpLFxuICAgICAgICBmOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuZiwgMCwgMCwgdGhpcyksXG4gICAgICAgIGw6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5sLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgcjogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLnIsIDAsIDAsIHRoaXMpLFxuICAgICAgICBwOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAucCwgMCwgMCwgdGhpcyksXG4gICAgICAgIG06IHRoaXMuX2VsZW0ubWFza01hbmFnZXIuZ2V0TWFza1Byb3BlcnR5KHRoaXMuX3RleHREYXRhLnAubSlcbiAgICAgIH07XG4gICAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX21vcmVPcHRpb25zLmFsaWdubWVudCA9IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEubS5hLCAxLCAwLCB0aGlzKTtcbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0TWVhc3VyZXMgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlcnNDaGFuZ2VkRmxhZztcblxuICAgIGlmICghdGhpcy5fbWRmICYmICF0aGlzLl9pc0ZpcnN0RnJhbWUgJiYgIWxldHRlcnNDaGFuZ2VkRmxhZyAmJiAoIXRoaXMuX2hhc01hc2tlZFBhdGggfHwgIXRoaXMuX3BhdGhEYXRhLm0uX21kZikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5fbW9yZU9wdGlvbnMuYWxpZ25tZW50LnY7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuX2FuaW1hdG9yc0RhdGE7XG4gICAgdmFyIHRleHREYXRhID0gdGhpcy5fdGV4dERhdGE7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgcmVuZGVyVHlwZSA9IHRoaXMuX3JlbmRlclR5cGU7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyc0NvdW50ID0gdGhpcy5yZW5kZXJlZExldHRlcnMubGVuZ3RoO1xuICAgIHZhciB4UG9zO1xuICAgIHZhciB5UG9zO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgcGF0aEluZm87XG4gICAgdmFyIGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRQb2ludDtcbiAgICB2YXIgc2VnbWVudExlbmd0aDtcbiAgICB2YXIgZmxhZztcbiAgICB2YXIgcG9pbnRJbmQ7XG4gICAgdmFyIHNlZ21lbnRJbmQ7XG4gICAgdmFyIHByZXZQb2ludDtcbiAgICB2YXIgcG9pbnRzO1xuICAgIHZhciBzZWdtZW50cztcbiAgICB2YXIgcGFydGlhbExlbmd0aDtcbiAgICB2YXIgdG90YWxMZW5ndGg7XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIHRhbkFuZ2xlO1xuICAgIHZhciBtYXNrO1xuXG4gICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgIG1hc2sgPSB0aGlzLl9wYXRoRGF0YS5tO1xuXG4gICAgICBpZiAoIXRoaXMuX3BhdGhEYXRhLm4gfHwgdGhpcy5fcGF0aERhdGEuX21kZikge1xuICAgICAgICB2YXIgcGF0aHMgPSBtYXNrLnY7XG5cbiAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLnIudikge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xuICAgICAgICB9IC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXG5cblxuICAgICAgICBwYXRoSW5mbyA9IHtcbiAgICAgICAgICB0TGVuZ3RoOiAwLFxuICAgICAgICAgIHNlZ21lbnRzOiBbXVxuICAgICAgICB9O1xuICAgICAgICBsZW4gPSBwYXRocy5fbGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIGJlemllckRhdGE7XG4gICAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBiZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRocy52W2ldLCBwYXRocy52W2kgKyAxXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBpID0gbGVuO1xuXG4gICAgICAgIGlmIChtYXNrLnYuYykge1xuICAgICAgICAgIGJlemllckRhdGEgPSBiZXouYnVpbGRCZXppZXJEYXRhKHBhdGhzLnZbaV0sIHBhdGhzLnZbMF0sIFtwYXRocy5vW2ldWzBdIC0gcGF0aHMudltpXVswXSwgcGF0aHMub1tpXVsxXSAtIHBhdGhzLnZbaV1bMV1dLCBbcGF0aHMuaVswXVswXSAtIHBhdGhzLnZbMF1bMF0sIHBhdGhzLmlbMF1bMV0gLSBwYXRocy52WzBdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXRoRGF0YS5waSA9IHBhdGhJbmZvO1xuICAgICAgfVxuXG4gICAgICBwYXRoSW5mbyA9IHRoaXMuX3BhdGhEYXRhLnBpO1xuICAgICAgY3VycmVudExlbmd0aCA9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgIHNlZ21lbnRJbmQgPSAwO1xuICAgICAgcG9pbnRJbmQgPSAxO1xuICAgICAgc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIHNlZ21lbnRzID0gcGF0aEluZm8uc2VnbWVudHM7XG5cbiAgICAgIGlmIChjdXJyZW50TGVuZ3RoIDwgMCAmJiBtYXNrLnYuYykge1xuICAgICAgICBpZiAocGF0aEluZm8udExlbmd0aCA8IE1hdGguYWJzKGN1cnJlbnRMZW5ndGgpKSB7XG4gICAgICAgICAgY3VycmVudExlbmd0aCA9IC1NYXRoLmFicyhjdXJyZW50TGVuZ3RoKSAlIHBhdGhJbmZvLnRMZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBzZWdtZW50SW5kID0gc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50TGVuZ3RoIDwgMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gcG9pbnRzW3BvaW50SW5kXS5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIHBvaW50SW5kIC09IDE7XG5cbiAgICAgICAgICBpZiAocG9pbnRJbmQgPCAwKSB7XG4gICAgICAgICAgICBzZWdtZW50SW5kIC09IDE7XG4gICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgfVxuXG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgeFBvcyA9IDA7XG4gICAgeVBvcyA9IDA7XG4gICAgdmFyIHlPZmYgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yICogMC43MTQ7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIGFuaW1hdG9yUHJvcHM7XG4gICAgdmFyIGFuaW1hdG9yU2VsZWN0b3I7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGxldHRlclZhbHVlO1xuICAgIGpMZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuICAgIHZhciBtdWx0O1xuICAgIHZhciBpbmQgPSAtMTtcbiAgICB2YXIgb2ZmZjtcbiAgICB2YXIgeFBhdGhQb3M7XG4gICAgdmFyIHlQYXRoUG9zO1xuICAgIHZhciBpbml0UGF0aFBvcyA9IGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGluaXRTZWdtZW50SW5kID0gc2VnbWVudEluZDtcbiAgICB2YXIgaW5pdFBvaW50SW5kID0gcG9pbnRJbmQ7XG4gICAgdmFyIGN1cnJlbnRMaW5lID0gLTE7XG4gICAgdmFyIGVsZW1PcGFjaXR5O1xuICAgIHZhciBzYztcbiAgICB2YXIgc3c7XG4gICAgdmFyIGZjO1xuICAgIHZhciBrO1xuICAgIHZhciBsZXR0ZXJTdztcbiAgICB2YXIgbGV0dGVyU2M7XG4gICAgdmFyIGxldHRlckZjO1xuICAgIHZhciBsZXR0ZXJNID0gJyc7XG4gICAgdmFyIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xuICAgIHZhciBsZXR0ZXJPOyAvL1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5qID09PSAyIHx8IGRvY3VtZW50RGF0YS5qID09PSAxKSB7XG4gICAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhbmltYXRvckZpcnN0Q2hhck9mZnNldCA9IDA7XG4gICAgICB2YXIganVzdGlmeU9mZnNldE11bHQgPSBkb2N1bWVudERhdGEuaiA9PT0gMiA/IC0wLjUgOiAtMTtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGlzTmV3TGluZSA9IHRydWU7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgICAgaWYgKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xuICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHdoaWxlIChsYXN0SW5kZXggPCBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xuICAgICAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICBpc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAoaXNOZXdMaW5lICYmIGRvY3VtZW50RGF0YS5qID09PSAyKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF0gKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0ICoganVzdGlmeU9mZnNldE11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpc05ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XG4gICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvckZpcnN0Q2hhck9mZnNldDtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcbiAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfSAvL1xuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuICAgICAgZWxlbU9wYWNpdHkgPSAxO1xuXG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIHhQb3MgPSAwO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gaW5pdFBhdGhQb3M7XG4gICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgc2VnbWVudEluZCA9IGluaXRTZWdtZW50SW5kO1xuICAgICAgICAgIHBvaW50SW5kID0gaW5pdFBvaW50SW5kO1xuICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xuICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldHRlck0gPSAnJztcbiAgICAgICAgbGV0dGVyRmMgPSAnJztcbiAgICAgICAgbGV0dGVyU3cgPSAnJztcbiAgICAgICAgbGV0dGVyTyA9ICcnO1xuICAgICAgICBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRMaW5lICE9PSBsZXR0ZXJzW2ldLmxpbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9ICh0b3RhbExlbmd0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGxldHRlcnNbaV0ubGluZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW5kICE9PSBsZXR0ZXJzW2ldLmluZCkge1xuICAgICAgICAgICAgaWYgKGxldHRlcnNbaW5kXSkge1xuICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaW5kXS5leHRyYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcbiAgICAgICAgICAgIGluZCA9IGxldHRlcnNbaV0uaW5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1O1xuICAgICAgICAgIHZhciBhbmltYXRvck9mZnNldCA9IDA7XG5cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuXG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvck9mZnNldCArPSBhbmltYXRvclByb3BzLmEudlswXSAqIG11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmbGFnID0gdHJ1ZTsgLy8gRm9yY2UgYWxpZ25tZW50IG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBsaW5lIGZvciBub3dcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5hLnYpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBsZXR0ZXJzWzBdLmFuICogMC41ICsgKHRvdGFsTGVuZ3RoIC0gdGhpcy5fcGF0aERhdGEuZi52IC0gbGV0dGVyc1swXS5hbiAqIDAuNSAtIGxldHRlcnNbbGV0dGVycy5sZW5ndGggLSAxXS5hbiAqIDAuNSkgKiBpbmQgLyAobGVuIC0gMSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRMZW5ndGggKyBwYXJ0aWFsTGVuZ3RoID49IGN1cnJlbnRMZW5ndGggKyBhbmltYXRvck9mZnNldCB8fCAhcG9pbnRzKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAoY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IC0gc2VnbWVudExlbmd0aCkgLyBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgeFBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMF0gKyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKSAqIHBlcmM7XG4gICAgICAgICAgICAgIHlQYXRoUG9zID0gcHJldlBvaW50LnBvaW50WzFdICsgKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgKiBwZXJjO1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC0oYWxpZ25tZW50WzFdICogeU9mZikgKiAwLjAxKTtcbiAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCArPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgcG9pbnRJbmQgKz0gMTtcblxuICAgICAgICAgICAgICBpZiAocG9pbnRJbmQgPj0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBvaW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kICs9IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRzW3NlZ21lbnRJbmRdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFzay52LmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCAtPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgICAgICBwcmV2UG9pbnQgPSBjdXJyZW50UG9pbnQ7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbiAvIDIgLSBsZXR0ZXJzW2ldLmFkZDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLCAwLCAwKTsgLy8gR3JvdXBpbmcgYWxpZ25tZW50XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDUsIC1hbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpOyAvLyBUaGlzIGNvbmRpdGlvbiBpcyB0byBwcmV2ZW50IGFwcGx5aW5nIHRyYWNraW5nIHRvIGZpcnN0IGNoYXJhY3RlciBpbiBlYWNoIGxpbmUuIE1pZ2h0IGJlIGJldHRlciB0byB1c2UgYSBib29sZWFuIFwiaXNOZXdMaW5lXCJcblxuICAgICAgICAgICAgaWYgKHhQb3MgIT09IDAgfHwgZG9jdW1lbnREYXRhLmogIT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52ICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgc3cgPSBkb2N1bWVudERhdGEuc3cgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgICAgICAgc2MgPSBbZG9jdW1lbnREYXRhLnNjWzBdLCBkb2N1bWVudERhdGEuc2NbMV0sIGRvY3VtZW50RGF0YS5zY1syXV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjID0gWzAsIDAsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICBmYyA9IFtkb2N1bWVudERhdGEuZmNbMF0sIGRvY3VtZW50RGF0YS5mY1sxXSwgZG9jdW1lbnREYXRhLmZjWzJdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHRbMV0sIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbmltYXRvclByb3BzLmEudlswXSAqIG11bHQsIC1hbmltYXRvclByb3BzLmEudlsxXSAqIG11bHQsIGFuaW1hdG9yUHJvcHMuYS52WzJdICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0WzBdLCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0WzFdLCAxKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZSgxICsgKGFuaW1hdG9yUHJvcHMucy52WzBdIC0gMSkgKiBtdWx0LCAxICsgKGFuaW1hdG9yUHJvcHMucy52WzFdIC0gMSkgKiBtdWx0LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zay5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5za2V3RnJvbUF4aXMoLWFuaW1hdG9yUHJvcHMuc2sudiAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMuc2EudiAqIG11bHRbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNrZXdGcm9tQXhpcygtYW5pbWF0b3JQcm9wcy5zay52ICogbXVsdCwgYW5pbWF0b3JQcm9wcy5zYS52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuci5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVaKC1hbmltYXRvclByb3BzLnIudiAqIG11bHRbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucnkucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYgKiBtdWx0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnJ4LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5vLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZWxlbU9wYWNpdHkgKz0gKGFuaW1hdG9yUHJvcHMuby52ICogbXVsdFswXSAtIGVsZW1PcGFjaXR5KSAqIG11bHRbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoYW5pbWF0b3JQcm9wcy5vLnYgKiBtdWx0IC0gZWxlbU9wYWNpdHkpICogbXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSAmJiBhbmltYXRvclByb3BzLnN3LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3ICs9IGFuaW1hdG9yUHJvcHMuc3cudiAqIG11bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0gJiYgYW5pbWF0b3JQcm9wcy5zYy5wcm9wVHlwZSkge1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdFswXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY1trXSArPSAoYW5pbWF0b3JQcm9wcy5zYy52W2tdIC0gc2Nba10pICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZjLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBmY1trXSArPSAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pICogbXVsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmgucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZnMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZnMudiAqIG11bHRbMF0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5mYi5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsIGFuaW1hdG9yUHJvcHMuZmIudiAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcblxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnAucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMF0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMV0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdFswXSwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzFdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0LCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgbGV0dGVyU3cgPSBzdyA8IDAgPyAwIDogc3c7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSkge1xuICAgICAgICAgIGxldHRlclNjID0gJ3JnYignICsgTWF0aC5yb3VuZChzY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKHNjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoc2NbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgIGxldHRlckZjID0gJ3JnYignICsgTWF0aC5yb3VuZChmY1swXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGZjWzFdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMl0gKiAyNTUpICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEgKyB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5wLnYpIHtcbiAgICAgICAgICAgIHRhbkFuZ2xlID0gKGN1cnJlbnRQb2ludC5wb2ludFsxXSAtIHByZXZQb2ludC5wb2ludFsxXSkgLyAoY3VycmVudFBvaW50LnBvaW50WzBdIC0gcHJldlBvaW50LnBvaW50WzBdKTtcbiAgICAgICAgICAgIHZhciByb3QgPSBNYXRoLmF0YW4odGFuQW5nbGUpICogMTgwIC8gTWF0aC5QSTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQb2ludC5wb2ludFswXSA8IHByZXZQb2ludC5wb2ludFswXSkge1xuICAgICAgICAgICAgICByb3QgKz0gMTgwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlKC1yb3QgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQYXRoUG9zLCB5UGF0aFBvcywgMCk7XG4gICAgICAgICAgY3VycmVudExlbmd0aCAtPSBhbGlnbm1lbnRbMF0gKiBsZXR0ZXJzW2ldLmFuICogMC4wMDU7XG5cbiAgICAgICAgICBpZiAobGV0dGVyc1tpICsgMV0gJiYgaW5kICE9PSBsZXR0ZXJzW2kgKyAxXS5pbmQpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpXS5hbiAvIDI7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UG9zLCB5UG9zLCAwKTtcblxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcbiAgICAgICAgICAgIC8vIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSwwKTtcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSwgMCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUobGV0dGVyc1tpXS5hbmltYXRvckp1c3RpZnlPZmZzZXQgKyBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSAvIDIsIDAsIDApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzKTtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKG9mZmYsIDAsIDApO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1LCBhbGlnbm1lbnRbMV0gKiB5T2ZmICogMC4wMSwgMCk7XG4gICAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmwgKyBkb2N1bWVudERhdGEudHIgKiAwLjAwMSAqIGRvY3VtZW50RGF0YS5maW5hbFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyVHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50b0NTUygpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50bzJkQ1NTKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0dGVyUCA9IFttYXRyaXhIZWxwZXIucHJvcHNbMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxXSwgbWF0cml4SGVscGVyLnByb3BzWzJdLCBtYXRyaXhIZWxwZXIucHJvcHNbM10sIG1hdHJpeEhlbHBlci5wcm9wc1s0XSwgbWF0cml4SGVscGVyLnByb3BzWzVdLCBtYXRyaXhIZWxwZXIucHJvcHNbNl0sIG1hdHJpeEhlbHBlci5wcm9wc1s3XSwgbWF0cml4SGVscGVyLnByb3BzWzhdLCBtYXRyaXhIZWxwZXIucHJvcHNbOV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMV0sIG1hdHJpeEhlbHBlci5wcm9wc1sxMl0sIG1hdHJpeEhlbHBlci5wcm9wc1sxM10sIG1hdHJpeEhlbHBlci5wcm9wc1sxNF0sIG1hdHJpeEhlbHBlci5wcm9wc1sxNV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyZWRMZXR0ZXJzQ291bnQgPD0gaSkge1xuICAgICAgICBsZXR0ZXJWYWx1ZSA9IG5ldyBMZXR0ZXJQcm9wcyhsZXR0ZXJPLCBsZXR0ZXJTdywgbGV0dGVyU2MsIGxldHRlckZjLCBsZXR0ZXJNLCBsZXR0ZXJQKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZExldHRlcnMucHVzaChsZXR0ZXJWYWx1ZSk7XG4gICAgICAgIHJlbmRlcmVkTGV0dGVyc0NvdW50ICs9IDE7XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldHRlclZhbHVlID0gdGhpcy5yZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gbGV0dGVyVmFsdWUudXBkYXRlKGxldHRlck8sIGxldHRlclN3LCBsZXR0ZXJTYywgbGV0dGVyRmMsIGxldHRlck0sIGxldHRlclApIHx8IHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLl9mcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZnJhbWVJZCA9IHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG5cbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLm1IZWxwZXIgPSBuZXcgTWF0cml4KCk7XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5kZWZhdWx0UHJvcHNBcnJheSA9IFtdO1xuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRBbmltYXRvclByb3BlcnR5KTtcblxuICBmdW5jdGlvbiBJVGV4dEVsZW1lbnQoKSB7fVxuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gdHJ1ZTtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudGV4dFByb3BlcnR5ID0gbmV3IFRleHRQcm9wZXJ0eSh0aGlzLCBkYXRhLnQsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIHRoaXMudGV4dEFuaW1hdG9yID0gbmV3IFRleHRBbmltYXRvclByb3BlcnR5KGRhdGEudCwgdGhpcy5yZW5kZXJUeXBlLCB0aGlzKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xuICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XG4gICAgdGhpcy5oaWRlKCk7XG4gICAgdGhpcy50ZXh0QW5pbWF0b3Iuc2VhcmNoUHJvcGVydGllcyh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlUGF0aFNoYXBlID0gZnVuY3Rpb24gKG1hdHJpeEhlbHBlciwgc2hhcGVzKSB7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIHZhciBwYXRoTm9kZXM7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICBzaGFwZVN0ciArPSBidWlsZFNoYXBlU3RyaW5nKHBhdGhOb2RlcywgcGF0aE5vZGVzLmkubGVuZ3RoLCB0cnVlLCBtYXRyaXhIZWxwZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaGFwZVN0cjtcbiAgfTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnVwZGF0ZURvY3VtZW50RGF0YShuZXdEYXRhLCBpbmRleCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24gKF9jYW5SZXNpemUpIHtcbiAgICB0aGlzLnRleHRQcm9wZXJ0eS5jYW5SZXNpemVGb250KF9jYW5SZXNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuc2V0TWluaW11bUZvbnRTaXplID0gZnVuY3Rpb24gKF9mb250U2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnNldE1pbmltdW1Gb250U2l6ZShfZm9udFNpemUpO1xuICB9O1xuXG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4ID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsaW5lTnVtYmVyLCB4UG9zLCB5UG9zKSB7XG4gICAgaWYgKGRvY3VtZW50RGF0YS5wcykge1xuICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sIGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsIDApO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scywgMCk7XG5cbiAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSkgLyAyLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZENvbG9yID0gZnVuY3Rpb24gKGNvbG9yRGF0YSkge1xuICAgIHJldHVybiAncmdiKCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVswXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsxXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsyXSAqIDI1NSkgKyAnKSc7XG4gIH07XG5cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5lbXB0eVByb3AgPSBuZXcgTGV0dGVyUHJvcHMoKTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnZhbGlkYXRlVGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50ZXh0UHJvcGVydHkuX21kZiB8fCB0aGlzLnRleHRQcm9wZXJ0eS5faXNGaXJzdEZyYW1lKSB7XG4gICAgICB0aGlzLmJ1aWxkTmV3VGV4dCgpO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX21kZiA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZW1wdHlTaGFwZURhdGEgPSB7XG4gICAgc2hhcGVzOiBbXVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgU1ZHVGV4dExvdHRpZUVsZW1lbnQpO1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmRhdGEuc2luZ2xlU2hhcGUgJiYgIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgdGhpcy50ZXh0Q29udGFpbmVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICB9XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkVGV4dENvbnRlbnRzID0gZnVuY3Rpb24gKHRleHRBcnJheSkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGV4dEFycmF5Lmxlbmd0aDtcbiAgICB2YXIgdGV4dENvbnRlbnRzID0gW107XG4gICAgdmFyIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xuXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xuICAgICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0Q29udGVudCArPSB0ZXh0QXJyYXlbaV07XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgIHJldHVybiB0ZXh0Q29udGVudHM7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkU2hhcGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHNjYWxlKSB7XG4gICAgLy8gZGF0YSBzaG91bGQgcHJvYmFibHkgYmUgY2xvbmVkIHRvIGFwcGx5IHNjYWxlIHNlcGFyYXRlbHkgdG8gZWFjaCBpbnN0YW5jZSBvZiBhIHRleHQgb24gZGlmZmVyZW50IGxheWVyc1xuICAgIC8vIGJ1dCBzaW5jZSB0ZXh0IGludGVybmFsIGNvbnRlbnQgZ2V0cyBvbmx5IHJlbmRlcmVkIG9uY2UgYW5kIHRoZW4gaXQncyBuZXZlciByZXJlbmRlcmVkLFxuICAgIC8vIGl0J3MgcHJvYmFibHkgc2FmZSBub3QgdG8gY2xvbmUgZGF0YSBhbmQgcmV1c2UgYWx3YXlzIHRoZSBzYW1lIGluc3RhbmNlIGV2ZW4gaWYgdGhlIG9iamVjdCBpcyBtdXRhdGVkLlxuICAgIC8vIEF2b2lkaW5nIGNsb25pbmcgaXMgcHJlZmVycmVkIHNpbmNlIGNsb25pbmcgZWFjaCBjaGFyYWN0ZXIgc2hhcGUgZGF0YSBpcyBleHBlbnNpdmVcbiAgICBpZiAoZGF0YS5zaGFwZXMgJiYgZGF0YS5zaGFwZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlc1swXTtcblxuICAgICAgaWYgKHNoYXBlLml0KSB7XG4gICAgICAgIHZhciBzaGFwZUl0ZW0gPSBzaGFwZS5pdFtzaGFwZS5pdC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc2hhcGVJdGVtLnMpIHtcbiAgICAgICAgICBzaGFwZUl0ZW0ucy5rWzBdID0gc2NhbGU7XG4gICAgICAgICAgc2hhcGVJdGVtLnMua1sxXSA9IHNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsMCwwLDApJyk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKSk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGRvY3VtZW50RGF0YS5zdyk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgZm9udERhdGEuZkNsYXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgIHZhciBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXN0eWxlJywgZlN0eWxlKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC13ZWlnaHQnLCBmV2VpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkb2N1bWVudERhdGEudCk7XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubCB8fCBbXTtcbiAgICB2YXIgdXNlc0dseXBocyA9ICEhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcblxuICAgIGlmIChzaW5nbGVTaGFwZSAmJiAhdXNlc0dseXBocyAmJiAhZG9jdW1lbnREYXRhLnN6KSB7XG4gICAgICB2YXIgdEVsZW1lbnQgPSB0aGlzLnRleHRDb250YWluZXI7XG4gICAgICB2YXIganVzdGlmeSA9ICdzdGFydCc7XG5cbiAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGp1c3RpZnkgPSAnZW5kJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAganVzdGlmeSA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAganVzdGlmeSA9ICdzdGFydCc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCBqdXN0aWZ5KTtcbiAgICAgIHRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbGV0dGVyLXNwYWNpbmcnLCB0cmFja2luZ09mZnNldCk7XG4gICAgICB2YXIgdGV4dENvbnRlbnQgPSB0aGlzLmJ1aWxkVGV4dENvbnRlbnRzKGRvY3VtZW50RGF0YS5maW5hbFRleHQpO1xuICAgICAgbGVuID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgICAgeVBvcyA9IGRvY3VtZW50RGF0YS5wcyA/IGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQgOiAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIHx8IGNyZWF0ZU5TKCd0c3BhbicpO1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IHRleHRDb250ZW50W2ldO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd5JywgeVBvcyk7XG4gICAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XG4gICAgICAgIHRFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcblxuICAgICAgICBpZiAoIXRoaXMudGV4dFNwYW5zW2ldKSB7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0gPSB7XG4gICAgICAgICAgICBzcGFuOiBudWxsLFxuICAgICAgICAgICAgZ2x5cGg6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhY2hlZFNwYW5zTGVuZ3RoID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgICAgdmFyIGNoYXJEYXRhO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRTcGFuc1tpXSkge1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldID0ge1xuICAgICAgICAgICAgc3BhbjogbnVsbCxcbiAgICAgICAgICAgIGNoaWxkU3BhbjogbnVsbCxcbiAgICAgICAgICAgIGdseXBoOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXNlc0dseXBocyB8fCAhc2luZ2xlU2hhcGUgfHwgaSA9PT0gMCkge1xuICAgICAgICAgIHRTcGFuID0gY2FjaGVkU3BhbnNMZW5ndGggPiBpID8gdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA6IGNyZWF0ZU5TKHVzZXNHbHlwaHMgPyAnZycgOiAndGV4dCcpO1xuXG4gICAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuXG4gICAgICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgICAgICB2YXIgY2hpbGRTcGFuID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICAgICAgdFNwYW4uYXBwZW5kQ2hpbGQoY2hpbGRTcGFuKTtcbiAgICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuID0gY2hpbGRTcGFuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuXG4gICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICAgIGlmIChsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgICAgIHhQb3MgPSAtdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcbiAgICAgICAgICAgIGZpcnN0TGluZSA9IGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xuICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7IC8vIHhQb3MgKz0gbGV0dGVyc1tpXS52YWwgPT09ICcgJyA/IDAgOiB0cmFja2luZ09mZnNldDtcblxuICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlc0dseXBocykge1xuICAgICAgICAgIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xuICAgICAgICAgIHZhciBnbHlwaEVsZW1lbnQ7IC8vIHQgPT09IDEgbWVhbnMgdGhlIGNoYXJhY3RlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGFuIGFuaW1hdGVkIHNoYXBlZFxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIGdseXBoRWxlbWVudCA9IG5ldyBTVkdDb21wRWxlbWVudChjaGFyRGF0YS5kYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGVtcHR5U2hhcGVEYXRhO1xuXG4gICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICBkYXRhID0gdGhpcy5idWlsZFNoYXBlRGF0YShjaGFyRGF0YS5kYXRhLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGhFbGVtZW50ID0gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCkge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gdGhpcy50ZXh0U3BhbnNbaV0uZ2x5cGg7XG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5jaGlsZFNwYW4ucmVtb3ZlQ2hpbGQoZ2x5cGgubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICAgIGdseXBoLmRlc3Ryb3koKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaCA9IGdseXBoRWxlbWVudDtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQuX2RlYnVnID0gdHJ1ZTtcbiAgICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKDApO1xuICAgICAgICAgIGdseXBoRWxlbWVudC5yZW5kZXJGcmFtZSgpO1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5hcHBlbmRDaGlsZChnbHlwaEVsZW1lbnQubGF5ZXJFbGVtZW50KTsgLy8gd2hlbiB1c2luZyBhbmltYXRlZCBzaGFwZXMsIHRoZSBsYXllciB3aWxsIGJlIHNjYWxlZCBpbnN0ZWFkIG9mIHJlcGxhY2luZyB0aGUgaW50ZXJuYWwgc2NhbGVcbiAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGhhdmUgaXNzdWVzIHdpdGggc3Ryb2tlcyBhbmQgbWlnaHQgbmVlZCBhIGRpZmZlcmVudCBzb2x1dGlvblxuXG4gICAgICAgICAgaWYgKGNoYXJEYXRhLnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICdzY2FsZSgnICsgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCArICcsJyArIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgbWF0cml4SGVscGVyLnByb3BzWzEyXSArICcsJyArIG1hdHJpeEhlbHBlci5wcm9wc1sxM10gKyAnKScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcbiAgICAgICAgfSAvL1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzaW5nbGVTaGFwZSAmJiB0U3Bhbikge1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmVwYXJlRnJhbWUodGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmRhdGEuc3QpO1xuICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICBpZiAodGhpcy5fc2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgdGV4dEJveCA9IHRoaXMubGF5ZXJFbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHRoaXMuYmJveCA9IHtcbiAgICAgICAgdG9wOiB0ZXh0Qm94LnksXG4gICAgICAgIGxlZnQ6IHRleHRCb3gueCxcbiAgICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYmJveDtcbiAgfTtcblxuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMudGV4dFNwYW5zLmxlbmd0aDtcbiAgICB2YXIgZ2x5cGhFbGVtZW50O1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICBnbHlwaEVsZW1lbnQucHJlcGFyZUZyYW1lKHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5kYXRhLnN0KTtcblxuICAgICAgICBpZiAoZ2x5cGhFbGVtZW50Ll9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcblxuICAgIGlmICghdGhpcy5kYXRhLnNpbmdsZVNoYXBlIHx8IHRoaXMuX21kZikge1xuICAgICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgICAgaWYgKHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnIHx8IHRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgICAgICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XG4gICAgICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgICAgIHZhciB0ZXh0U3BhbjtcbiAgICAgICAgdmFyIGdseXBoRWxlbWVudDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldLnNwYW47XG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcblxuICAgICAgICAgICAgaWYgKGdseXBoRWxlbWVudCkge1xuICAgICAgICAgICAgICBnbHlwaEVsZW1lbnQucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYubSkge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5vKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHJlbmRlcmVkTGV0dGVyLm8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHJlbmRlcmVkTGV0dGVyLnN3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UnLCByZW5kZXJlZExldHRlci5zYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJlbmRlcmVkTGV0dGVyLmZjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSUltYWdlRWxlbWVudF0sIElTb2xpZEVsZW1lbnQpO1xuXG4gIElTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpOyAvLy8gL3JlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3c7XG4gICAgLy8vIC9yZWN0LnN0eWxlLmhlaWdodCA9IHRoaXMuZGF0YS5zaDtcbiAgICAvLy8gL3JlY3Quc3R5bGUuZmlsbCA9IHRoaXMuZGF0YS5zYztcblxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE51bGxFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICB9XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG5cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnNvdXJjZVJlY3RBdFRpbWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIE51bGxFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlckJhc2UoKSB7fVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSwgU1ZHUmVuZGVyZXJCYXNlKTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgTnVsbEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBTVkdUZXh0TG90dGllRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxuczp4bGluaycsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcudmlld0JveFNpemUpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwICcgKyBhbmltRGF0YS53ICsgJyAnICsgYW5pbURhdGEuaCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy53aWR0aCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLnJlbmRlckNvbmZpZy53aWR0aCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmhlaWdodCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5yZW5kZXJDb25maWcuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsIHRoaXMucmVuZGVyQ29uZmlnLmZvY3VzYWJsZSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pOyAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAvLyB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmxheWVyRWxlbWVudC5zdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IFwiMHB4IDBweCAwcHhcIjtcblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7IC8vIE1hc2sgYW5pbWF0aW9uXG5cbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkZWZzKTtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICAgIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICBtYXNrRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbWFza0lkICsgJyknKTtcbiAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycyA/IHRoaXMubGF5ZXJzLmxlbmd0aCA6IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS51cGRhdGVDb250YWluZXJTaXplID0gZnVuY3Rpb24gKCkge307XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5maW5kSW5kZXhCeUluZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmluZCA9PT0gaW5kKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgaWYgKGVsZW1lbnRzW3Bvc10gfHwgdGhpcy5sYXllcnNbcG9zXS50eSA9PT0gOTkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50c1twb3NdID0gdHJ1ZTtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcblxuICAgIGlmIChnZXRFeHByZXNzaW9uc1BsdWdpbigpKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIH1cblxuICAgIHRoaXMuYXBwZW5kRWxlbWVudEluUG9zKGVsZW1lbnQsIHBvcyk7XG5cbiAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50dCkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gdGhpcy5sYXllcnNbcG9zXSA/IHRoaXMuZmluZEluZGV4QnlJbmQodGhpcy5sYXllcnNbcG9zXS50cCkgOiBwb3MgLSAxO1xuXG4gICAgICBpZiAoZWxlbWVudEluZGV4ID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdIHx8IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJ1aWxkSXRlbShlbGVtZW50SW5kZXgpO1xuICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IGVsZW1lbnRzW2VsZW1lbnRJbmRleF07XG4gICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbcG9zXS50dCk7XG4gICAgICAgIGVsZW1lbnQuc2V0TWF0dGUobWF0dGVNYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuXG4gICAgICBpZiAoZWxlbWVudC5kYXRhLnR0KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gPT09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5kZXggPSAndHAnIGluIGVsZW1lbnQuZGF0YSA/IHRoaXMuZmluZEluZGV4QnlJbmQoZWxlbWVudC5kYXRhLnRwKSA6IGkgLSAxO1xuICAgICAgICAgICAgdmFyIG1hdHRlRWxlbWVudCA9IHRoaXMuZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgICAgIHZhciBtYXR0ZU1hc2sgPSBtYXR0ZUVsZW1lbnQuZ2V0TWF0dGUodGhpcy5sYXllcnNbaV0udHQpO1xuICAgICAgICAgICAgZWxlbWVudC5zZXRNYXR0ZShtYXR0ZU1hc2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtIHx8IHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG51bSA9PT0gbnVsbCkge1xuICAgICAgbnVtID0gdGhpcy5yZW5kZXJlZEZyYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgfSAvLyBjb25zb2xlLmxvZygnLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdGUkFNRSAnLG51bSk7XG5cblxuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZU51bSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbmV4dEVsZW1lbnQ7XG5cbiAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCkpIHtcbiAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gSUNvbXBFbGVtZW50KCkge31cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUNvbXBFbGVtZW50KTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcblxuICAgIGlmICh0aGlzLmRhdGEueHQgfHwgIWdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XG4gICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGUoKTtcbiAgfTtcbiAgLyogSUNvbXBFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKXtcclxuICAgICAgaWYoIXRoaXMuaGlkZGVuKXtcclxuICAgICAgICAgIHRoaXMuaGlkZUVsZW1lbnQoKTtcclxuICAgICAgICAgIHZhciBpLGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xyXG4gICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmhpZGUoKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgIH1cclxuICB9OyAqL1xuXG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbiAobnVtKSB7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5wcmVwYXJlUmVuZGVyYWJsZUZyYW1lKG51bSk7XG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcblxuICAgIGlmICghdGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuZGF0YS54dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XG5cbiAgICAgIGlmICh0aW1lUmVtYXBwZWQgPT09IHRoaXMuZGF0YS5vcCkge1xuICAgICAgICB0aW1lUmVtYXBwZWQgPSB0aGlzLmRhdGEub3AgLSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bSAvIHRoaXMuZGF0YS5zcjtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnModGhpcy5yZW5kZXJlZEZyYW1lKTtcbiAgICB9IC8vIFRoaXMgaXRlcmF0aW9uIG5lZWRzIHRvIGJlIGJhY2t3YXJkcyBiZWNhdXNlIG9mIGhvdyBleHByZXNzaW9ucyBjb25uZWN0IGJldHdlZW4gZWFjaCBvdGhlclxuXG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmxheWVyc1tpXS5zdCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbXM7XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50cztcbiAgfTtcblxuICBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVzdHJveUVsZW1lbnRzKCk7XG4gICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmxheWVycyA/IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5sYXllcnMubGVuZ3RoKSA6IFtdO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2UsIElDb21wRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnRdLCBTVkdDb21wRWxlbWVudCk7XG5cbiAgU1ZHQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgdmFyIGFyaWFMYWJlbCA9ICcnO1xuXG4gICAgaWYgKGNvbmZpZyAmJiBjb25maWcudGl0bGUpIHtcbiAgICAgIHZhciB0aXRsZUVsZW1lbnQgPSBjcmVhdGVOUygndGl0bGUnKTtcbiAgICAgIHZhciB0aXRsZUlkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICB0aXRsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRpdGxlSWQpO1xuICAgICAgdGl0bGVFbGVtZW50LnRleHRDb250ZW50ID0gY29uZmlnLnRpdGxlO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKHRpdGxlRWxlbWVudCk7XG4gICAgICBhcmlhTGFiZWwgKz0gdGl0bGVJZDtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnICYmIGNvbmZpZy5kZXNjcmlwdGlvbikge1xuICAgICAgdmFyIGRlc2NFbGVtZW50ID0gY3JlYXRlTlMoJ2Rlc2MnKTtcbiAgICAgIHZhciBkZXNjSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIGRlc2NFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkZXNjSWQpO1xuICAgICAgZGVzY0VsZW1lbnQudGV4dENvbnRlbnQgPSBjb25maWcuZGVzY3JpcHRpb247XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVzY0VsZW1lbnQpO1xuICAgICAgYXJpYUxhYmVsICs9ICcgJyArIGRlc2NJZDtcbiAgICB9XG5cbiAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBhcmlhTGFiZWwpO1xuICAgIH1cblxuICAgIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbWFza0VsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIG1lZXQnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgY29udGVudFZpc2liaWxpdHk6IGNvbmZpZyAmJiBjb25maWcuY29udGVudFZpc2liaWxpdHkgfHwgJ3Zpc2libGUnLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcbiAgICAgIHZpZXdCb3hPbmx5OiBjb25maWcgJiYgY29uZmlnLnZpZXdCb3hPbmx5IHx8IGZhbHNlLFxuICAgICAgdmlld0JveFNpemU6IGNvbmZpZyAmJiBjb25maWcudmlld0JveFNpemUgfHwgZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBmb2N1c2FibGU6IGNvbmZpZyAmJiBjb25maWcuZm9jdXNhYmxlLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICcxMDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICcxMDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJzAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJzAlJ1xuICAgICAgfSxcbiAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmhlaWdodCxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICBkZWZzOiBkZWZzLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdzdmcnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdSZW5kZXJlckJhc2VdLCBTVkdSZW5kZXJlcik7XG5cbiAgU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKSB7XG4gICAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcbiAgICB0aGlzLnNlcXVlbmNlTGlzdCA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCA9IDA7XG4gIH1cblxuICBTaGFwZVRyYW5zZm9ybU1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIGFkZFRyYW5zZm9ybVNlcXVlbmNlOiBmdW5jdGlvbiBhZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBrZXkgPSAnXyc7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBrZXkgKz0gdHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ua2V5ICsgJ18nO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlc1trZXldO1xuXG4gICAgICBpZiAoIXNlcXVlbmNlKSB7XG4gICAgICAgIHNlcXVlbmNlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKSxcbiAgICAgICAgICBmaW5hbFRyYW5zZm9ybTogbmV3IE1hdHJpeCgpLFxuICAgICAgICAgIF9tZGY6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2VxdWVuY2VzW2tleV0gPSBzZXF1ZW5jZTtcbiAgICAgICAgdGhpcy5zZXF1ZW5jZUxpc3QucHVzaChzZXF1ZW5jZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9LFxuICAgIHByb2Nlc3NTZXF1ZW5jZTogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlKHNlcXVlbmNlLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSBzZXF1ZW5jZS50cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgIHZhciBfbWRmID0gaXNGaXJzdEZyYW1lO1xuXG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAhaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICAgIF9tZGYgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21kZikge1xuICAgICAgICBzZXF1ZW5jZS5maW5hbFRyYW5zZm9ybS5yZXNldCgpO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNlcXVlbmNlLl9tZGYgPSBfbWRmO1xuICAgIH0sXG4gICAgcHJvY2Vzc1NlcXVlbmNlczogZnVuY3Rpb24gcHJvY2Vzc1NlcXVlbmNlcyhpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2VxdWVuY2VMaXN0Lmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc1NlcXVlbmNlKHRoaXMuc2VxdWVuY2VMaXN0W2ldLCBpc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TmV3S2V5OiBmdW5jdGlvbiBnZXROZXdLZXkoKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQgKz0gMTtcbiAgICAgIHJldHVybiAnXycgKyB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQ7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsdW1hTG9hZGVyID0gZnVuY3Rpb24gbHVtYUxvYWRlcigpIHtcbiAgICB2YXIgaWQgPSAnX19sb3R0aWVfZWxlbWVudF9sdW1hX2J1ZmZlcic7XG4gICAgdmFyIGx1bWFCdWZmZXIgPSBudWxsO1xuICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbnVsbDtcbiAgICB2YXIgc3ZnID0gbnVsbDsgLy8gVGhpcyBhbHRlcm5hdGUgc29sdXRpb24gaGFzIGEgc2xpZ2h0IGRlbGF5IGJlZm9yZSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQsIHJlc3VsdGluZyBpbiBhIGZsaWNrZXIgb24gdGhlIGZpcnN0IGZyYW1lLlxuICAgIC8vIEtlZXBpbmcgdGhpcyBoZXJlIGZvciByZWZlcmVuY2UsIGFuZCBpbiB0aGUgZnV0dXJlLCBpZiBvZmZzY3JlZW4gY2FudmFzIHN1cHBvcnRzIHVybCBmaWx0ZXJzLCB0aGlzIGNhbiBiZSB1c2VkLlxuICAgIC8vIEZvciBub3csIG5laXRoZXIgb2YgdGhlbSB3b3JrIGZvciBvZmZzY3JlZW4gY2FudmFzLCBzbyBjYW52YXMgd29ya2VycyBjYW4ndCBzdXBwb3J0IHRoZSBsdW1hIHRyYWNrIG1hdHRlIG1hc2suXG4gICAgLy8gTmFtaW5nIGl0IHNvbHV0aW9uIDIgdG8gbWFyayB0aGUgZXh0cmEgY29tbWVudCBsaW5lcy5cblxuICAgIC8qXHJcbiAgICB2YXIgc3ZnU3RyaW5nID0gW1xyXG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JyxcclxuICAgICAgJzxmaWx0ZXIgaWQ9XCInICsgaWQgKyAnXCI+JyxcclxuICAgICAgJzxmZUNvbG9yTWF0cml4IHR5cGU9XCJtYXRyaXhcIiBjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnM9XCJzUkdCXCIgdmFsdWVzPVwiJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAsICcsXHJcbiAgICAgICcwLjMsIDAuMywgMC4zLCAwLCAwLCAnLFxyXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCwgJyxcclxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAnLFxyXG4gICAgICAnXCIvPicsXHJcbiAgICAgICc8L2ZpbHRlcj4nLFxyXG4gICAgICAnPC9zdmc+JyxcclxuICAgIF0uam9pbignJyk7XHJcbiAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtzdmdTdHJpbmddLCB7IHR5cGU6ICdpbWFnZS9zdmcreG1sJyB9KTtcclxuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUx1bWFTdmdGaWx0ZXIoKSB7XG4gICAgICB2YXIgX3N2ZyA9IGNyZWF0ZU5TKCdzdmcnKTtcblxuICAgICAgdmFyIGZpbCA9IGNyZWF0ZU5TKCdmaWx0ZXInKTtcbiAgICAgIHZhciBtYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICBtYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgICAgbWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIG1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwLCAwLjMsIDAuMywgMC4zLCAwLCAwJyk7XG4gICAgICBmaWwuYXBwZW5kQ2hpbGQobWF0cml4KTtcblxuICAgICAgX3N2Zy5hcHBlbmRDaGlsZChmaWwpO1xuXG4gICAgICBfc3ZnLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCArICdfc3ZnJyk7XG5cbiAgICAgIGlmIChmZWF0dXJlU3VwcG9ydC5zdmdMdW1hSGlkZGVuKSB7XG4gICAgICAgIF9zdmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9zdmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZEx1bWEoKSB7XG4gICAgICBpZiAoIWx1bWFCdWZmZXIpIHtcbiAgICAgICAgc3ZnID0gY3JlYXRlTHVtYVN2Z0ZpbHRlcigpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgICAgIGx1bWFCdWZmZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgICBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpOyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgICBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9ICd1cmwoIycgKyBpZCArICcpJztcbiAgICAgICAgbHVtYUJ1ZmZlckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgICAgIGx1bWFCdWZmZXJDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0THVtYShjYW52YXMpIHtcbiAgICAgIGlmICghbHVtYUJ1ZmZlcikge1xuICAgICAgICBsb2FkTHVtYSgpO1xuICAgICAgfVxuXG4gICAgICBsdW1hQnVmZmVyLndpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgbHVtYUJ1ZmZlci5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0OyAvLyBsdW1hQnVmZmVyQ3R4LmZpbHRlciA9IGB1cmwoJyR7dXJsfSNfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJylgOyAvLyBwYXJ0IG9mIHNvbHV0aW9uIDJcblxuICAgICAgbHVtYUJ1ZmZlckN0eC5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gICAgICByZXR1cm4gbHVtYUJ1ZmZlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbG9hZDogbG9hZEx1bWEsXG4gICAgICBnZXQ6IGdldEx1bWFcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKGZlYXR1cmVTdXBwb3J0Lm9mZnNjcmVlbkNhbnZhcykge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgdmFyIGFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsb2FkTHVtYUNhbnZhczogbHVtYUxvYWRlci5sb2FkLFxuICAgICAgZ2V0THVtYUNhbnZhczogbHVtYUxvYWRlci5nZXQsXG4gICAgICBjcmVhdGVDYW52YXM6IGNyZWF0ZUNhbnZhc1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVnaXN0ZXJlZEVmZmVjdHMgPSB7fTtcblxuICBmdW5jdGlvbiBDVkVmZmVjdHMoZWxlbSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtLmRhdGEuZWYgPyBlbGVtLmRhdGEuZWYubGVuZ3RoIDogMDtcbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcblxuICAgICAgaWYgKHJlZ2lzdGVyZWRFZmZlY3RzW3R5cGVdKSB7XG4gICAgICAgIHZhciBFZmZlY3QgPSByZWdpc3RlcmVkRWZmZWN0c1t0eXBlXS5lZmZlY3Q7XG4gICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgRWZmZWN0KGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsdGVyTWFuYWdlcikge1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXJNYW5hZ2VyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmZpbHRlcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XG4gICAgfVxuICB9O1xuXG4gIENWRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlZmZlY3RzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGlkLCBlZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0c1tpZF0gPSB7XG4gICAgICBlZmZlY3Q6IGVmZmVjdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDVk1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgaGFzTWFza3MgPSBmYWxzZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xuICAgICAgICBoYXNNYXNrcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld0RhdGFbaV0gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LCB0aGlzLm1hc2tzUHJvcGVydGllc1tpXSwgMyk7XG4gICAgfVxuXG4gICAgdGhpcy5oYXNNYXNrcyA9IGhhc01hc2tzO1xuXG4gICAgaWYgKGhhc01hc2tzKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkUmVuZGVyYWJsZUNvbXBvbmVudCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBDVk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaGFzTWFza3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICB2YXIgY3R4ID0gdGhpcy5lbGVtZW50LmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgcHQ7XG4gICAgdmFyIHB0cztcbiAgICB2YXIgZGF0YTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcbiAgICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLmludikge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcbiAgICAgICAgICBjdHgubGluZVRvKHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLncsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xuICAgICAgICAgIGN0eC5saW5lVG8oMCwgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XG4gICAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEgPSB0aGlzLnZpZXdEYXRhW2ldLnY7XG4gICAgICAgIHB0ID0gdHJhbnNmb3JtLmFwcGx5VG9Qb2ludEFycmF5KGRhdGEudlswXVswXSwgZGF0YS52WzBdWzFdLCAwKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pO1xuICAgICAgICB2YXIgajtcbiAgICAgICAgdmFyIGpMZW4gPSBkYXRhLl9sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVtqXSwgZGF0YS52W2pdKTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVswXSwgZGF0YS52WzBdKTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocHRzWzBdLCBwdHNbMV0sIHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSh0cnVlKTtcbiAgICBjdHguY2xpcCgpO1xuICB9O1xuXG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XG5cbiAgQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWQmFzZUVsZW1lbnQoKSB7fVxuXG4gIHZhciBvcGVyYXRpb25zTWFwID0ge1xuICAgIDE6ICdzb3VyY2UtaW4nLFxuICAgIDI6ICdzb3VyY2Utb3V0JyxcbiAgICAzOiAnc291cmNlLWluJyxcbiAgICA0OiAnc291cmNlLW91dCdcbiAgfTtcbiAgQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY3JlYXRlRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRzKCkge30sXG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHt9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIC8vIElmIHRoZSBsYXllciBpcyBtYXNrZWQgd2Ugd2lsbCB1c2UgdHdvIGJ1ZmZlcnMgdG8gc3RvcmUgZWFjaCBkaWZmZXJlbnQgc3RhdGVzIG9mIHRoZSBkcmF3aW5nXG4gICAgICAvLyBUaGlzIHNvbHV0aW9uIGlzIG5vdCBpZGVhbCBmb3Igc2V2ZXJhbCByZWFzb24uIEJ1dCB1bmZvcnR1bmF0ZWx5LCBiZWNhdXNlIG9mIHRoZSByZWN1cnNpdmVcbiAgICAgIC8vIG5hdHVyZSBvZiB0aGUgcmVuZGVyIHRyZWUsIGl0J3MgdGhlIG9ubHkgc2ltcGxlIHdheSB0byBtYWtlIHN1cmUgb25lIGlubmVyIG1hc2sgZG9lc24ndCBvdmVycmlkZSBhbiBvdXRlciBtYXNrLlxuICAgICAgLy8gVE9ETzogdHJ5IHRvIHJlZHVjZSB0aGUgc2l6ZSBvZiB0aGVzZSBidWZmZXJzIHRvIHRoZSBzaXplIG9mIHRoZSBjb21wb3NpdGlvbiBjb250YW5pbmcgdGhlIGxheWVyXG4gICAgICAvLyBJdCBtaWdodCBiZSBjaGFsbGVuZ2luZyBiZWNhdXNlIHRoZSBsYXllciBtb3N0IGxpa2VseSBpcyB0cmFuc2Zvcm1lZCBpbiBzb21lIHdheVxuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB2YXIgY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzID0gYXNzZXRMb2FkZXIuY3JlYXRlQ2FudmFzKGNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoLCBjYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXJDYW52YXMpO1xuICAgICAgICB2YXIgYnVmZmVyQ2FudmFzMiA9IGFzc2V0TG9hZGVyLmNyZWF0ZUNhbnZhcyhjYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aCwgY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyQ2FudmFzMik7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAzICYmICFkb2N1bWVudC5faXNQcm94eSkge1xuICAgICAgICAgIGFzc2V0TG9hZGVyLmxvYWRMdW1hQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXM7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XG4gICAgICB0aGlzLnNlYXJjaEVmZmVjdFRyYW5zZm9ybXMoKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRlbnQoKSB7fSxcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uIHNldEJsZW5kTW9kZSgpIHtcbiAgICAgIHZhciBnbG9iYWxEYXRhID0gdGhpcy5nbG9iYWxEYXRhO1xuXG4gICAgICBpZiAoZ2xvYmFsRGF0YS5ibGVuZE1vZGUgIT09IHRoaXMuZGF0YS5ibSkge1xuICAgICAgICBnbG9iYWxEYXRhLmJsZW5kTW9kZSA9IHRoaXMuZGF0YS5ibTtcbiAgICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gZ2V0QmxlbmRNb2RlKHRoaXMuZGF0YS5ibSk7XG4gICAgICAgIGdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBibGVuZE1vZGVWYWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbiBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpIHtcbiAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1FZmZlY3RzID0gdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIuZ2V0RWZmZWN0cyhlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUKTtcbiAgICB9LFxuICAgIGhpZGVFbGVtZW50OiBmdW5jdGlvbiBoaWRlRWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3dFbGVtZW50OiBmdW5jdGlvbiBzaG93RWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5SYW5nZSAmJiAhdGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFza01hbmFnZXIuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhckNhbnZhczogZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzQ29udGV4dCkge1xuICAgICAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QodGhpcy50cmFuc2Zvcm1DYW52YXMudHgsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53ICogdGhpcy50cmFuc2Zvcm1DYW52YXMuc3gsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSk7XG4gICAgfSxcbiAgICBwcmVwYXJlTGF5ZXI6IGZ1bmN0aW9uIHByZXBhcmVMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzBdO1xuICAgICAgICB2YXIgYnVmZmVyQ3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXMoYnVmZmVyQ3R4KTsgLy8gb24gdGhlIGZpcnN0IGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcblxuICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApOyAvLyBUaGUgbmV4dCBmb3VyIGxpbmVzIGFyZSB0byBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIGNsZWFyIHRoZSBjYW52YXMgd2l0aG91dCByZXNldHRpbmcgdGhlIHRyYW5zZm9ybVxuXG4gICAgICAgIHRoaXMuY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuY2FudmFzQ29udGV4dC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMuY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBleGl0TGF5ZXI6IGZ1bmN0aW9uIGV4aXRMYXllcigpIHtcbiAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMSkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzWzFdOyAvLyBPbiB0aGUgc2Vjb25kIGJ1ZmZlciB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZ2xvYmFsIGRyYXdpbmdcbiAgICAgICAgLy8gdGhhdCBvbmx5IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXJcbiAgICAgICAgLy8gKGlmIGl0IGlzIGEgY29tcG9zaXRpb24sIGl0IGFsc28gaW5jbHVkZXMgdGhlIG5lc3RlZCBsYXllcnMpXG5cbiAgICAgICAgdmFyIGJ1ZmZlckN0eCA9IGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKGJ1ZmZlckN0eCk7XG4gICAgICAgIGJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7IC8vIFdlIGNsZWFyIHRoZSBjYW52YXMgYWdhaW5cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgZHJhdyB0aGUgbWFza1xuXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5jb21wLmdldEVsZW1lbnRCeUlkKCd0cCcgaW4gdGhpcy5kYXRhID8gdGhpcy5kYXRhLnRwIDogdGhpcy5kYXRhLmluZCAtIDEpO1xuICAgICAgICBtYXNrLnJlbmRlckZyYW1lKHRydWUpOyAvLyBXZSBkcmF3IHRoZSBzZWNvbmQgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgbGF5ZXIpXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTsgLy8gSWYgdGhlIG1hc2sgaXMgYSBMdW1hIG1hdHRlLCB3ZSBuZWVkIHRvIGRvIHR3byBleHRyYSBwYWludGluZyBvcGVyYXRpb25zXG4gICAgICAgIC8vIHRoZSBfaXNQcm94eSBjaGVjayBpcyB0byBhdm9pZCBkcmF3aW5nIGEgZmFrZSBjYW52YXMgaW4gd29ya2VycyB0aGF0IHdpbGwgdGhyb3cgYW4gZXJyb3JcblxuICAgICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDMgJiYgIWRvY3VtZW50Ll9pc1Byb3h5KSB7XG4gICAgICAgICAgLy8gV2UgY29weSB0aGUgcGFpbnRlZCBtYXNrIHRvIGEgYnVmZmVyIHRoYXQgaGFzIGEgY29sb3IgbWF0cml4IGZpbHRlciBhcHBsaWVkIHRvIGl0XG4gICAgICAgICAgLy8gdGhhdCBhcHBsaWVzIHRoZSByZ2IgdmFsdWVzIHRvIHRoZSBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgdmFyIGx1bWFCdWZmZXIgPSBhc3NldExvYWRlci5nZXRMdW1hQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMpO1xuICAgICAgICAgIHZhciBsdW1hQnVmZmVyQ3R4ID0gbHVtYUJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGx1bWFCdWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApO1xuICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXNDb250ZXh0KTsgLy8gd2UgcmVwYWludCB0aGUgY29udGV4dCB3aXRoIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXRcblxuICAgICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UobHVtYUJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gb3BlcmF0aW9uc01hcFt0aGlzLmRhdGEudHRdO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlciwgMCwgMCk7IC8vIFdlIGZpbmFsbHkgZHJhdyB0aGUgZmlyc3QgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBnbG9iYWwgZHJhd2luZylcbiAgICAgICAgLy8gV2UgdXNlIGRlc3RpbmF0aW9uLW92ZXIgdG8gZHJhdyB0aGUgZ2xvYmFsIGRyYXdpbmcgYmVsb3cgdGhlIGN1cnJlbnQgbGF5ZXJcblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuYnVmZmVyc1swXSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTsgLy8gV2UgcmVzZXQgdGhlIGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiB0byBzb3VyY2Utb3ZlciwgdGhlIHN0YW5kYXJkIHR5cGUgb2Ygb3BlcmF0aW9uXG5cbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24gcmVuZGVyRnJhbWUoZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmICh0aGlzLmhpZGRlbiB8fCB0aGlzLmRhdGEuaGQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRkID09PSAxICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcbiAgICAgIHRoaXMucmVuZGVyTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB2YXIgZm9yY2VSZWFsU3RhY2sgPSB0aGlzLmRhdGEudHkgPT09IDA7XG4gICAgICB0aGlzLnByZXBhcmVMYXllcigpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUoZm9yY2VSZWFsU3RhY2spO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eFRyYW5zZm9ybSh0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0LnByb3BzKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhPcGFjaXR5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxPcGFjaXR5KTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZShmb3JjZVJlYWxTdGFjayk7XG4gICAgICB0aGlzLmV4aXRMYXllcigpO1xuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlci5oYXNNYXNrcykge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XG4gIENWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcblxuICBmdW5jdGlvbiBDVlNoYXBlRGF0YShlbGVtZW50LCBkYXRhLCBzdHlsZXMsIHRyYW5zZm9ybXNNYW5hZ2VyKSB7XG4gICAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcbiAgICB0aGlzLnRyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciB0eSA9IDQ7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3JjJykge1xuICAgICAgdHkgPSA1O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2VsJykge1xuICAgICAgdHkgPSA2O1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ3NyJykge1xuICAgICAgdHkgPSA3O1xuICAgIH1cblxuICAgIHRoaXMuc2ggPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AoZWxlbWVudCwgZGF0YSwgdHksIGVsZW1lbnQpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIHZhciBzdHlsZWRTaGFwZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XG4gICAgICAgIHN0eWxlZFNoYXBlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHN0eWxlc1tpXS50cmFuc2Zvcm1zKSxcbiAgICAgICAgICB0ck5vZGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcbiAgICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIENWU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkO1xuXG4gIGZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gW107XG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIgPSBuZXcgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyKCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIElTaGFwZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNoYXBlRWxlbWVudCk7XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnRyYW5zZm9ybUhlbHBlciA9IHtcbiAgICBvcGFjaXR5OiAxLFxuICAgIF9vcE1kZjogZmFsc2VcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRhc2hSZXNldHRlciA9IFtdO1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCB0cmFuc2Zvcm1zKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IHtcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICB0eXBlOiBkYXRhLnR5LFxuICAgICAgcHJlVHJhbnNmb3JtczogdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5hZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKSxcbiAgICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgICAgZWxlbWVudHM6IFtdLFxuICAgICAgY2xvc2VkOiBkYXRhLmhkID09PSB0cnVlXG4gICAgfTtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7fTtcblxuICAgIGlmIChkYXRhLnR5ID09PSAnZmwnIHx8IGRhdGEudHkgPT09ICdzdCcpIHtcbiAgICAgIGVsZW1lbnREYXRhLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEuYy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzJdKSArICcpJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgZWxlbWVudERhdGEucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgICBlbGVtZW50RGF0YS5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmggfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XG4gICAgfVxuXG4gICAgZWxlbWVudERhdGEubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEubywgMCwgMC4wMSwgdGhpcyk7XG5cbiAgICBpZiAoZGF0YS50eSA9PT0gJ3N0JyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICBzdHlsZUVsZW0ubGMgPSBsaW5lQ2FwRW51bVtkYXRhLmxjIHx8IDJdO1xuICAgICAgc3R5bGVFbGVtLmxqID0gbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl07XG5cbiAgICAgIGlmIChkYXRhLmxqID09IDEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgc3R5bGVFbGVtLm1sID0gZGF0YS5tbDtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudERhdGEudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG5cbiAgICAgIGlmICghZWxlbWVudERhdGEudy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS53aSA9IGVsZW1lbnREYXRhLncudjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuZCkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXNoUHJvcGVydHkodGhpcywgZGF0YS5kLCAnY2FudmFzJywgdGhpcyk7XG4gICAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xuXG4gICAgICAgIGlmICghZWxlbWVudERhdGEuZC5rKSB7XG4gICAgICAgICAgc3R5bGVFbGVtLmRhID0gZWxlbWVudERhdGEuZC5kYXNoQXJyYXk7XG4gICAgICAgICAgc3R5bGVFbGVtW1wiZG9cIl0gPSBlbGVtZW50RGF0YS5kLmRhc2hvZmZzZXRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtLnIgPSBkYXRhLnIgPT09IDIgPyAnZXZlbm9kZCcgOiAnbm9uemVybyc7XG4gICAgfVxuXG4gICAgdGhpcy5zdHlsZXNMaXN0LnB1c2goc3R5bGVFbGVtKTtcbiAgICBlbGVtZW50RGF0YS5zdHlsZSA9IHN0eWxlRWxlbTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XG4gICAgICBpdDogW10sXG4gICAgICBwcmV2Vmlld0RhdGE6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IHtcbiAgICAgIHRyYW5zZm9ybToge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBfb3BNZGY6IGZhbHNlLFxuICAgICAgICBrZXk6IHRoaXMudHJhbnNmb3Jtc01hbmFnZXIuZ2V0TmV3S2V5KCksXG4gICAgICAgIG9wOiBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpLFxuICAgICAgICBtUHJvcHM6IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCBkYXRhLCB0aGlzKVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBDVlNoYXBlRGF0YSh0aGlzLCBkYXRhLCB0aGlzLnN0eWxlc0xpc3QsIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIpO1xuICAgIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnByZXZWaWV3RGF0YVtpXSA9IHRoaXMuaXRlbXNEYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gICAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xuICAgIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIucHJvY2Vzc1NlcXVlbmNlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybUZyb21TdHlsZUxpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNsb3NlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNlYXJjaFNoYXBlcyA9IGZ1bmN0aW9uIChhcnIsIGl0ZW1zRGF0YSwgcHJldlZpZXdEYXRhLCBzaG91bGRSZW5kZXIsIHRyYW5zZm9ybXMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIG93blN0eWxlcyA9IFtdO1xuICAgIHZhciBvd25Nb2RpZmllcnMgPSBbXTtcbiAgICB2YXIgcHJvY2Vzc2VkUG9zO1xuICAgIHZhciBtb2RpZmllcjtcbiAgICB2YXIgY3VycmVudFRyYW5zZm9ybTtcbiAgICB2YXIgb3duVHJhbnNmb3JtcyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKTtcblxuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuXG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3Nob3VsZFJlbmRlciA9IHNob3VsZFJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFycltpXS50eSA9PT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT09ICdzdCcgfHwgYXJyW2ldLnR5ID09PSAnZ2YnIHx8IGFycltpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU3R5bGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldLnN0eWxlLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGFbal0gPSBpdGVtc0RhdGFbaV0uaXRbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgb3duVHJhbnNmb3Jtcyk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBjdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duVHJhbnNmb3Jtcy5wdXNoKGl0ZW1zRGF0YVtpXSk7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QoaXRlbXNEYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0bScgfHwgYXJyW2ldLnR5ID09PSAncmQnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XG4gICAgICAgICAgbW9kaWZpZXIuaW5pdCh0aGlzLCBhcnIsIGksIGl0ZW1zRGF0YSk7XG4gICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RpZmllciA9IGl0ZW1zRGF0YVtpXTtcbiAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0KCk7XG4gICAgdGhpcy5jbG9zZVN0eWxlcyhvd25TdHlsZXMpO1xuICAgIGxlbiA9IG93bk1vZGlmaWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLl9vcE1kZiA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgdGhpcy5yZW5kZXJTaGFwZSh0aGlzLnRyYW5zZm9ybUhlbHBlciwgdGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdHJ1ZSk7XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlVHJhbnNmb3JtID0gZnVuY3Rpb24gKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICBpZiAocGFyZW50VHJhbnNmb3JtLl9vcE1kZiB8fCBncm91cFRyYW5zZm9ybS5vcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSA9IHBhcmVudFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSAqPSBncm91cFRyYW5zZm9ybS5vcC52O1xuICAgICAgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRyYXdMYXllciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgZWxlbXM7XG4gICAgdmFyIG5vZGVzO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlcjtcbiAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIHR5cGU7XG4gICAgdmFyIGN1cnJlbnRTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xuICAgICAgdHlwZSA9IGN1cnJlbnRTdHlsZS50eXBlOyAvLyBTa2lwcGluZyBzdHlsZSB3aGVuXG4gICAgICAvLyBTdHJva2Ugd2lkdGggZXF1YWxzIDBcbiAgICAgIC8vIHN0eWxlIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgKGV4dHJhIHVudXNlZCByZXBlYXRlcnMpXG4gICAgICAvLyBjdXJyZW50IG9wYWNpdHkgZXF1YWxzIDBcbiAgICAgIC8vIGdsb2JhbCBvcGFjaXR5IGVxdWFscyAwXG5cbiAgICAgIGlmICghKCh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpICYmIGN1cnJlbnRTdHlsZS53aSA9PT0gMCB8fCAhY3VycmVudFN0eWxlLmRhdGEuX3Nob3VsZFJlbmRlciB8fCBjdXJyZW50U3R5bGUuY29PcCA9PT0gMCB8fCB0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhID09PSAwKSkge1xuICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgIGVsZW1zID0gY3VycmVudFN0eWxlLmVsZW1lbnRzO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZSh0eXBlID09PSAnc3QnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZCk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKGN1cnJlbnRTdHlsZS53aSk7IC8vIGN0eC5saW5lV2lkdGggPSBjdXJyZW50U3R5bGUud2k7XG5cbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lQ2FwKGN1cnJlbnRTdHlsZS5sYyk7IC8vIGN0eC5saW5lQ2FwID0gY3VycmVudFN0eWxlLmxjO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TGluZUpvaW4oY3VycmVudFN0eWxlLmxqKTsgLy8gY3R4LmxpbmVKb2luID0gY3VycmVudFN0eWxlLmxqO1xuXG4gICAgICAgICAgcmVuZGVyZXIuY3R4TWl0ZXJMaW1pdChjdXJyZW50U3R5bGUubWwgfHwgMCk7IC8vIGN0eC5taXRlckxpbWl0ID0gY3VycmVudFN0eWxlLm1sIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4RmlsbFN0eWxlKHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkKTsgLy8gY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIuY3R4T3BhY2l0eShjdXJyZW50U3R5bGUuY29PcCk7XG5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdzdCcgJiYgdHlwZSAhPT0gJ2dzJykge1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XG4gICAgICAgIGpMZW4gPSBlbGVtcy5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2goY3VycmVudFN0eWxlLmRhKTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3VycmVudFN0eWxlW1wiZG9cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbm9kZXMgPSBlbGVtc1tqXS50ck5vZGVzO1xuICAgICAgICAgIGtMZW4gPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNba10udCA9PT0gJ20nKSB7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZXNba10ucFswXSwgbm9kZXNba10ucFsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5vZGVzW2tdLnQgPT09ICdjJykge1xuICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhub2Rlc1trXS5wdHNbMF0sIG5vZGVzW2tdLnB0c1sxXSwgbm9kZXNba10ucHRzWzJdLCBub2Rlc1trXS5wdHNbM10sIG5vZGVzW2tdLnB0c1s0XSwgbm9kZXNba10ucHRzWzVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSB7XG4gICAgICAgICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5kYXNoUmVzZXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlICE9PSAnc3QnICYmIHR5cGUgIT09ICdncycpIHtcbiAgICAgICAgICAvLyBjdHguZmlsbChjdXJyZW50U3R5bGUucik7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGwoY3VycmVudFN0eWxlLnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBpdGVtcywgZGF0YSwgaXNNYWluKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIGdyb3VwVHJhbnNmb3JtO1xuICAgIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xuXG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKGl0ZW1zW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGdyb3VwVHJhbnNmb3JtID0gZGF0YVtpXS50cmFuc2Zvcm07XG4gICAgICAgIHRoaXMucmVuZGVyU2hhcGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnc2gnIHx8IGl0ZW1zW2ldLnR5ID09PSAnZWwnIHx8IGl0ZW1zW2ldLnR5ID09PSAncmMnIHx8IGl0ZW1zW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIHRoaXMucmVuZGVyUGF0aChpdGVtc1tpXSwgZGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAnZmwnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICB0aGlzLnJlbmRlclN0cm9rZShpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dmJyB8fCBpdGVtc1tpXS50eSA9PT0gJ2dzJykge1xuICAgICAgICB0aGlzLnJlbmRlckdyYWRpZW50RmlsbChpdGVtc1tpXSwgZGF0YVtpXSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICB0aGlzLnJlbmRlclNoYXBlKGdyb3VwVHJhbnNmb3JtLCBpdGVtc1tpXS5pdCwgZGF0YVtpXS5pdCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5ID09PSAndG0nKSB7Ly9cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNNYWluKSB7XG4gICAgICB0aGlzLmRyYXdMYXllcigpO1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU3R5bGVkU2hhcGUgPSBmdW5jdGlvbiAoc3R5bGVkU2hhcGUsIHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCBzaGFwZS5fbWRmIHx8IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuX21kZikge1xuICAgICAgdmFyIHNoYXBlTm9kZXMgPSBzdHlsZWRTaGFwZS50ck5vZGVzO1xuICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHM7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuID0gcGF0aHMuX2xlbmd0aDtcbiAgICAgIHNoYXBlTm9kZXMubGVuZ3RoID0gMDtcbiAgICAgIHZhciBncm91cFRyYW5zZm9ybU1hdCA9IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm07XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgdmFyIHBhdGhOb2RlcyA9IHBhdGhzLnNoYXBlc1tqXTtcblxuICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy52KSB7XG4gICAgICAgICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICAgIHA6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9Qb2ludEFycmF5KHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHQ6ICdjJyxcbiAgICAgICAgICAgICAgcHRzOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvVHJpcGxlUG9pbnRzKHBhdGhOb2Rlcy5vW2kgLSAxXSwgcGF0aE5vZGVzLmlbaV0sIHBhdGhOb2Rlcy52W2ldKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuKSB7XG4gICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICB0OiAnYycsXG4gICAgICAgICAgICAgIHB0czogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1RyaXBsZVBvaW50cyhwYXRoTm9kZXMub1tpIC0gMV0sIHBhdGhOb2Rlcy5pWzBdLCBwYXRoTm9kZXMudlswXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ3onXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3R5bGVkU2hhcGUudHJOb2RlcyA9IHNoYXBlTm9kZXM7XG4gICAgfVxuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBpdGVtRGF0YSkge1xuICAgIGlmIChwYXRoRGF0YS5oZCAhPT0gdHJ1ZSAmJiBwYXRoRGF0YS5fc2hvdWxkUmVuZGVyKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBpdGVtRGF0YS5zdHlsZWRTaGFwZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdHlsZWRTaGFwZShpdGVtRGF0YS5zdHlsZWRTaGFwZXNbaV0sIGl0ZW1EYXRhLnNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZpbGwgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG5cbiAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICAgIH1cbiAgfTtcblxuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24gKHN0eWxlRGF0YSwgaXRlbURhdGEsIGdyb3VwVHJhbnNmb3JtKSB7XG4gICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xuICAgIHZhciBncmQ7XG5cbiAgICBpZiAoIXN0eWxlRWxlbS5ncmQgfHwgaXRlbURhdGEuZy5fbWRmIHx8IGl0ZW1EYXRhLnMuX21kZiB8fCBpdGVtRGF0YS5lLl9tZGYgfHwgc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xuICAgICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcblxuICAgICAgaWYgKHN0eWxlRGF0YS50ID09PSAxKSB7XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwdDFbMF0sIHB0MVsxXSwgcHQyWzBdLCBwdDJbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnY7XG5cbiAgICAgICAgaWYgKHBlcmNlbnQgPj0gMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAwLjk5O1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcbiAgICAgICAgICBwZXJjZW50ID0gLTAuOTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlzdCA9IHJhZCAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCBwdDFbMF0sIHB0MVsxXSwgcmFkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc3R5bGVEYXRhLmcucDtcbiAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xuICAgICAgdmFyIG9wYWNpdHkgPSAxO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZW1EYXRhLmcuX2hhc09wYWNpdHkgJiYgaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICBvcGFjaXR5ID0gaXRlbURhdGEuZy5vW2kgKiAyICsgMV07XG4gICAgICAgIH1cblxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNWYWx1ZXNbaSAqIDRdIC8gMTAwLCAncmdiYSgnICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRWxlbS5ncmQgPSBncmQ7XG4gICAgfVxuXG4gICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYgKiBncm91cFRyYW5zZm9ybS5vcGFjaXR5O1xuICB9O1xuXG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHJva2UgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xuXG4gICAgaWYgKGQgJiYgKGQuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICBzdHlsZUVsZW0uZGEgPSBkLmRhc2hBcnJheTtcbiAgICAgIHN0eWxlRWxlbVtcImRvXCJdID0gZC5kYXNob2Zmc2V0WzBdO1xuICAgIH1cblxuICAgIGlmIChpdGVtRGF0YS5jLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKSc7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS53aSA9IGl0ZW1EYXRhLncudjtcbiAgICB9XG4gIH07XG5cbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zaGFwZXNEYXRhID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdGhpcy5pdGVtc0RhdGEubGVuZ3RoID0gMDtcbiAgfTtcblxuICBmdW5jdGlvbiBDVlRleHRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xuICAgIHRoaXMueU9mZnNldCA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3JBbmltID0gZmFsc2U7XG4gICAgdGhpcy5zdHJva2VDb2xvckFuaW0gPSBmYWxzZTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoQW5pbSA9IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlID0gZmFsc2U7XG4gICAgdGhpcy5maWxsID0gZmFsc2U7XG4gICAgdGhpcy5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRSZW5kZXIgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdjYW52YXMnO1xuICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgc3Ryb2tlOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBzV2lkdGg6IDAsXG4gICAgICBmVmFsdWU6ICcnXG4gICAgfTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgSVRleHRFbGVtZW50XSwgQ1ZUZXh0RWxlbWVudCk7XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnRIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IGNyZWF0ZVNpemVkQXJyYXkoZG9jdW1lbnREYXRhLmwgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcbiAgICB2YXIgaGFzRmlsbCA9IGZhbHNlO1xuXG4gICAgaWYgKGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgaGFzRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlcy5maWxsID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWVzLmZpbGwgPSAncmdiYSgwLDAsMCwwKSc7XG4gICAgfVxuXG4gICAgdGhpcy5maWxsID0gaGFzRmlsbDtcbiAgICB2YXIgaGFzU3Ryb2tlID0gZmFsc2U7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBoYXNTdHJva2UgPSB0cnVlO1xuICAgICAgdGhpcy52YWx1ZXMuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XG4gICAgICB0aGlzLnZhbHVlcy5zV2lkdGggPSBkb2N1bWVudERhdGEuc3c7XG4gICAgfVxuXG4gICAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHRoaXMuc3Ryb2tlID0gaGFzU3Ryb2tlO1xuICAgIHRoaXMudmFsdWVzLmZWYWx1ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJyArIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoOyAvLyB0aGlzLnRIZWxwZXIuZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcblxuICAgIHZhciBjaGFyRGF0YTtcbiAgICB2YXIgc2hhcGVEYXRhO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBzaGFwZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIHBhdGhOb2RlcztcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhICYmIGNoYXJEYXRhLmRhdGEgfHwge307XG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgaWYgKHNpbmdsZVNoYXBlICYmIGxldHRlcnNbaV0ubikge1xuICAgICAgICB4UG9zID0gLXRyYWNraW5nT2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xuICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcbiAgICAgIGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDAsIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDApO1xuXG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XG4gICAgICB9XG5cbiAgICAgIGNvbW1hbmRzID0gY3JlYXRlU2l6ZWRBcnJheShqTGVuIC0gMSk7XG4gICAgICB2YXIgY29tbWFuZHNDb3VudGVyID0gMDtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2pdLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAga0xlbiA9IHNoYXBlc1tqXS5rcy5rLmkubGVuZ3RoO1xuICAgICAgICAgIHBhdGhOb2RlcyA9IHNoYXBlc1tqXS5rcy5rO1xuICAgICAgICAgIHBhdGhBcnIgPSBbXTtcblxuICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5vW2sgLSAxXVswXSwgcGF0aE5vZGVzLm9bayAtIDFdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5pW2tdWzBdLCBwYXRoTm9kZXMuaVtrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMuaVtrXVswXSwgcGF0aE5vZGVzLmlba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZba11bMF0sIHBhdGhOb2Rlcy52W2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52W2tdWzBdLCBwYXRoTm9kZXMudltrXVsxXSwgMCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bayAtIDFdWzBdLCBwYXRoTm9kZXMub1trIC0gMV1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pWzBdWzBdLCBwYXRoTm9kZXMuaVswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSk7XG4gICAgICAgICAgY29tbWFuZHNbY29tbWFuZHNDb3VudGVyXSA9IHBhdGhBcnI7XG4gICAgICAgICAgY29tbWFuZHNDb3VudGVyICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sO1xuICAgICAgICB4UG9zICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLmVsZW0gPSBjb21tYW5kcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB7XG4gICAgICAgICAgZWxlbTogY29tbWFuZHNcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY250ICs9IDE7XG4gICAgfVxuICB9O1xuXG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eExpbmVDYXAoJ2J1dHQnKTsgLy8gY3R4LmxpbmVDYXAgPSAnYnV0dCc7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TGluZUpvaW4oJ21pdGVyJyk7IC8vIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG5cbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TWl0ZXJMaW1pdCg0KTsgLy8gY3R4Lm1pdGVyTGltaXQgPSA0O1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuc2luZ2xlU2hhcGUpIHtcbiAgICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIGxhc3RGaWxsID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZSA9IG51bGw7XG4gICAgdmFyIGxhc3RTdHJva2VXID0gbnVsbDtcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tpXTtcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICByZW5kZXJlci5zYXZlKCk7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4VHJhbnNmb3JtKHJlbmRlcmVkTGV0dGVyLnApO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eE9wYWNpdHkocmVuZGVyZWRMZXR0ZXIubyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICBpZiAobGFzdEZpbGwgIT09IHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZShyZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgICAgIGxhc3RGaWxsID0gcmVuZGVyZWRMZXR0ZXIuZmM7IC8vIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RGaWxsICE9PSB0aGlzLnZhbHVlcy5maWxsKSB7XG4gICAgICAgICAgICBsYXN0RmlsbCA9IHRoaXMudmFsdWVzLmZpbGw7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhGaWxsU3R5bGUodGhpcy52YWx1ZXMuZmlsbCk7IC8vIGN0eC5maWxsU3R5bGUgPSB0aGlzLnZhbHVlcy5maWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhGaWxsKCk7IC8vIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAvLy8gY3R4LmZpbGxUZXh0KHRoaXMudGV4dFNwYW5zW2ldLnZhbCwwLDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZVcgIT09IHJlbmRlcmVkTGV0dGVyLnN3KSB7XG4gICAgICAgICAgICAgIGxhc3RTdHJva2VXID0gcmVuZGVyZWRMZXR0ZXIuc3c7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eExpbmVXaWR0aChyZW5kZXJlZExldHRlci5zdyk7IC8vIGN0eC5saW5lV2lkdGggPSByZW5kZXJlZExldHRlci5zdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2VXICE9PSB0aGlzLnZhbHVlcy5zV2lkdGgpIHtcbiAgICAgICAgICAgIGxhc3RTdHJva2VXID0gdGhpcy52YWx1ZXMuc1dpZHRoO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKHRoaXMudmFsdWVzLnNXaWR0aCk7IC8vIGN0eC5saW5lV2lkdGggPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLnNjKSB7XG4gICAgICAgICAgICBpZiAobGFzdFN0cm9rZSAhPT0gcmVuZGVyZWRMZXR0ZXIuc2MpIHtcbiAgICAgICAgICAgICAgbGFzdFN0cm9rZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2VTdHlsZShyZW5kZXJlZExldHRlci5zYyk7IC8vIGN0eC5zdHJva2VTdHlsZSA9IHJlbmRlcmVkTGV0dGVyLnNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZSAhPT0gdGhpcy52YWx1ZXMuc3Ryb2tlKSB7XG4gICAgICAgICAgICBsYXN0U3Ryb2tlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgICAgcmVuZGVyZXIuY3R4U3Ryb2tlU3R5bGUodGhpcy52YWx1ZXMuc3Ryb2tlKTsgLy8gY3R4LnN0cm9rZVN0eWxlID0gdGhpcy52YWx1ZXMuc3Ryb2tlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuXG4gICAgICAgICAgICBmb3IgKGsgPSAyOyBrIDwga0xlbjsgayArPSA2KSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTsgLy8gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgICAgICAgLy8vIGN0eC5zdHJva2VUZXh0KGxldHRlcnNbaV0udmFsLDAsMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENWSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW1nID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRBc3NldCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVkltYWdlRWxlbWVudCk7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaW1nLndpZHRoICYmICh0aGlzLmFzc2V0RGF0YS53ICE9PSB0aGlzLmltZy53aWR0aCB8fCB0aGlzLmFzc2V0RGF0YS5oICE9PSB0aGlzLmltZy5oZWlnaHQpKSB7XG4gICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuYXNzZXREYXRhLnc7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBpbWdXID0gdGhpcy5pbWcud2lkdGg7XG4gICAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcbiAgICAgIHZhciBpbWdSZWwgPSBpbWdXIC8gaW1nSDtcbiAgICAgIHZhciBjYW52YXNSZWwgPSB0aGlzLmFzc2V0RGF0YS53IC8gdGhpcy5hc3NldERhdGEuaDtcbiAgICAgIHZhciB3aWR0aENyb3A7XG4gICAgICB2YXIgaGVpZ2h0Q3JvcDtcbiAgICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcblxuICAgICAgaWYgKGltZ1JlbCA+IGNhbnZhc1JlbCAmJiBwYXIgPT09ICd4TWlkWU1pZCBzbGljZScgfHwgaW1nUmVsIDwgY2FudmFzUmVsICYmIHBhciAhPT0gJ3hNaWRZTWlkIHNsaWNlJykge1xuICAgICAgICBoZWlnaHRDcm9wID0gaW1nSDtcbiAgICAgICAgd2lkdGhDcm9wID0gaGVpZ2h0Q3JvcCAqIGNhbnZhc1JlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoQ3JvcCA9IGltZ1c7XG4gICAgICAgIGhlaWdodENyb3AgPSB3aWR0aENyb3AgLyBjYW52YXNSZWw7XG4gICAgICB9XG5cbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWcsIChpbWdXIC0gd2lkdGhDcm9wKSAvIDIsIChpbWdIIC0gaGVpZ2h0Q3JvcCkgLyAyLCB3aWR0aENyb3AsIGhlaWdodENyb3AsIDAsIDAsIHRoaXMuYXNzZXREYXRhLncsIHRoaXMuYXNzZXREYXRhLmgpO1xuICAgICAgdGhpcy5pbWcgPSBjYW52YXM7XG4gICAgfVxuICB9O1xuXG4gIENWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmltZywgMCwgMCk7XG4gIH07XG5cbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbWcgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU29saWRFbGVtZW50KTtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcbiAgQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZTtcblxuICBDVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxTdHlsZSh0aGlzLmRhdGEuc2MpOyAvLyBjdHguZmlsbFN0eWxlID0gdGhpcy5kYXRhLnNjO1xuXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eEZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTsgLy8gY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuZGF0YS5zdywgdGhpcy5kYXRhLnNoKTtcbiAgICAvL1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyQmFzZSgpIHt9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBDYW52YXNSZW5kZXJlckJhc2UpO1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlSW1hZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhUcmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICBpZiAocHJvcHNbMF0gPT09IDEgJiYgcHJvcHNbMV0gPT09IDAgJiYgcHJvcHNbNF0gPT09IDAgJiYgcHJvcHNbNV0gPT09IDEgJiYgcHJvcHNbMTJdID09PSAwICYmIHByb3BzWzEzXSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzQ29udGV4dC50cmFuc2Zvcm0ocHJvcHNbMF0sIHByb3BzWzFdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgKj0gb3AgPCAwID8gMCA6IG9wO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbFN0eWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eExpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUNhcCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eE1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4RmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGwocnVsZSk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXNldCgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVzdG9yZSA9IGZ1bmN0aW9uIChhY3Rpb25GbGFnKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uRmxhZykge1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmJsZW5kTW9kZSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXN0b3JlKGFjdGlvbkZsYWcpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGU7XG4gICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHZhciBvcmlnaW4gPSAnMHB4IDBweCAwcHgnO1xuICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgY29udGFpbmVyU3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmlkKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMucmVuZGVyQ29uZmlnLmlkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGV4dDtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRleHREYXRhLnNldENvbnRleHQodGhpcy5jYW52YXNDb250ZXh0KTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcyA9IHtcbiAgICAgIHc6IGFuaW1EYXRhLncsXG4gICAgICBoOiBhbmltRGF0YS5oLFxuICAgICAgc3g6IDAsXG4gICAgICBzeTogMCxcbiAgICAgIHR4OiAwLFxuICAgICAgdHk6IDBcbiAgICB9O1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5pc0Rhc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQgPSB0aGlzLnJlbmRlckNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyA9IHRoaXMudHJhbnNmb3JtQ2FudmFzO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHZhciBlbGVtZW50V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQ7XG5cbiAgICBpZiAod2lkdGgpIHtcbiAgICAgIGVsZW1lbnRXaWR0aCA9IHdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBlbGVtZW50V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlciAmJiB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKSB7XG4gICAgICAgIGVsZW1lbnRXaWR0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldFdpZHRoO1xuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudFdpZHRoID0gdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy53aWR0aDtcbiAgICAgICAgZWxlbWVudEhlaWdodCA9IHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoID0gZWxlbWVudFdpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0ICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50UmVsO1xuICAgIHZhciBhbmltYXRpb25SZWw7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5pbmRleE9mKCdtZWV0JykgIT09IC0xIHx8IHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignc2xpY2UnKSAhPT0gLTEpIHtcbiAgICAgIHZhciBwYXIgPSB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLnNwbGl0KCcgJyk7XG4gICAgICB2YXIgZmlsbFR5cGUgPSBwYXJbMV0gfHwgJ21lZXQnO1xuICAgICAgdmFyIHBvcyA9IHBhclswXSB8fCAneE1pZFlNaWQnO1xuICAgICAgdmFyIHhQb3MgPSBwb3Muc3Vic3RyKDAsIDQpO1xuICAgICAgdmFyIHlQb3MgPSBwb3Muc3Vic3RyKDQpO1xuICAgICAgZWxlbWVudFJlbCA9IGVsZW1lbnRXaWR0aCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgICBhbmltYXRpb25SZWwgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaDtcblxuICAgICAgaWYgKGFuaW1hdGlvblJlbCA+IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdtZWV0JyB8fCBhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoeFBvcyA9PT0gJ3hNaWQnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeFBvcyA9PT0gJ3hNYXgnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoeVBvcyA9PT0gJ1lNaWQnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeVBvcyA9PT0gJ1lNYXgnICYmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsIDwgZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoZWxlbWVudEhlaWdodCAtIHRoaXMudHJhbnNmb3JtQ2FudmFzLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy50cmFuc2Zvcm1DYW52YXMudykpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyA9PT0gJ25vbmUnKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy53IC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodCAvICh0aGlzLnRyYW5zZm9ybUNhbnZhcy5oIC8gdGhpcy5yZW5kZXJDb25maWcuZHByKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICB9XG5cbiAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyA9IFt0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgMCwgMCwgMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ksIDAsIDAsIDAsIDAsIDEsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSwgMCwgMV07XG4gICAgLyogdmFyIGksIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRhdGEudHkgPT09IDApe1xyXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9ICovXG5cbiAgICB0aGlzLmN0eFRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZWN0KDAsIDAsIHRoaXMudHJhbnNmb3JtQ2FudmFzLncsIHRoaXMudHJhbnNmb3JtQ2FudmFzLmgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2xpcCgpO1xuICAgIHRoaXMucmVuZGVyRnJhbWUodGhpcy5yZW5kZXJlZEZyYW1lLCB0cnVlKTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICYmIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKG51bSwgZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gJiYgdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUgJiYgIWZvcmNlUmVuZGVyIHx8IHRoaXMuZGVzdHJveWVkIHx8IG51bSA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW07XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtIC0gdGhpcy5hbmltYXRpb25JdGVtLl9pc0ZpcnN0RnJhbWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgKz0gMTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9ICF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyB8fCBmb3JjZVJlbmRlcjtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07IC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcblxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBpZiAoIXRoaXMuY29tcGxldGVMYXllcnMpIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllcnMobnVtKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5idWlsZEl0ZW0gPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcblxuICAgIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZUl0ZW0odGhpcy5sYXllcnNbcG9zXSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcbiAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIC8qIGlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xyXG4gICAgICAgICAgZWxlbWVudC5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICAgIH0gKi9cbiAgfTtcblxuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfVxuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzQ29udGV4dCgpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxNik7XG4gICAgdGhpcy5maWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLnN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5saW5lV2lkdGggPSAnJztcbiAgICB0aGlzLmxpbmVDYXAgPSAnJztcbiAgICB0aGlzLmxpbmVKb2luID0gJyc7XG4gICAgdGhpcy5taXRlckxpbWl0ID0gJyc7XG4gICAgdGhpcy5pZCA9IE1hdGgucmFuZG9tKCk7XG4gIH1cblxuICBmdW5jdGlvbiBDVkNvbnRleHREYXRhKCkge1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyID0gbmV3IE1hdHJpeCgpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSAxNTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNhbnZhc0NvbnRleHQgPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgICAgdGhpcy5zdGFja1tpXSA9IGNhbnZhc0NvbnRleHQ7XG4gICAgfVxuXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xuICAgIHRoaXMubmF0aXZlQ29udGV4dCA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IDE7IC8vXG5cbiAgICB0aGlzLmN1cnJlbnRGaWxsU3R5bGUgPSAnJztcbiAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVXaWR0aCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVXaWR0aCA9ICcnOyAvL1xuXG4gICAgdGhpcy5jdXJyZW50TGluZUNhcCA9ICcnO1xuICAgIHRoaXMuYXBwbGllZExpbmVDYXAgPSAnJzsgLy9cblxuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSAnJzsgLy9cblxuICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSAnJztcbiAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gJyc7XG4gIH1cblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gdGhpcy5fbGVuZ3RoOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3RhY2tbaV0gPSBuZXcgQ2FudmFzQ29udGV4dCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbmd0aCA9IG5ld0xlbmd0aDtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSAxO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnJlc3RvcmUgPSBmdW5jdGlvbiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgdGhpcy5jQXJyUG9zIC09IDE7XG4gICAgdmFyIGN1cnJlbnRDb250ZXh0ID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciB0cmFuc2Zvcm0gPSBjdXJyZW50Q29udGV4dC50cmFuc2Zvcm07XG4gICAgdmFyIGk7XG4gICAgdmFyIGFyciA9IHRoaXMuY1RyLnByb3BzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGFycltpXSA9IHRyYW5zZm9ybVtpXTtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgdmFyIHByZXZTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zICsgMV07XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSBwcmV2U3RhY2suZmlsbFN0eWxlO1xuICAgICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSBwcmV2U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSBwcmV2U3RhY2subGluZVdpZHRoO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9IHByZXZTdGFjay5saW5lQ2FwO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSBwcmV2U3RhY2subGluZUpvaW47XG4gICAgICB0aGlzLmFwcGxpZWRNaXRlckxpbWl0ID0gcHJldlN0YWNrLm1pdGVyTGltaXQ7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0cmFuc2Zvcm1bMF0sIHRyYW5zZm9ybVsxXSwgdHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bNV0sIHRyYW5zZm9ybVsxMl0sIHRyYW5zZm9ybVsxM10pO1xuXG4gICAgaWYgKGZvcmNlUmVzdG9yZSB8fCBjdXJyZW50Q29udGV4dC5vcGFjaXR5ICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRPcGFjaXR5ICE9PSBjdXJyZW50Q29udGV4dC5vcGFjaXR5KSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBjdXJyZW50Q29udGV4dC5vcGFjaXR5O1xuICAgICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50RmlsbFN0eWxlID0gY3VycmVudENvbnRleHQuZmlsbFN0eWxlO1xuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gY3VycmVudENvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gY3VycmVudENvbnRleHQubGluZVdpZHRoO1xuICAgIHRoaXMuY3VycmVudExpbmVDYXAgPSBjdXJyZW50Q29udGV4dC5saW5lQ2FwO1xuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gY3VycmVudENvbnRleHQubGluZUpvaW47XG4gICAgdGhpcy5jdXJyZW50TWl0ZXJMaW1pdCA9IGN1cnJlbnRDb250ZXh0Lm1pdGVyTGltaXQ7XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChzYXZlT25OYXRpdmVGbGFnKSB7XG4gICAgaWYgKHNhdmVPbk5hdGl2ZUZsYWcpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5zYXZlKCk7XG4gICAgfVxuXG4gICAgdmFyIHByb3BzID0gdGhpcy5jVHIucHJvcHM7XG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IHRoaXMuY0FyclBvcykge1xuICAgICAgdGhpcy5kdXBsaWNhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0YWNrID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGN1cnJlbnRTdGFjay50cmFuc2Zvcm1baV0gPSBwcm9wc1tpXTtcbiAgICB9XG5cbiAgICB0aGlzLmNBcnJQb3MgKz0gMTtcbiAgICB2YXIgbmV3U3RhY2sgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgbmV3U3RhY2sub3BhY2l0eSA9IGN1cnJlbnRTdGFjay5vcGFjaXR5O1xuICAgIG5ld1N0YWNrLmZpbGxTdHlsZSA9IGN1cnJlbnRTdGFjay5maWxsU3R5bGU7XG4gICAgbmV3U3RhY2suc3Ryb2tlU3R5bGUgPSBjdXJyZW50U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgbmV3U3RhY2subGluZVdpZHRoID0gY3VycmVudFN0YWNrLmxpbmVXaWR0aDtcbiAgICBuZXdTdGFjay5saW5lQ2FwID0gY3VycmVudFN0YWNrLmxpbmVDYXA7XG4gICAgbmV3U3RhY2subGluZUpvaW4gPSBjdXJyZW50U3RhY2subGluZUpvaW47XG4gICAgbmV3U3RhY2subWl0ZXJMaW1pdCA9IGN1cnJlbnRTdGFjay5taXRlckxpbWl0O1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldE9wYWNpdHkgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSA9IHZhbHVlO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNldENvbnRleHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQgPSB2YWx1ZTtcbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5zdHJva2VTdHlsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10uc3Ryb2tlU3R5bGUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdHJva2VTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLnN0cm9rZVN0eWxlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVXaWR0aCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZVdpZHRoID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVDYXAgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUNhcCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5saW5lSm9pbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUpvaW4gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lSm9pbiA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVKb2luID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm1pdGVyTGltaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm1pdGVyTGltaXQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRNaXRlckxpbWl0ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubWl0ZXJMaW1pdCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC5jbG9uZUZyb21Qcm9wcyhwcm9wcyk7IC8vIFRha2luZyB0aGUgbGFzdCB0cmFuc2Zvcm0gdmFsdWUgZnJvbSB0aGUgc3RvcmVkIHN0YWNrIG9mIHRyYW5zZm9ybXNcblxuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jVHI7IC8vIEFwcGx5aW5nIHRoZSBsYXN0IHRyYW5zZm9ybSB2YWx1ZSBhZnRlciB0aGUgbmV3IHRyYW5zZm9ybSB0byByZXNwZWN0IHRoZSBvcmRlciBvZiB0cmFuc2Zvcm1hdGlvbnNcblxuICAgIHRoaXMudHJhbnNmb3JtTWF0Lm11bHRpcGx5KGN1cnJlbnRUcmFuc2Zvcm0pOyAvLyBTdG9yaW5nIHRoZSBuZXcgdHJhbnNmb3JtZWQgdmFsdWUgaW4gdGhlIHN0b3JlZCB0cmFuc2Zvcm1cblxuICAgIGN1cnJlbnRUcmFuc2Zvcm0uY2xvbmVGcm9tUHJvcHModGhpcy50cmFuc2Zvcm1NYXQucHJvcHMpO1xuICAgIHZhciB0clByb3BzID0gY3VycmVudFRyYW5zZm9ybS5wcm9wczsgLy8gQXBwbHlpbmcgdGhlIG5ldyB0cmFuc2Zvcm0gdG8gdGhlIGNhbnZhc1xuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0clByb3BzWzBdLCB0clByb3BzWzFdLCB0clByb3BzWzRdLCB0clByb3BzWzVdLCB0clByb3BzWzEyXSwgdHJQcm9wc1sxM10pO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLm9wYWNpdHkgPSBmdW5jdGlvbiAob3ApIHtcbiAgICB2YXIgY3VycmVudE9wYWNpdHkgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eTtcbiAgICBjdXJyZW50T3BhY2l0eSAqPSBvcCA8IDAgPyAwIDogb3A7XG5cbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgIT09IGN1cnJlbnRPcGFjaXR5KSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50T3BhY2l0eSAhPT0gb3ApIHtcbiAgICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lmdsb2JhbEFscGhhID0gb3A7XG4gICAgICAgIHRoaXMuY3VycmVudE9wYWNpdHkgPSBvcDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSBjdXJyZW50T3BhY2l0eTtcbiAgICB9XG4gIH07XG5cbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChydWxlKSB7XG4gICAgaWYgKHRoaXMuYXBwbGllZEZpbGxTdHlsZSAhPT0gdGhpcy5jdXJyZW50RmlsbFN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSB0aGlzLmN1cnJlbnRGaWxsU3R5bGU7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5hcHBsaWVkRmlsbFN0eWxlO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsKHJ1bGUpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkRmlsbFN0eWxlICE9PSB0aGlzLmN1cnJlbnRGaWxsU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHRoaXMuY3VycmVudEZpbGxTdHlsZTtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmFwcGxpZWRGaWxsU3R5bGU7XG4gICAgfVxuXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuXG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgIT09IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlKSB7XG4gICAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9IHRoaXMuY3VycmVudFN0cm9rZVN0eWxlO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZExpbmVXaWR0aCAhPT0gdGhpcy5jdXJyZW50TGluZVdpZHRoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSB0aGlzLmN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZVdpZHRoID0gdGhpcy5hcHBsaWVkTGluZVdpZHRoO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFwcGxpZWRMaW5lQ2FwICE9PSB0aGlzLmN1cnJlbnRMaW5lQ2FwKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lQ2FwID0gdGhpcy5jdXJyZW50TGluZUNhcDtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5saW5lQ2FwID0gdGhpcy5hcHBsaWVkTGluZUNhcDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hcHBsaWVkTGluZUpvaW4gIT09IHRoaXMuY3VycmVudExpbmVKb2luKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9IHRoaXMuY3VycmVudExpbmVKb2luO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmxpbmVKb2luID0gdGhpcy5hcHBsaWVkTGluZUpvaW47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYXBwbGllZE1pdGVyTGltaXQgIT09IHRoaXMuY3VycmVudE1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSB0aGlzLmN1cnJlbnRNaXRlckxpbWl0O1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lm1pdGVyTGltaXQgPSB0aGlzLmFwcGxpZWRNaXRlckxpbWl0O1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5zdHJva2UoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBDVkNvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyQmFzZSwgSUNvbXBFbGVtZW50LCBDVkJhc2VFbGVtZW50XSwgQ1ZDb21wRWxlbWVudCk7XG5cbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBDVkNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMuZWxlbWVudHMgPSBudWxsO1xuICB9O1xuXG4gIENWQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGVhckNhbnZhczogY29uZmlnICYmIGNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmNsZWFyQ2FudmFzIDogdHJ1ZSxcbiAgICAgIGNvbnRleHQ6IGNvbmZpZyAmJiBjb25maWcuY29udGV4dCB8fCBudWxsLFxuICAgICAgcHJvZ3Jlc3NpdmVMb2FkOiBjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCB8fCBmYWxzZSxcbiAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgbWVldCcsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBjb250ZW50VmlzaWJpbGl0eTogY29uZmlnICYmIGNvbmZpZy5jb250ZW50VmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaWQ6IGNvbmZpZyAmJiBjb25maWcuaWQgfHwgJycsXG4gICAgICBydW5FeHByZXNzaW9uczogIWNvbmZpZyB8fCBjb25maWcucnVuRXhwcmVzc2lvbnMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucnVuRXhwcmVzc2lvbnNcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IDE7XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgX21kZjogZmFsc2UsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxuICAgICAgY3VycmVudEdsb2JhbEFscGhhOiAtMVxuICAgIH07XG4gICAgdGhpcy5jb250ZXh0RGF0YSA9IG5ldyBDVkNvbnRleHREYXRhKCk7XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy50cmFuc2Zvcm1NYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4VHJhbnNmb3JtID0gdGhpcy5jb250ZXh0RGF0YS50cmFuc2Zvcm0uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4T3BhY2l0eSA9IHRoaXMuY29udGV4dERhdGEub3BhY2l0eS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsU3R5bGUgPSB0aGlzLmNvbnRleHREYXRhLmZpbGxTdHlsZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2VTdHlsZSA9IHRoaXMuY29udGV4dERhdGEuc3Ryb2tlU3R5bGUuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZVdpZHRoID0gdGhpcy5jb250ZXh0RGF0YS5saW5lV2lkdGguYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TGluZUNhcCA9IHRoaXMuY29udGV4dERhdGEubGluZUNhcC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lSm9pbiA9IHRoaXMuY29udGV4dERhdGEubGluZUpvaW4uYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4TWl0ZXJMaW1pdCA9IHRoaXMuY29udGV4dERhdGEubWl0ZXJMaW1pdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhGaWxsID0gdGhpcy5jb250ZXh0RGF0YS5maWxsLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGxSZWN0ID0gdGhpcy5jb250ZXh0RGF0YS5maWxsUmVjdC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhTdHJva2UgPSB0aGlzLmNvbnRleHREYXRhLnN0cm9rZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5zYXZlID0gdGhpcy5jb250ZXh0RGF0YS5zYXZlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtDYW52YXNSZW5kZXJlckJhc2VdLCBDYW52YXNSZW5kZXJlcik7XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEhCYXNlRWxlbWVudCgpIHt9XG5cbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjaGVja0JsZW5kTW9kZTogZnVuY3Rpb24gY2hlY2tCbGVuZE1vZGUoKSB7fSxcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge1xuICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IGNyZWF0ZVRhZyh0aGlzLmRhdGEudGcgfHwgJ2RpdicpO1xuXG4gICAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlRGl2KHRoaXMuYmFzZUVsZW1lbnQpO1xuICAgIH0sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRhdGEuYm0gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckVsZW1lbnQ6IGZ1bmN0aW9uIHJlbmRlckVsZW1lbnQoKSB7XG4gICAgICB2YXIgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUgPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA/IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnN0eWxlIDoge307XG5cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgdmFyIG1hdHJpeFZhbHVlID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tYXQudG9DU1MoKTtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUudHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XG4gICAgICAgIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeFZhbHVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUub3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uIHJlbmRlckZyYW1lKCkge1xuICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICB0aGlzLnJlbmRlckVsZW1lbnQoKTtcbiAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG5cbiAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYXNrTWFuYWdlcikge1xuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24gY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKSB7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICB9LFxuICAgIGFkZEVmZmVjdHM6IGZ1bmN0aW9uIGFkZEVmZmVjdHMoKSB7fSxcbiAgICBzZXRNYXR0ZTogZnVuY3Rpb24gc2V0TWF0dGUoKSB7fVxuICB9O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gU1ZHQmFzZUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50O1xuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3lCYXNlRWxlbWVudCA9IEhCYXNlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveTtcbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZztcblxuICBmdW5jdGlvbiBIU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSFNvbGlkRWxlbWVudCk7XG5cbiAgSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdDtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5zaCk7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuZGF0YS5zYyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS5zdyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgIHJlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3cgKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmRhdGEuc2ggKyAncHgnO1xuICAgICAgcmVjdC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmRhdGEuc2M7XG4gICAgfVxuXG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSFNoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgLy8gTGlzdCBvZiBkcmF3YWJsZSBlbGVtZW50c1xuICAgIHRoaXMuc2hhcGVzID0gW107IC8vIEZ1bGwgc2hhcGUgZGF0YVxuXG4gICAgdGhpcy5zaGFwZXNEYXRhID0gZGF0YS5zaGFwZXM7IC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zdHlsZXNMaXN0ID0gW107IC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuXG4gICAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdOyAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcblxuICAgIHRoaXMuaXRlbXNEYXRhID0gW107IC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxuXG4gICAgdGhpcy5wcm9jZXNzZWRFbGVtZW50cyA9IFtdOyAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcblxuICAgIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xuICAgIHRoaXMuc2hhcGVzQ29udGFpbmVyID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApOyAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxuICAgIC8vIExpc3Qgb2YgZWxlbWVudHMgdGhhdCBoYXZlIGJlZW4gY3JlYXRlZFxuXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRCQm94ID0ge1xuICAgICAgeDogOTk5OTk5LFxuICAgICAgeTogLTk5OTk5OSxcbiAgICAgIGg6IDAsXG4gICAgICB3OiAwXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSFNoYXBlRWxlbWVudCk7XG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLl9yZW5kZXJTaGFwZUZyYW1lID0gSFNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbnQ7XG4gICAgdGhpcy5iYXNlRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IDA7XG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIGNvbnQgPSB0aGlzLnN2Z0VsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuY29tcC5kYXRhID8gdGhpcy5jb21wLmRhdGEgOiB0aGlzLmdsb2JhbERhdGEuY29tcFNpemU7XG4gICAgICBjb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzaXplLncpO1xuICAgICAgY29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNpemUuaCk7XG4gICAgICBjb250LmFwcGVuZENoaWxkKHRoaXMuc2hhcGVzQ29udGFpbmVyKTtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGNvbnQpO1xuICAgIH1cblxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLnNoYXBlc0NvbnRhaW5lciwgMCwgW10sIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XG4gICAgdGhpcy5zaGFwZUNvbnQgPSBjb250O1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbiAodHJhbnNmb3JtZXJzLCBwb2ludCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBwb2ludCA9IHRyYW5zZm9ybWVyc1tpXS5tUHJvcHMudi5hcHBseVRvUG9pbnRBcnJheShwb2ludFswXSwgcG9pbnRbMV0sIDApO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW0sIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIHNoYXBlID0gaXRlbS5zaC52O1xuICAgIHZhciB0cmFuc2Zvcm1lcnMgPSBpdGVtLnRyYW5zZm9ybWVycztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGUuX2xlbmd0aDtcbiAgICB2YXIgdlBvaW50O1xuICAgIHZhciBvUG9pbnQ7XG4gICAgdmFyIG5leHRJUG9pbnQ7XG4gICAgdmFyIG5leHRWUG9pbnQ7XG5cbiAgICBpZiAobGVuIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XG4gICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcbiAgICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xuICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcbiAgICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2kgKyAxXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlLmMpIHtcbiAgICAgIHZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbaV0pO1xuICAgICAgb1BvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUub1tpXSk7XG4gICAgICBuZXh0SVBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUuaVswXSk7XG4gICAgICBuZXh0VlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudlswXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNoZWNrQm91bmRzID0gZnVuY3Rpb24gKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCkge1xuICAgIHRoaXMuZ2V0Qm91bmRzT2ZDdXJ2ZSh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCk7XG4gICAgdmFyIGJvdW5kcyA9IHRoaXMuc2hhcGVCb3VuZGluZ0JveDtcbiAgICBib3VuZGluZ0JveC54ID0gYm1NaW4oYm91bmRzLmxlZnQsIGJvdW5kaW5nQm94LngpO1xuICAgIGJvdW5kaW5nQm94LnhNYXggPSBibU1heChib3VuZHMucmlnaHQsIGJvdW5kaW5nQm94LnhNYXgpO1xuICAgIGJvdW5kaW5nQm94LnkgPSBibU1pbihib3VuZHMudG9wLCBib3VuZGluZ0JveC55KTtcbiAgICBib3VuZGluZ0JveC55TWF4ID0gYm1NYXgoYm91bmRzLmJvdHRvbSwgYm91bmRpbmdCb3gueU1heCk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUudGVtcEJvdW5kaW5nQm94ID0ge1xuICAgIHg6IDAsXG4gICAgeE1heDogMCxcbiAgICB5OiAwLFxuICAgIHlNYXg6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGZ1bmN0aW9uIChwMCwgcDEsIHAyLCBwMykge1xuICAgIHZhciBib3VuZHMgPSBbW3AwWzBdLCBwM1swXV0sIFtwMFsxXSwgcDNbMV1dXTtcblxuICAgIGZvciAodmFyIGEsIGIsIGMsIHQsIGIyYWMsIHQxLCB0MiwgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuICAgICAgYiB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYSB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgYyB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgICAgaWYgKGEgPT09IDAgJiYgYiA9PT0gMCkgey8vXG4gICAgICB9IGVsc2UgaWYgKGEgPT09IDApIHtcbiAgICAgICAgdCA9IC1jIC8gYjtcblxuICAgICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgICBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodCwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuXG4gICAgICAgIGlmIChiMmFjID49IDApIHtcbiAgICAgICAgICB0MSA9ICgtYiArIGJtU3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICAgIGlmICh0MSA+IDAgJiYgdDEgPCAxKSBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodDEsIHAwLCBwMSwgcDIsIHAzLCBpKSk7XG4gICAgICAgICAgdDIgPSAoLWIgLSBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICBpZiAodDIgPiAwICYmIHQyIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQyLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmxlZnQgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMF0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC50b3AgPSBibU1pbi5hcHBseShudWxsLCBib3VuZHNbMV0pO1xuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5yaWdodCA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LmJvdHRvbSA9IGJtTWF4LmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gIH07XG5cbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlRiA9IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMywgaSkge1xuICAgIHJldHVybiBibVBvdygxIC0gdCwgMykgKiBwMFtpXSArIDMgKiBibVBvdygxIC0gdCwgMikgKiB0ICogcDFbaV0gKyAzICogKDEgLSB0KSAqIGJtUG93KHQsIDIpICogcDJbaV0gKyBibVBvdyh0LCAzKSAqIHAzW2ldO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKGl0ZW1zRGF0YSwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gaXRlbXNEYXRhLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc2gpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXSwgYm91bmRpbmdCb3gpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLml0KSB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLml0LCBib3VuZGluZ0JveCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uc3R5bGUgJiYgaXRlbXNEYXRhW2ldLncpIHtcbiAgICAgICAgdGhpcy5leHBhbmRTdHJva2VCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0udywgYm91bmRpbmdCb3gpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5leHBhbmRTdHJva2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICh3aWR0aFByb3BlcnR5LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICBpZiAod2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGhQcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtmdyA9IHdpZHRoUHJvcGVydHkua2V5ZnJhbWVzW2ldLnM7XG5cbiAgICAgICAgaWYgKGtmdyA+IHdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBrZnc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd2lkdGggKj0gd2lkdGhQcm9wZXJ0eS5tdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHdpZHRoUHJvcGVydHkudiAqIHdpZHRoUHJvcGVydHkubXVsdDtcbiAgICB9XG5cbiAgICBib3VuZGluZ0JveC54IC09IHdpZHRoO1xuICAgIGJvdW5kaW5nQm94LnhNYXggKz0gd2lkdGg7XG4gICAgYm91bmRpbmdCb3gueSAtPSB3aWR0aDtcbiAgICBib3VuZGluZ0JveC55TWF4ICs9IHdpZHRoO1xuICB9O1xuXG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRCb3hDb250YWlucyA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50QkJveC54IDw9IGJveC54ICYmIHRoaXMuY3VycmVudEJCb3gueSA8PSBib3gueSAmJiB0aGlzLmN1cnJlbnRCQm94LndpZHRoICsgdGhpcy5jdXJyZW50QkJveC54ID49IGJveC54ICsgYm94LndpZHRoICYmIHRoaXMuY3VycmVudEJCb3guaGVpZ2h0ICsgdGhpcy5jdXJyZW50QkJveC55ID49IGJveC55ICsgYm94LmhlaWdodDtcbiAgfTtcblxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyU2hhcGVGcmFtZSgpO1xuXG4gICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAodGhpcy5faXNGaXJzdEZyYW1lIHx8IHRoaXMuX21kZikpIHtcbiAgICAgIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnRlbXBCb3VuZGluZ0JveDtcbiAgICAgIHZhciBtYXggPSA5OTk5OTk7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueCA9IG1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC54TWF4ID0gLW1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC55ID0gbWF4O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnlNYXggPSAtbWF4O1xuICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveCh0aGlzLml0ZW1zRGF0YSwgdGVtcEJvdW5kaW5nQm94KTtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC53aWR0aCA9IHRlbXBCb3VuZGluZ0JveC54TWF4IDwgdGVtcEJvdW5kaW5nQm94LnggPyAwIDogdGVtcEJvdW5kaW5nQm94LnhNYXggLSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC5oZWlnaHQgPSB0ZW1wQm91bmRpbmdCb3gueU1heCA8IHRlbXBCb3VuZGluZ0JveC55ID8gMCA6IHRlbXBCb3VuZGluZ0JveC55TWF4IC0gdGVtcEJvdW5kaW5nQm94Lnk7IC8vIHZhciB0ZW1wQm91bmRpbmdCb3ggPSB0aGlzLnNoYXBlQ29udC5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3gudyAhPT0gdGVtcEJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRlbXBCb3VuZGluZ0JveC53aWR0aCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGVtcEJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCB8fCB0aGlzLmN1cnJlbnRCQm94LnggIT09IHRlbXBCb3VuZGluZ0JveC54IHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gdGVtcEJvdW5kaW5nQm94LnkpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSB0ZW1wQm91bmRpbmdCb3gueDtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC55ID0gdGVtcEJvdW5kaW5nQm94Lnk7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMuY3VycmVudEJCb3gueCArICcgJyArIHRoaXMuY3VycmVudEJCb3gueSArICcgJyArIHRoaXMuY3VycmVudEJCb3gudyArICcgJyArIHRoaXMuY3VycmVudEJCb3guaCk7XG4gICAgICAgIHZhciBzaGFwZVN0eWxlID0gdGhpcy5zaGFwZUNvbnQuc3R5bGU7XG4gICAgICAgIHZhciBzaGFwZVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHNoYXBlU3R5bGUudHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICAgIHNoYXBlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc2hhcGVUcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhUZXh0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy50ZXh0U3BhbnMgPSBbXTtcbiAgICB0aGlzLnRleHRQYXRocyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEJCb3ggPSB7XG4gICAgICB4OiA5OTk5OTksXG4gICAgICB5OiAtOTk5OTk5LFxuICAgICAgaDogMCxcbiAgICAgIHc6IDBcbiAgICB9O1xuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgIHRoaXMuaXNNYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50LCBJVGV4dEVsZW1lbnRdLCBIVGV4dEVsZW1lbnQpO1xuXG4gIEhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XG5cbiAgICBpZiAodGhpcy5pc01hc2tlZCkge1xuICAgICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgICB0aGlzLmNvbXBXID0gdGhpcy5jb21wLmRhdGEudztcbiAgICAgIHRoaXMuY29tcEggPSB0aGlzLmNvbXAuZGF0YS5oO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXBXKTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuY29tcEgpO1xuICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuICAgICAgdGhpcy5tYXNrZWRFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xuICAgICAgdGhpcy5pbm5lckVsZW0gPSBnO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbmRlclR5cGUgPSAnaHRtbCc7XG4gICAgICB0aGlzLmlubmVyRWxlbSA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cblxuICAgIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcbiAgfTtcblxuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG4gICAgdmFyIGlubmVyRWxlbVN0eWxlID0gdGhpcy5pbm5lckVsZW0uc3R5bGU7XG4gICAgdmFyIHRleHRDb2xvciA9IGRvY3VtZW50RGF0YS5mYyA/IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpIDogJ3JnYmEoMCwwLDAsMCknO1xuICAgIGlubmVyRWxlbVN0eWxlLmZpbGwgPSB0ZXh0Q29sb3I7XG4gICAgaW5uZXJFbGVtU3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG5cbiAgICBpZiAoZG9jdW1lbnREYXRhLnNjKSB7XG4gICAgICBpbm5lckVsZW1TdHlsZS5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcbiAgICAgIGlubmVyRWxlbVN0eWxlLnN0cm9rZVdpZHRoID0gZG9jdW1lbnREYXRhLnN3ICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG5cbiAgICBpZiAoIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFNpemUgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcbiAgICAgIGlubmVyRWxlbVN0eWxlLmxpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcblxuICAgICAgaWYgKGZvbnREYXRhLmZDbGFzcykge1xuICAgICAgICB0aGlzLmlubmVyRWxlbS5jbGFzc05hbWUgPSBmb250RGF0YS5mQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcbiAgICAgICAgdmFyIGZXZWlnaHQgPSBkb2N1bWVudERhdGEuZldlaWdodDtcbiAgICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTdHlsZSA9IGZTdHlsZTtcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFdlaWdodCA9IGZXZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgdFBhcmVudDtcbiAgICB2YXIgdENvbnQ7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgc2hhcGVzO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBjbnQgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGF0aHNbY250XSkge1xuICAgICAgICAgIHRTcGFuID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bMV0pO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtWzJdKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgJzQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgICB0Q29udCA9IHRQYXJlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgICAgICAgICAgdFBhcmVudC5zdHlsZS5saW5lSGVpZ2h0ID0gMDtcbiAgICAgICAgICAgIHRDb250ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICAgICAgdENvbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICAgICAgc3R5bGVEaXYodFBhcmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgIGlmICh0aGlzLnRleHRTcGFuc1tjbnRdKSB7XG4gICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XG4gICAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRQYXJlbnQgPSBjcmVhdGVUYWcoJ3NwYW4nKTtcbiAgICAgICAgICBzdHlsZURpdih0UGFyZW50KTtcbiAgICAgICAgICB0U3BhbiA9IGNyZWF0ZVRhZygnc3BhbicpO1xuICAgICAgICAgIHN0eWxlRGl2KHRTcGFuKTtcbiAgICAgICAgICB0UGFyZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdID8gdGhpcy50ZXh0UGF0aHNbY250XSA6IGNyZWF0ZU5TKCd0ZXh0Jyk7XG4gICAgICB9IC8vIHRTcGFuLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcblxuXG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIHZhciBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgICAgdmFyIHNoYXBlRGF0YTtcblxuICAgICAgICBpZiAoY2hhckRhdGEpIHtcbiAgICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YS5kYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlRGF0YSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcblxuICAgICAgICBpZiAoc2hhcGVEYXRhICYmIHNoYXBlRGF0YS5zaGFwZXMgJiYgc2hhcGVEYXRhLnNoYXBlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzWzBdLml0O1xuICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwLCBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwKTtcbiAgICAgICAgICBzaGFwZVN0ciA9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlciwgc2hhcGVzKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ2QnLCBzaGFwZVN0cik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0UGFyZW50KTtcblxuICAgICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodENvbnQpO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdENvbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoICsgMik7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJvdW5kaW5nQm94LmhlaWdodCArIDIpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYm91bmRpbmdCb3gueCAtIDEgKyAnICcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJyAnICsgKGJvdW5kaW5nQm94LndpZHRoICsgMikgKyAnICcgKyAoYm91bmRpbmdCb3guaGVpZ2h0ICsgMikpO1xuICAgICAgICAgICAgdmFyIHRDb250U3R5bGUgPSB0Q29udC5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0Q29udFRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LnggLSAxKSArICdweCwnICsgKGJvdW5kaW5nQm94LnkgLSAxKSArICdweCknO1xuICAgICAgICAgICAgdENvbnRTdHlsZS50cmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgdENvbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgbGV0dGVyc1tpXS55T2Zmc2V0ID0gYm91bmRpbmdCb3gueSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxKTtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdFBhcmVudC5hcHBlbmRDaGlsZCh0Q29udCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IGxldHRlcnNbaV0udmFsO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJywgJ3htbDpzcGFjZScsICdwcmVzZXJ2ZScpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpOyAvL1xuXG4gICAgICAgICAgdmFyIHRTdHlsZSA9IHRTcGFuLnN0eWxlO1xuICAgICAgICAgIHZhciB0U3BhblRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZTNkKDAsJyArIC1kb2N1bWVudERhdGEuZmluYWxTaXplIC8gMS4yICsgJ3B4LDApJztcbiAgICAgICAgICB0U3R5bGUudHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgICB0U3R5bGUud2Via2l0VHJhbnNmb3JtID0gdFNwYW5UcmFuc2xhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmlubmVyRWxlbS5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gLy9cblxuXG4gICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHRQYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFNwYW47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLnRleHRQYXRoc1tjbnRdID0gdFNwYW47XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG5cbiAgICB3aGlsZSAoY250IDwgdGhpcy50ZXh0U3BhbnMubGVuZ3RoKSB7XG4gICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gIH07XG5cbiAgSFRleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcbiAgICB2YXIgc3ZnU3R5bGU7XG5cbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc01hc2tlZCAmJiB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpIHtcbiAgICAgICAgLy8gVG9kbyBCZW5jaG1hcmsgaWYgdXNpbmcgdGhpcyBpcyBiZXR0ZXIgdGhhbiBnZXRCQm94XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAnICcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMV0gKyAnICcgKyB0aGlzLmNvbXBXICsgJyAnICsgdGhpcy5jb21wSCk7XG4gICAgICAgIHN2Z1N0eWxlID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMF0gKyAncHgsJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSArICdweCknO1xuICAgICAgICBzdmdTdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGlvbjtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcblxuICAgIGlmICghdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIHRleHRTcGFuO1xuICAgIHZhciB0ZXh0UGF0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICBjb3VudCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXTtcbiAgICAgICAgdGV4dFBhdGggPSB0aGlzLnRleHRQYXRoc1tpXTtcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbY291bnRdO1xuICAgICAgICBjb3VudCArPSAxO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICAgIHRleHRTcGFuLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zdHlsZS50cmFuc2Zvcm0gPSByZW5kZXJlZExldHRlci5tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLy8gL3RleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScscmVuZGVyZWRMZXR0ZXIubyk7XG5cblxuICAgICAgICB0ZXh0U3Bhbi5zdHlsZS5vcGFjaXR5ID0gcmVuZGVyZWRMZXR0ZXIubztcblxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc3cgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLnNjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc2MpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5mYyAmJiByZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgcmVuZGVyZWRMZXR0ZXIuZmMpO1xuICAgICAgICAgIHRleHRQYXRoLnN0eWxlLmNvbG9yID0gcmVuZGVyZWRMZXR0ZXIuZmM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbm5lckVsZW0uZ2V0QkJveCAmJiAhdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmlubmVyRWxlbS5nZXRCQm94KCk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hcmdpbiA9IDE7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luICogMiB8fCB0aGlzLmN1cnJlbnRCQm94LmggIT09IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDIgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSBib3VuZGluZ0JveC54IC0gbWFyZ2luIHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gYm91bmRpbmdCb3gueSAtIG1hcmdpbikge1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSBib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbiAqIDI7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IGJvdW5kaW5nQm94LnggLSBtYXJnaW47XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueSA9IGJvdW5kaW5nQm94LnkgLSBtYXJnaW47XG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLmN1cnJlbnRCQm94LnggKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LncgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LmgpO1xuICAgICAgICBzdmdTdHlsZSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIHN2Z1RyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIHRoaXMuY3VycmVudEJCb3gueCArICdweCwnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJ3B4KSc7XG4gICAgICAgIHN2Z1N0eWxlLnRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybTtcbiAgICAgICAgc3ZnU3R5bGUud2Via2l0VHJhbnNmb3JtID0gc3ZnVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ2FtZXJhRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIHRoaXMucGUgPSBnZXRQcm9wKHRoaXMsIGRhdGEucGUsIDAsIDAsIHRoaXMpO1xuXG4gICAgaWYgKGRhdGEua3MucC5zKSB7XG4gICAgICB0aGlzLnB4ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueCwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB5ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueSwgMSwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnB6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAueiwgMSwgMCwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucCA9IGdldFByb3AodGhpcywgZGF0YS5rcy5wLCAxLCAwLCB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5rcy5hKSB7XG4gICAgICB0aGlzLmEgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MuYSwgMSwgMCwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEua3Mub3Iuay5sZW5ndGggJiYgZGF0YS5rcy5vci5rWzBdLnRvKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBkYXRhLmtzLm9yLmsubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgZGF0YS5rcy5vci5rW2ldLnRpID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm9yID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xuICAgIHRoaXMucnggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5yeSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLnJ6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMubWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX3ByZXZNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTsgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gbWFrZSB0aGUgSENhbWVyYSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgTGF5ZXJJbnRlcmZhY2UgYW5kIFRyYW5zZm9ybUludGVyZmFjZS5cblxuICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0gPSB7XG4gICAgICBtUHJvcDogdGhpc1xuICAgIH07XG4gIH1cblxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBjb21wO1xuICAgIHZhciBwZXJzcGVjdGl2ZVN0eWxlO1xuICAgIHZhciBjb250YWluZXJTdHlsZTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgLy8gW3BlcnNwZWN0aXZlRWxlbSxjb250YWluZXJdXG4gICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xuXG4gICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUgPSBjb21wLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgdmFyIHBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuaGllcmFyY2h5KSB7XG4gICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWRmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBfbWRmO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfbWRmIHx8IHRoaXMucGUuX21kZiB8fCB0aGlzLnAgJiYgdGhpcy5wLl9tZGYgfHwgdGhpcy5weCAmJiAodGhpcy5weC5fbWRmIHx8IHRoaXMucHkuX21kZiB8fCB0aGlzLnB6Ll9tZGYpIHx8IHRoaXMucnguX21kZiB8fCB0aGlzLnJ5Ll9tZGYgfHwgdGhpcy5yei5fbWRmIHx8IHRoaXMub3IuX21kZiB8fCB0aGlzLmEgJiYgdGhpcy5hLl9tZGYpIHtcbiAgICAgIHRoaXMubWF0LnJlc2V0KCk7XG5cbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGggLSAxO1xuXG4gICAgICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgICB2YXIgbVRyYW5zZiA9IHRoaXMuaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtbVRyYW5zZi5wLnZbMF0sIC1tVHJhbnNmLnAudlsxXSwgbVRyYW5zZi5wLnZbMl0pO1xuICAgICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yub3IudlswXSkucm90YXRlWSgtbVRyYW5zZi5vci52WzFdKS5yb3RhdGVaKG1UcmFuc2Yub3IudlsyXSk7XG4gICAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5yeC52KS5yb3RhdGVZKC1tVHJhbnNmLnJ5LnYpLnJvdGF0ZVoobVRyYW5zZi5yei52KTtcbiAgICAgICAgICB0aGlzLm1hdC5zY2FsZSgxIC8gbVRyYW5zZi5zLnZbMF0sIDEgLyBtVHJhbnNmLnMudlsxXSwgMSAvIG1UcmFuc2Yucy52WzJdKTtcbiAgICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUobVRyYW5zZi5hLnZbMF0sIG1UcmFuc2YuYS52WzFdLCBtVHJhbnNmLmEudlsyXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucC52WzBdLCAtdGhpcy5wLnZbMV0sIHRoaXMucC52WzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5weC52LCAtdGhpcy5weS52LCB0aGlzLnB6LnYpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hKSB7XG4gICAgICAgIHZhciBkaWZmVmVjdG9yO1xuXG4gICAgICAgIGlmICh0aGlzLnApIHtcbiAgICAgICAgICBkaWZmVmVjdG9yID0gW3RoaXMucC52WzBdIC0gdGhpcy5hLnZbMF0sIHRoaXMucC52WzFdIC0gdGhpcy5hLnZbMV0sIHRoaXMucC52WzJdIC0gdGhpcy5hLnZbMl1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5weC52IC0gdGhpcy5hLnZbMF0sIHRoaXMucHkudiAtIHRoaXMuYS52WzFdLCB0aGlzLnB6LnYgLSB0aGlzLmEudlsyXV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZWZWN0b3JbMF0sIDIpICsgTWF0aC5wb3coZGlmZlZlY3RvclsxXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzJdLCAyKSk7IC8vIHZhciBsb29rRGlyID0gZ2V0Tm9ybWFsaXplZFBvaW50KGdldERpZmZWZWN0b3IodGhpcy5hLnYsdGhpcy5wLnYpKTtcblxuICAgICAgICB2YXIgbG9va0RpciA9IFtkaWZmVmVjdG9yWzBdIC8gbWFnLCBkaWZmVmVjdG9yWzFdIC8gbWFnLCBkaWZmVmVjdG9yWzJdIC8gbWFnXTtcbiAgICAgICAgdmFyIGxvb2tMZW5ndGhPblhaID0gTWF0aC5zcXJ0KGxvb2tEaXJbMl0gKiBsb29rRGlyWzJdICsgbG9va0RpclswXSAqIGxvb2tEaXJbMF0pO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWCA9IE1hdGguYXRhbjIobG9va0RpclsxXSwgbG9va0xlbmd0aE9uWFopO1xuICAgICAgICB2YXIgbVJvdGF0aW9uWSA9IE1hdGguYXRhbjIobG9va0RpclswXSwgLWxvb2tEaXJbMl0pO1xuICAgICAgICB0aGlzLm1hdC5yb3RhdGVZKG1Sb3RhdGlvblkpLnJvdGF0ZVgoLW1Sb3RhdGlvblgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLnJ4LnYpLnJvdGF0ZVkoLXRoaXMucnkudikucm90YXRlWih0aGlzLnJ6LnYpO1xuICAgICAgdGhpcy5tYXQucm90YXRlWCgtdGhpcy5vci52WzBdKS5yb3RhdGVZKC10aGlzLm9yLnZbMV0pLnJvdGF0ZVoodGhpcy5vci52WzJdKTtcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSh0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIDIsIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oIC8gMiwgMCk7XG4gICAgICB0aGlzLm1hdC50cmFuc2xhdGUoMCwgMCwgdGhpcy5wZS52KTtcbiAgICAgIHZhciBoYXNNYXRyaXhDaGFuZ2VkID0gIXRoaXMuX3ByZXZNYXQuZXF1YWxzKHRoaXMubWF0KTtcblxuICAgICAgaWYgKChoYXNNYXRyaXhDaGFuZ2VkIHx8IHRoaXMucGUuX21kZikgJiYgdGhpcy5jb21wLnRocmVlREVsZW1lbnRzKSB7XG4gICAgICAgIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XG5cbiAgICAgICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgICAgICBpZiAoaGFzTWF0cml4Q2hhbmdlZCkge1xuICAgICAgICAgICAgICB2YXIgbWF0VmFsdWUgPSB0aGlzLm1hdC50b0NTUygpO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZSA9IGNvbXAuY29udGFpbmVyLnN0eWxlO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm0gPSBtYXRWYWx1ZTtcbiAgICAgICAgICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0VmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBlLl9tZGYpIHtcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXQuY2xvbmUodGhpcy5fcHJldk1hdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG5cbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBIQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgZnVuY3Rpb24gSEltYWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIU29saWRFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSEltYWdlRWxlbWVudCk7XG5cbiAgSEltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXNzZXRQYXRoID0gdGhpcy5nbG9iYWxEYXRhLmdldEFzc2V0c1BhdGgodGhpcy5hc3NldERhdGEpO1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5pbWFnZUVsZW0gPSBjcmVhdGVOUygnaW1hZ2UnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53ICsgJ3B4Jyk7XG4gICAgICB0aGlzLmltYWdlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuYXNzZXREYXRhLmggKyAncHgnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBhc3NldFBhdGgpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5pbWFnZUVsZW0pO1xuICAgICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5hc3NldERhdGEudyk7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGltZyk7XG4gICAgfVxuXG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcblxuICAgIGlmICh0aGlzLmRhdGEubG4pIHtcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyQmFzZShhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW86IGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBzbGljZScsXG4gICAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXG4gICAgICBmaWx0ZXJTaXplOiB7XG4gICAgICAgIHdpZHRoOiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUud2lkdGggfHwgJzQwMCUnLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS5oZWlnaHQgfHwgJzQwMCUnLFxuICAgICAgICB4OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueCB8fCAnLTEwMCUnLFxuICAgICAgICB5OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUueSB8fCAnLTEwMCUnXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XG4gICAgICBfbWRmOiBmYWxzZSxcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcbiAgICB9O1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudGhyZWVERWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcbiAgICB0aGlzLnN1cHBvcnRzM2QgPSB0cnVlO1xuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2h0bWwnO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLCBIeWJyaWRSZW5kZXJlckJhc2UpO1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5idWlsZEl0ZW07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmFwcGVuZEVsZW1lbnRJblBvcyA9IGZ1bmN0aW9uIChlbGVtZW50LCBwb3MpIHtcbiAgICB2YXIgbmV3RE9NRWxlbWVudCA9IGVsZW1lbnQuZ2V0QmFzZUVsZW1lbnQoKTtcblxuICAgIGlmICghbmV3RE9NRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW3Bvc107XG5cbiAgICBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50cykge1xuICAgICAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCwgcG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIG5leHRET01FbGVtZW50O1xuICAgICAgICB2YXIgbmV4dExheWVyO1xuICAgICAgICB2YXIgdG1wRE9NRWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaSA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0gIT09IHRydWUgJiYgdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCkge1xuICAgICAgICAgICAgbmV4dExheWVyID0gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRtcERPTUVsZW1lbnQgPSB0aGlzLmxheWVyc1tpXS5kZGQgPyB0aGlzLmdldFRocmVlRENvbnRhaW5lckJ5UG9zKGkpIDogbmV4dExheWVyLmdldEJhc2VFbGVtZW50KCk7XG4gICAgICAgICAgICBuZXh0RE9NRWxlbWVudCA9IHRtcERPTUVsZW1lbnQgfHwgbmV4dERPTUVsZW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRET01FbGVtZW50KSB7XG4gICAgICAgICAgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0RPTUVsZW1lbnQsIG5leHRET01FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RE9NRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQsIHBvcyk7XG4gICAgfVxuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEhUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBISW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSFNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcyA8PSBwb3MgJiYgdGhpcy50aHJlZURFbGVtZW50c1tpXS5lbmRQb3MgPj0gcG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlVGhyZWVEQ29udGFpbmVyID0gZnVuY3Rpb24gKHBvcywgdHlwZSkge1xuICAgIHZhciBwZXJzcGVjdGl2ZUVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xuICAgIHZhciBzdHlsZTtcbiAgICB2YXIgY29udGFpbmVyU3R5bGU7XG4gICAgc3R5bGVEaXYocGVyc3BlY3RpdmVFbGVtKTtcbiAgICB2YXIgY29udGFpbmVyID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICBzdHlsZURpdihjb250YWluZXIpO1xuXG4gICAgaWYgKHR5cGUgPT09ICczZCcpIHtcbiAgICAgIHN0eWxlID0gcGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgc3R5bGUud2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyArICdweCc7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCArICdweCc7XG4gICAgICB2YXIgY2VudGVyID0gJzUwJSA1MCUnO1xuICAgICAgc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2VudGVyO1xuICAgICAgY29udGFpbmVyU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gICAgICB2YXIgbWF0cml4ID0gJ21hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpJztcbiAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IG1hdHJpeDtcbiAgICB9XG5cbiAgICBwZXJzcGVjdGl2ZUVsZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTsgLy8gdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChwZXJzcGVjdGl2ZUVsZW0pO1xuXG4gICAgdmFyIHRocmVlRENvbnRhaW5lckRhdGEgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHBlcnNwZWN0aXZlRWxlbTogcGVyc3BlY3RpdmVFbGVtLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIGVuZFBvczogcG9zLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgdGhpcy50aHJlZURFbGVtZW50cy5wdXNoKHRocmVlRENvbnRhaW5lckRhdGEpO1xuICAgIHJldHVybiB0aHJlZURDb250YWluZXJEYXRhO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGQzZENvbnRhaW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICB2YXIgbGFzdFRocmVlRENvbnRhaW5lckRhdGE7XG4gICAgdmFyIGN1cnJlbnRDb250YWluZXIgPSAnJztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMubGF5ZXJzW2ldLmRkZCAmJiB0aGlzLmxheWVyc1tpXS50eSAhPT0gMykge1xuICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciAhPT0gJzNkJykge1xuICAgICAgICAgIGN1cnJlbnRDb250YWluZXIgPSAnM2QnO1xuICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwgJzNkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgIT09ICcyZCcpIHtcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzJkJztcbiAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YSA9IHRoaXMuY3JlYXRlVGhyZWVEQ29udGFpbmVyKGksICcyZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zID0gTWF0aC5tYXgobGFzdFRocmVlRENvbnRhaW5lckRhdGEuZW5kUG9zLCBpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5hZGRUbzNkQ29udGFpbmVyID0gZnVuY3Rpb24gKGVsZW0sIHBvcykge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKHBvcyA8PSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcykge1xuICAgICAgICB2YXIgaiA9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3M7XG4gICAgICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgICAgICB3aGlsZSAoaiA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0RWxlbWVudCkge1xuICAgICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xuICAgIHZhciByZXNpemVyRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgdmFyIHdyYXBwZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcjtcbiAgICB2YXIgc3R5bGUgPSByZXNpemVyRWxlbS5zdHlsZTtcbiAgICBzdHlsZS53aWR0aCA9IGFuaW1EYXRhLncgKyAncHgnO1xuICAgIHN0eWxlLmhlaWdodCA9IGFuaW1EYXRhLmggKyAncHgnO1xuICAgIHRoaXMucmVzaXplckVsZW0gPSByZXNpemVyRWxlbTtcbiAgICBzdHlsZURpdihyZXNpemVyRWxlbSk7XG4gICAgc3R5bGUudHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG4gICAgc3R5bGUud2Via2l0VHJhbnNmb3JtU3R5bGUgPSAnZmxhdCc7XG5cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICByZXNpemVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICB9XG5cbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHJlc2l6ZXJFbGVtKTtcbiAgICBzdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIHZhciBzdmcgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMScpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxJyk7XG4gICAgc3R5bGVEaXYoc3ZnKTtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHN2Zyk7XG4gICAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xuICAgIHN2Zy5hcHBlbmRDaGlsZChkZWZzKTtcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTsgLy8gTWFzayBhbmltYXRpb25cblxuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBzdmcpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gZGVmcztcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMucmVzaXplckVsZW07XG4gICAgdGhpcy5idWlsZDNkQ29udGFpbmVycygpO1xuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSAmJiB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3kpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGVsZW1lbnRSZWwgPSBlbGVtZW50V2lkdGggLyBlbGVtZW50SGVpZ2h0O1xuICAgIHZhciBhbmltYXRpb25SZWwgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHZhciBzeDtcbiAgICB2YXIgc3k7XG4gICAgdmFyIHR4O1xuICAgIHZhciB0eTtcblxuICAgIGlmIChhbmltYXRpb25SZWwgPiBlbGVtZW50UmVsKSB7XG4gICAgICBzeCA9IGVsZW1lbnRXaWR0aCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgc3kgPSBlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIHR4ID0gMDtcbiAgICAgIHR5ID0gKGVsZW1lbnRIZWlnaHQgLSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCAqIChlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudykpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ggPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBzeSA9IGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHR4ID0gKGVsZW1lbnRXaWR0aCAtIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICogKGVsZW1lbnRIZWlnaHQgLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCkpIC8gMjtcbiAgICAgIHR5ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlO1xuICAgIHN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdtYXRyaXgzZCgnICsgc3ggKyAnLDAsMCwwLDAsJyArIHN5ICsgJywwLDAsMCwwLDEsMCwnICsgdHggKyAnLCcgKyB0eSArICcsMCwxKSc7XG4gICAgc3R5bGUudHJhbnNmb3JtID0gc3R5bGUud2Via2l0VHJhbnNmb3JtO1xuICB9O1xuXG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWU7XG5cbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVzaXplckVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmluaXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcblxuICAgIGlmICh0aGlzLmNhbWVyYSkge1xuICAgICAgdGhpcy5jYW1lcmEuc2V0dXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNXaWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgdmFyIGNIZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICAgIHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlID0gTWF0aC5zcXJ0KE1hdGgucG93KGNXaWR0aCwgMikgKyBNYXRoLnBvdyhjSGVpZ2h0LCAyKSkgKyAncHgnO1xuICAgICAgICBzdHlsZS5wZXJzcGVjdGl2ZSA9IHN0eWxlLndlYmtpdFBlcnNwZWN0aXZlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldLCBmbG9hdGluZ0NvbnRhaW5lciwgdGhpcy5nbG9iYWxEYXRhLmNvbXAsIG51bGwpO1xuICAgICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gIWRhdGEuaGFzTWFzaztcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlLCBJQ29tcEVsZW1lbnQsIEhCYXNlRWxlbWVudF0sIEhDb21wRWxlbWVudCk7XG4gIEhDb21wRWxlbWVudC5wcm90b3R5cGUuX2NyZWF0ZUJhc2VDb250YWluZXJFbGVtZW50cyA9IEhDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyRWxlbWVudHM7XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMoKTsgLy8gZGl2RWxlbWVudC5zdHlsZS5jbGlwID0gJ3JlY3QoMHB4LCAnK3RoaXMuZGF0YS53KydweCwgJyt0aGlzLmRhdGEuaCsncHgsIDBweCknO1xuXG5cbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLncpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLmgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgIH1cbiAgfTtcblxuICBIQ29tcEVsZW1lbnQucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbiAoZWxlbSwgcG9zKSB7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBuZXh0RWxlbWVudDtcblxuICAgIHdoaWxlIChqIDwgcG9zKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuXG4gICAgICBqICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICB9XG4gIH07XG5cbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSHlicmlkUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoY29uZmlnICYmIGNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCA9PT0gZmFsc2UpLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICc0MDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICc0MDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJy0xMDAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJy0xMDAlJ1xuICAgICAgfSxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXJCYXNlXSwgSHlicmlkUmVuZGVyZXIpO1xuXG4gIEh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgSENvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgdmFyIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29tcCkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gY29tcC5sYXllcnMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGNvbXAubGF5ZXJzW2ldLm5tID09PSBuYW1lIHx8IGNvbXAubGF5ZXJzW2ldLmluZCA9PT0gbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXAuZWxlbWVudHNbaV0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIHJldHVybiB7YWN0aXZlOmZhbHNlfTtcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzTGF5ZXJGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICB2YWx1ZTogY29tcC5kYXRhLm5tXG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5sYXllciA9IF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaGVpZ2h0ID0gY29tcC5kYXRhLmggfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ud2lkdGggPSBjb21wLmRhdGEudyB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5waXhlbEFzcGVjdCA9IDE7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJhbWVEdXJhdGlvbiA9IDEgLyBjb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmRpc3BsYXlTdGFydFRpbWUgPSAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm51bUxheWVycyA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YkMihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiQyID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YkMiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mJDIob2JqKTsgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG5cbiAgLypcclxuICAgQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxyXG5cclxuICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiAgIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxyXG4gICBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcclxuICAgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gICBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cclxuICAgcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXHJcbiAgIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXHJcbiAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXHJcbiAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cclxuICAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuICAgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcclxuICAgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcclxuICAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4gICAqL1xuICBmdW5jdGlvbiBzZWVkUmFuZG9tKHBvb2wsIG1hdGgpIHtcbiAgICAvL1xuICAgIC8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbiAgICAvL1xuICAgIHZhciBnbG9iYWwgPSB0aGlzLFxuICAgICAgICB3aWR0aCA9IDI1NixcbiAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsXG4gICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MixcbiAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJyxcbiAgICAgICAgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICAgICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICAgICAgb3ZlcmZsb3cgPSBzaWduaWZpY2FuY2UgKiAyLFxuICAgICAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgICAgICBub2RlY3J5cHRvOyAvLyBub2RlLmpzIGNyeXB0byBtb2R1bGUsIGluaXRpYWxpemVkIGF0IHRoZSBib3R0b20uXG4gICAgLy9cbiAgICAvLyBzZWVkcmFuZG9tKClcbiAgICAvLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAvL1xuXG4gICAgZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGtleSA9IFtdO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHRydWUgPyB7XG4gICAgICAgIGVudHJvcHk6IHRydWVcbiAgICAgIH0gOiBvcHRpb25zIHx8IHt9OyAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cblxuICAgICAgdmFyIHNob3J0c2VlZCA9IG1peGtleShmbGF0dGVuKG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOiBzZWVkID09PSBudWxsID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpOyAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cblxuICAgICAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpOyAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuXG4gICAgICB2YXIgcHJuZyA9IGZ1bmN0aW9uIHBybmcoKSB7XG4gICAgICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksXG4gICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sXG4gICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgLy8gICBhbmQgbm8gJ2V4dHJhIGxhc3QgYnl0ZScuXG5cbiAgICAgICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHtcbiAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcblxuICAgICAgICAgIGQgKj0gd2lkdGg7IC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuXG4gICAgICAgICAgeCA9IGFyYzQuZygxKTsgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7XG4gICAgICAgICAgLy8gVG8gYXZvaWQgcm91bmRpbmcgdXAsIGJlZm9yZSBhZGRpbmdcbiAgICAgICAgICBuIC89IDI7IC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG5cbiAgICAgICAgICBkIC89IDI7IC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG5cbiAgICAgICAgICB4ID4+Pj0gMTsgLy8gICB3ZSBoYXZlIGV4YWN0bHkgdGhlIGRlc2lyZWQgYml0cy5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobiArIHgpIC8gZDsgLy8gRm9ybSB0aGUgbnVtYmVyIHdpdGhpbiBbMCwgMSkuXG4gICAgICB9O1xuXG4gICAgICBwcm5nLmludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjNC5nKDQpIHwgMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmcucXVpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmM0LmcoNCkgLyAweDEwMDAwMDAwMDtcbiAgICAgIH07XG5cbiAgICAgIHBybmdbXCJkb3VibGVcIl0gPSBwcm5nOyAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuXG4gICAgICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7IC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuXG4gICAgICByZXR1cm4gKG9wdGlvbnMucGFzcyB8fCBjYWxsYmFjayB8fCBmdW5jdGlvbiAocHJuZywgc2VlZCwgaXNfbWF0aF9jYWxsLCBzdGF0ZSkge1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAvLyBMb2FkIHRoZSBhcmM0IHN0YXRlIGZyb20gdGhlIGdpdmVuIHN0YXRlIGlmIGl0IGhhcyBhbiBTIGFycmF5LlxuICAgICAgICAgIGlmIChzdGF0ZS5TKSB7XG4gICAgICAgICAgICBjb3B5KHN0YXRlLCBhcmM0KTtcbiAgICAgICAgICB9IC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG5cblxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29weShhcmM0LCB7fSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cblxuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHtcbiAgICAgICAgICBtYXRoW3JuZ25hbWVdID0gcHJuZztcbiAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShwcm5nLCBzaG9ydHNlZWQsICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6IHRoaXMgPT0gbWF0aCwgb3B0aW9ucy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207IC8vXG4gICAgLy8gQVJDNFxuICAgIC8vXG4gICAgLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuICAgIC8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxuICAgIC8vXG4gICAgLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbiAgICAvLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XG4gICAgLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuICAgIC8vXG5cbiAgICBmdW5jdGlvbiBBUkM0KGtleSkge1xuICAgICAgdmFyIHQsXG4gICAgICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgICBtZSA9IHRoaXMsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgaiA9IG1lLmkgPSBtZS5qID0gMCxcbiAgICAgICAgICBzID0gbWUuUyA9IFtdOyAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuXG4gICAgICBpZiAoIWtleWxlbikge1xuICAgICAgICBrZXkgPSBba2V5bGVuKytdO1xuICAgICAgfSAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxuXG5cbiAgICAgIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICAgICAgc1tpXSA9IGkrKztcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKV07XG4gICAgICAgIHNbal0gPSB0O1xuICAgICAgfSAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXG5cblxuICAgICAgbWUuZyA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICAvLyBVc2luZyBpbnN0YW5jZSBtZW1iZXJzIGluc3RlYWQgb2YgY2xvc3VyZSBzdGF0ZSBuZWFybHkgZG91YmxlcyBzcGVlZC5cbiAgICAgICAgdmFyIHQsXG4gICAgICAgICAgICByID0gMCxcbiAgICAgICAgICAgIGkgPSBtZS5pLFxuICAgICAgICAgICAgaiA9IG1lLmosXG4gICAgICAgICAgICBzID0gbWUuUztcblxuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIHQgPSBzW2kgPSBtYXNrICYgaSArIDFdO1xuICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsgdF0pICsgKHNbal0gPSB0KV07XG4gICAgICAgIH1cblxuICAgICAgICBtZS5pID0gaTtcbiAgICAgICAgbWUuaiA9IGo7XG4gICAgICAgIHJldHVybiByOyAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgICAgICAvLyBTZWUgaHR0cDovL2dvb2dsZS5jb20vc2VhcmNoP3E9cnNhK2ZsdWhyZXIrcmVzcG9uc2UmYnRuSVxuICAgICAgfTtcbiAgICB9IC8vXG4gICAgLy8gY29weSgpXG4gICAgLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgICAgIHQuaSA9IGYuaTtcbiAgICAgIHQuaiA9IGYuajtcbiAgICAgIHQuUyA9IGYuUy5zbGljZSgpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSAvL1xuICAgIC8vIGZsYXR0ZW4oKVxuICAgIC8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgICB0eXAgPSBfdHlwZW9mJDIob2JqKSxcbiAgICAgICAgICBwcm9wO1xuXG4gICAgICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZmxhdHRlbihvYmpbcHJvcF0sIGRlcHRoIC0gMSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJztcbiAgICB9IC8vXG4gICAgLy8gbWl4a2V5KClcbiAgICAvLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4gICAgLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4gICAgLy9cblxuXG4gICAgZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xuICAgICAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsXG4gICAgICAgICAgc21lYXIsXG4gICAgICAgICAgaiA9IDA7XG5cbiAgICAgIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICAgICAga2V5W21hc2sgJiBqXSA9IG1hc2sgJiAoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbiAgICB9IC8vXG4gICAgLy8gYXV0b3NlZWQoKVxuICAgIC8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbiAgICAvLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICAgIC8vXG5cblxuICAgIGZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5vZGVjcnlwdG8pIHtcbiAgICAgICAgICByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgICAgKGdsb2JhbC5jcnlwdG8gfHwgZ2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMob3V0KTtcbiAgICAgICAgcmV0dXJuIHRvc3RyaW5nKG91dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgICAgIHBsdWdpbnMgPSBicm93c2VyICYmIGJyb3dzZXIucGx1Z2lucztcbiAgICAgICAgcmV0dXJuIFsrbmV3IERhdGUoKSwgZ2xvYmFsLCBwbHVnaW5zLCBnbG9iYWwuc2NyZWVuLCB0b3N0cmluZyhwb29sKV07XG4gICAgICB9XG4gICAgfSAvL1xuICAgIC8vIHRvc3RyaW5nKClcbiAgICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbiAgICAvL1xuXG5cbiAgICBmdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbiAgICB9IC8vXG4gICAgLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbiAgICAvLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuICAgIC8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbiAgICAvLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuICAgIC8vIGluaXRpYWxpemF0aW9uLlxuICAgIC8vXG5cblxuICAgIG1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTsgLy9cbiAgICAvLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4gICAgLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4gICAgLy9cbiAgICAvLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbiAgfVxuXG4gIDtcblxuICBmdW5jdGlvbiBpbml0aWFsaXplJDIoQk1NYXRoKSB7XG4gICAgc2VlZFJhbmRvbShbXSwgQk1NYXRoKTtcbiAgfVxuXG4gIHZhciBwcm9wVHlwZXMgPSB7XG4gICAgU0hBUEU6ICdzaGFwZSdcbiAgfTtcblxuICBmdW5jdGlvbiBfdHlwZW9mJDEob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YkMSA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mJDEgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZiQxKG9iaik7IH1cblxuICB2YXIgRXhwcmVzc2lvbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIE1hdGggPSBCTU1hdGg7XG4gICAgdmFyIHdpbmRvdyA9IG51bGw7XG4gICAgdmFyIGRvY3VtZW50ID0gbnVsbDtcbiAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBudWxsO1xuICAgIHZhciBmZXRjaCA9IG51bGw7XG4gICAgdmFyIGZyYW1lcyA9IG51bGw7XG4gICAgdmFyIF9sb3R0aWVHbG9iYWwgPSB7fTtcbiAgICBpbml0aWFsaXplJDIoQk1NYXRoKTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0RnJhbWUoKSB7XG4gICAgICBfbG90dGllR2xvYmFsID0ge307XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJGJtX2lzSW5zdGFuY2VPZkFycmF5KGFycikge1xuICAgICAgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgYXJyLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xuICAgICAgcmV0dXJuIHRPZlYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mViA9PT0gJ2Jvb2xlYW4nIHx8IHRPZlYgPT09ICdzdHJpbmcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICRibV9uZWcoYSkge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIGlmICh0T2ZBID09PSAnbnVtYmVyJyB8fCBhIGluc3RhbmNlb2YgTnVtYmVyIHx8IHRPZkEgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gLWE7XG4gICAgICB9XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQTsgaSArPSAxKSB7XG4gICAgICAgICAgcmV0QXJyW2ldID0gLWFbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5wcm9wVHlwZSkge1xuICAgICAgICByZXR1cm4gYS52O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLWE7XG4gICAgfVxuXG4gICAgdmFyIGVhc2VJbkJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMzMzLCAwLCAwLjgzMywgMC44MzMsICdlYXNlSW4nKS5nZXQ7XG4gICAgdmFyIGVhc2VPdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjE2NywgMC4xNjcsIDAuNjY3LCAxLCAnZWFzZU91dCcpLmdldDtcbiAgICB2YXIgZWFzZUluT3V0QmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMywgMCwgMC42NjcsIDEsICdlYXNlSW5PdXQnKS5nZXQ7XG5cbiAgICBmdW5jdGlvbiBzdW0oYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikgfHwgdE9mQSA9PT0gJ3N0cmluZycgfHwgdE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGEgKyBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdICs9IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSArIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldICsgYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgYWRkID0gc3VtO1xuXG4gICAgZnVuY3Rpb24gc3ViKGEsIGIpIHtcbiAgICAgIHZhciB0T2ZBID0gX3R5cGVvZiQxKGEpO1xuXG4gICAgICB2YXIgdE9mQiA9IF90eXBlb2YkMShiKTtcblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGlmICh0T2ZBID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodE9mQiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBiID0gcGFyc2VJbnQoYiwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdIC09IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIGIgPSBiLnNsaWNlKDApO1xuICAgICAgICBiWzBdID0gYSAtIGJbMF07XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuXG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldIC0gYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdWwoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gKiBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAqIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaXYoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG5cbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuXG4gICAgICB2YXIgYXJyO1xuXG4gICAgICBpZiAoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgcmV0dXJuIGEgLyBiO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG5cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpIHtcbiAgICAgICAgbGVuID0gYS5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IGFbaV0gLyBiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBsZW4gPSBiLmxlbmd0aDtcbiAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYSAvIGJbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgICAgaWYgKHR5cGVvZiBhID09PSAnc3RyaW5nJykge1xuICAgICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhICUgYjtcbiAgICB9XG5cbiAgICB2YXIgJGJtX3N1bSA9IHN1bTtcbiAgICB2YXIgJGJtX3N1YiA9IHN1YjtcbiAgICB2YXIgJGJtX211bCA9IG11bDtcbiAgICB2YXIgJGJtX2RpdiA9IGRpdjtcbiAgICB2YXIgJGJtX21vZCA9IG1vZDtcblxuICAgIGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgdmFyIG1tID0gbWF4O1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IG1tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhZGlhbnNUb0RlZ3JlZXModmFsKSB7XG4gICAgICByZXR1cm4gdmFsIC8gZGVnVG9SYWRzO1xuICAgIH1cblxuICAgIHZhciByYWRpYW5zX3RvX2RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xuXG4gICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgKiBkZWdUb1JhZHM7XG4gICAgfVxuXG4gICAgdmFyIGRlZ3JlZXNfdG9fcmFkaWFucyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG4gICAgdmFyIGhlbHBlckxlbmd0aEFycmF5ID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuXG4gICAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyMSA9PT0gJ251bWJlcicgfHwgYXJyMSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICBhcnIyID0gYXJyMiB8fCAwO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXJyMSAtIGFycjIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFycjIpIHtcbiAgICAgICAgYXJyMiA9IGhlbHBlckxlbmd0aEFycmF5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBNYXRoLm1pbihhcnIxLmxlbmd0aCwgYXJyMi5sZW5ndGgpO1xuICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IE1hdGgucG93KGFycjJbaV0gLSBhcnIxW2ldLCAyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE1hdGguc3FydChhZGRlZExlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHZlYykge1xuICAgICAgcmV0dXJuIGRpdih2ZWMsIGxlbmd0aCh2ZWMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZ2JUb0hzbCh2YWwpIHtcbiAgICAgIHZhciByID0gdmFsWzBdO1xuICAgICAgdmFyIGcgPSB2YWxbMV07XG4gICAgICB2YXIgYiA9IHZhbFsyXTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIHM7XG4gICAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgIGggPSAwOyAvLyBhY2hyb21hdGljXG5cbiAgICAgICAgcyA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgYjpcbiAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGggLz0gNjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtoLCBzLCBsLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoc2xUb1JnYih2YWwpIHtcbiAgICAgIHZhciBoID0gdmFsWzBdO1xuICAgICAgdmFyIHMgPSB2YWxbMV07XG4gICAgICB2YXIgbCA9IHZhbFsyXTtcbiAgICAgIHZhciByO1xuICAgICAgdmFyIGc7XG4gICAgICB2YXIgYjtcblxuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgciA9IGw7IC8vIGFjaHJvbWF0aWNcblxuICAgICAgICBiID0gbDsgLy8gYWNocm9tYXRpY1xuXG4gICAgICAgIGcgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xuICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICAgICAgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyLCBnLCBiLCB2YWxbM11dO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVhcih0LCB0TWluLCB0TWF4LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgaWYgKHZhbHVlMSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlMSA9IHRNaW47XG4gICAgICAgIHZhbHVlMiA9IHRNYXg7XG4gICAgICAgIHRNaW4gPSAwO1xuICAgICAgICB0TWF4ID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRNYXggPCB0TWluKSB7XG4gICAgICAgIHZhciBfdE1pbiA9IHRNYXg7XG4gICAgICAgIHRNYXggPSB0TWluO1xuICAgICAgICB0TWluID0gX3RNaW47XG4gICAgICB9XG5cbiAgICAgIGlmICh0IDw9IHRNaW4pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQgPj0gdE1heCkge1xuICAgICAgICByZXR1cm4gdmFsdWUyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGVyYyA9IHRNYXggPT09IHRNaW4gPyAwIDogKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG5cbiAgICAgIGlmICghdmFsdWUxLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMiAtIHZhbHVlMSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xuICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyW2ldID0gdmFsdWUxW2ldICsgKHZhbHVlMltpXSAtIHZhbHVlMVtpXSkgKiBwZXJjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgbWluID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXgubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gbWF4Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIW1pbikge1xuICAgICAgICAgIG1pbiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB2YXIgcm5kID0gQk1NYXRoLnJhbmRvbSgpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGFycltpXSA9IG1pbltpXSArIHJuZCAqIChtYXhbaV0gLSBtaW5baV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBybmRtID0gQk1NYXRoLnJhbmRvbSgpO1xuICAgICAgcmV0dXJuIG1pbiArIHJuZG0gKiAobWF4IC0gbWluKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXRoKHBvaW50cywgaW5UYW5nZW50cywgb3V0VGFuZ2VudHMsIGNsb3NlZCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgIHZhciBwYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHBhdGguc2V0UGF0aERhdGEoISFjbG9zZWQsIGxlbik7XG4gICAgICB2YXIgYXJyUGxhY2Vob2xkZXIgPSBbMCwgMF07XG4gICAgICB2YXIgaW5WZXJ0ZXhQb2ludDtcbiAgICAgIHZhciBvdXRWZXJ0ZXhQb2ludDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGluVmVydGV4UG9pbnQgPSBpblRhbmdlbnRzICYmIGluVGFuZ2VudHNbaV0gPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XG4gICAgICAgIG91dFZlcnRleFBvaW50ID0gb3V0VGFuZ2VudHMgJiYgb3V0VGFuZ2VudHNbaV0gPyBvdXRUYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xuICAgICAgICBwYXRoLnNldFRyaXBsZUF0KHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdLCBvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgb3V0VmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGluVmVydGV4UG9pbnRbMF0gKyBwb2ludHNbaV1bMF0sIGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGksIHRydWUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbml0aWF0ZUV4cHJlc3Npb24oZWxlbSwgZGF0YSwgcHJvcGVydHkpIHtcbiAgICAgIC8vIEJhaWwgb3V0IGlmIHdlIGRvbid0IHdhbnQgZXhwcmVzc2lvbnNcbiAgICAgIGZ1bmN0aW9uIG5vT3AoX3ZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbS5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5ydW5FeHByZXNzaW9ucykge1xuICAgICAgICByZXR1cm4gbm9PcDtcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbCA9IGRhdGEueDtcbiAgICAgIHZhciBuZWVkc1ZlbG9jaXR5ID0gL3ZlbG9jaXR5KD8hW1xcd1xcZF0pLy50ZXN0KHZhbCk7XG5cbiAgICAgIHZhciBfbmVlZHNSYW5kb20gPSB2YWwuaW5kZXhPZigncmFuZG9tJykgIT09IC0xO1xuXG4gICAgICB2YXIgZWxlbVR5cGUgPSBlbGVtLmRhdGEudHk7XG4gICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgdmFyICRibV90cmFuc2Zvcm07XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIHZhciBlZmZlY3Q7XG4gICAgICB2YXIgdGhpc1Byb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICB0aGlzUHJvcGVydHkudmFsdWVBdFRpbWUgPSB0aGlzUHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1Byb3BlcnR5LCAndmFsdWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzUHJvcGVydHkudjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmNvbXAuZnJhbWVEdXJhdGlvbiA9IDEgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBlbGVtLmNvbXAuZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICB2YXIgaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciB3aWR0aCA9IGVsZW0uZGF0YS5zdyA/IGVsZW0uZGF0YS5zdyA6IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcbiAgICAgIHZhciBuYW1lID0gZWxlbS5kYXRhLm5tO1xuICAgICAgdmFyIGxvb3BJbjtcbiAgICAgIHZhciBsb29wX2luO1xuICAgICAgdmFyIGxvb3BPdXQ7XG4gICAgICB2YXIgbG9vcF9vdXQ7XG4gICAgICB2YXIgc21vb3RoO1xuICAgICAgdmFyIHRvV29ybGQ7XG4gICAgICB2YXIgZnJvbVdvcmxkO1xuICAgICAgdmFyIGZyb21Db21wO1xuICAgICAgdmFyIHRvQ29tcDtcbiAgICAgIHZhciBmcm9tQ29tcFRvU3VyZmFjZTtcbiAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgIHZhciByb3RhdGlvbjtcbiAgICAgIHZhciBhbmNob3JQb2ludDtcbiAgICAgIHZhciBzY2FsZTtcbiAgICAgIHZhciB0aGlzTGF5ZXI7XG4gICAgICB2YXIgdGhpc0NvbXA7XG4gICAgICB2YXIgbWFzaztcbiAgICAgIHZhciB2YWx1ZUF0VGltZTtcbiAgICAgIHZhciB2ZWxvY2l0eUF0VGltZTtcbiAgICAgIHZhciBzY29wZWRfYm1fcnQ7IC8vIHZhbCA9IHZhbC5yZXBsYWNlKC8oXFxcXD9cInwnKSgoaHR0cCkocyk/KDpcXC8pKT9cXC8uKj8oXFxcXD9cInwnKS9nLCBcIlxcXCJcXFwiXCIpOyAvLyBkZXRlciBwb3RlbnRpYWwgbmV0d29yayBjYWxsc1xuXG4gICAgICB2YXIgZXhwcmVzc2lvbl9mdW5jdGlvbiA9IGV2YWwoJ1tmdW5jdGlvbiBfZXhwcmVzc2lvbl9mdW5jdGlvbigpeycgKyB2YWwgKyAnO3Njb3BlZF9ibV9ydD0kYm1fcnR9XScpWzBdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV2YWxcblxuICAgICAgdmFyIG51bUtleXMgPSBwcm9wZXJ0eS5rZiA/IGRhdGEuay5sZW5ndGggOiAwO1xuICAgICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xuXG4gICAgICB2YXIgd2lnZ2xlID0gZnVuY3Rpb24gd2lnZ2xlKGZyZXEsIGFtcCkge1xuICAgICAgICB2YXIgaVdpZ2dsZTtcbiAgICAgICAgdmFyIGo7XG4gICAgICAgIHZhciBsZW5XaWdnbGUgPSB0aGlzLnB2Lmxlbmd0aCA/IHRoaXMucHYubGVuZ3RoIDogMTtcbiAgICAgICAgdmFyIGFkZGVkQW1wcyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5XaWdnbGUpO1xuICAgICAgICBmcmVxID0gNTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKHRpbWUgKiBmcmVxKTtcbiAgICAgICAgaVdpZ2dsZSA9IDA7XG4gICAgICAgIGogPSAwO1xuXG4gICAgICAgIHdoaWxlIChpV2lnZ2xlIDwgaXRlcmF0aW9ucykge1xuICAgICAgICAgIC8vIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbldpZ2dsZTsgaiArPSAxKSB7XG4gICAgICAgICAgICBhZGRlZEFtcHNbal0gKz0gLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCk7IC8vIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqcm5kO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlXaWdnbGUgKz0gMTtcbiAgICAgICAgfSAvLyB2YXIgcm5kMiA9IEJNTWF0aC5yYW5kb20oKTtcblxuXG4gICAgICAgIHZhciBwZXJpb2RzID0gdGltZSAqIGZyZXE7XG4gICAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcblxuICAgICAgICBpZiAobGVuV2lnZ2xlID4gMSkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZW5XaWdnbGU7IGogKz0gMSkge1xuICAgICAgICAgICAgYXJyW2pdID0gdGhpcy5wdltqXSArIGFkZGVkQW1wc1tqXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjOyAvLyBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipybmQpKnBlcmM7XG4gICAgICAgICAgICAvLyBhcnJbaV0gPSB0aGlzLnB2W2ldICsgYWRkZWRBbXAgKyBhbXAxKnBlcmMgKyBhbXAyKigxLXBlcmMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wdiArIGFkZGVkQW1wc1swXSArICgtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKSkgKiBwZXJjO1xuICAgICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAodGhpc1Byb3BlcnR5Lmxvb3BJbikge1xuICAgICAgICBsb29wSW4gPSB0aGlzUHJvcGVydHkubG9vcEluLmJpbmQodGhpc1Byb3BlcnR5KTtcbiAgICAgICAgbG9vcF9pbiA9IGxvb3BJbjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wT3V0KSB7XG4gICAgICAgIGxvb3BPdXQgPSB0aGlzUHJvcGVydHkubG9vcE91dC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICAgIGxvb3Bfb3V0ID0gbG9vcE91dDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5zbW9vdGgpIHtcbiAgICAgICAgc21vb3RoID0gdGhpc1Byb3BlcnR5LnNtb290aC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxvb3BJbkR1cmF0aW9uKHR5cGUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb29wSW4odHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBsb29wT3V0RHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXRWYWx1ZUF0VGltZSkge1xuICAgICAgICB2YWx1ZUF0VGltZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUpIHtcbiAgICAgICAgdmVsb2NpdHlBdFRpbWUgPSB0aGlzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wID0gZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5iaW5kKGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UpO1xuXG4gICAgICBmdW5jdGlvbiBsb29rQXQoZWxlbTEsIGVsZW0yKSB7XG4gICAgICAgIHZhciBmVmVjID0gW2VsZW0yWzBdIC0gZWxlbTFbMF0sIGVsZW0yWzFdIC0gZWxlbTFbMV0sIGVsZW0yWzJdIC0gZWxlbTFbMl1dO1xuICAgICAgICB2YXIgcGl0Y2ggPSBNYXRoLmF0YW4yKGZWZWNbMF0sIE1hdGguc3FydChmVmVjWzFdICogZlZlY1sxXSArIGZWZWNbMl0gKiBmVmVjWzJdKSkgLyBkZWdUb1JhZHM7XG4gICAgICAgIHZhciB5YXcgPSAtTWF0aC5hdGFuMihmVmVjWzFdLCBmVmVjWzJdKSAvIGRlZ1RvUmFkcztcbiAgICAgICAgcmV0dXJuIFt5YXcsIHBpdGNoLCAwXTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZU91dCh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZU91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGVhc2VJbih0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluQmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZWFzZSh0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluT3V0QmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwbHlFYXNlKGZuLCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIGlmICh2YWwxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWwxID0gdE1pbjtcbiAgICAgICAgICB2YWwyID0gdE1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ID0gKHQgLSB0TWluKSAvICh0TWF4IC0gdE1pbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11bHQgPSBmbih0KTtcblxuICAgICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KHZhbDEpKSB7XG4gICAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgICAgdmFyIGxlbktleSA9IHZhbDEubGVuZ3RoO1xuICAgICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuS2V5KTtcblxuICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXk7IGlLZXkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2lLZXldID0gKHZhbDJbaUtleV0gLSB2YWwxW2lLZXldKSAqIG11bHQgKyB2YWwxW2lLZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKHZhbDIgLSB2YWwxKSAqIG11bHQgKyB2YWwxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBuZWFyZXN0S2V5KHRpbWUpIHtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXkgPSBkYXRhLmsubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXlUaW1lO1xuXG4gICAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgZGF0YS5rWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICBrZXlUaW1lID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgIHRpbWUgKj0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgICAgaWYgKHRpbWUgPCBkYXRhLmtbMF0udCkge1xuICAgICAgICAgICAgaW5kZXggPSAxO1xuICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1swXS50O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGlLZXkgPSAwOyBpS2V5IDwgbGVuS2V5IC0gMTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICh0aW1lID09PSBkYXRhLmtbaUtleV0udCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRpbWUgPiBkYXRhLmtbaUtleV0udCAmJiB0aW1lIDwgZGF0YS5rW2lLZXkgKyAxXS50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgLSBkYXRhLmtbaUtleV0udCA+IGRhdGEua1tpS2V5ICsgMV0udCAtIHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDI7XG4gICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXkgKyAxXS50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpbmRleCA9IGlLZXkgKyAxO1xuICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcbiAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpS2V5XS50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvYktleSA9IHt9O1xuICAgICAgICBvYktleS5pbmRleCA9IGluZGV4O1xuICAgICAgICBvYktleS50aW1lID0ga2V5VGltZSAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgcmV0dXJuIG9iS2V5O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBrZXkoaW5kKSB7XG4gICAgICAgIHZhciBvYktleTtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXk7XG5cbiAgICAgICAgaWYgKCFkYXRhLmsubGVuZ3RoIHx8IHR5cGVvZiBkYXRhLmtbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcHJvcGVydHkgaGFzIG5vIGtleWZyYW1lIGF0IGluZGV4ICcgKyBpbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kIC09IDE7XG4gICAgICAgIG9iS2V5ID0ge1xuICAgICAgICAgIHRpbWU6IGRhdGEua1tpbmRdLnQgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsXG4gICAgICAgICAgdmFsdWU6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhcnIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YS5rW2luZF0sICdzJykgPyBkYXRhLmtbaW5kXS5zIDogZGF0YS5rW2luZCAtIDFdLmU7XG4gICAgICAgIGxlbktleSA9IGFyci5sZW5ndGg7XG5cbiAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgb2JLZXlbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgICAgb2JLZXkudmFsdWVbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JLZXk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZyYW1lc1RvVGltZShmciwgZnBzKSB7XG4gICAgICAgIGlmICghZnBzKSB7XG4gICAgICAgICAgZnBzID0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZyIC8gZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lVG9GcmFtZXModCwgZnBzKSB7XG4gICAgICAgIGlmICghdCAmJiB0ICE9PSAwKSB7XG4gICAgICAgICAgdCA9IHRpbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZwcykge1xuICAgICAgICAgIGZwcyA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ICogZnBzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZWVkUmFuZG9tKHNlZWQpIHtcbiAgICAgICAgQk1NYXRoLnNlZWRyYW5kb20ocmFuZFNlZWQgKyBzZWVkKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc291cmNlUmVjdEF0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIGVsZW0uc291cmNlUmVjdEF0VGltZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdWJzdHJpbmcoaW5pdCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGluaXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB2YWx1ZS5zdWJzdHJpbmcoaW5pdCwgZW5kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyKGluaXQsIGVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBvc3Rlcml6ZVRpbWUoZnJhbWVzUGVyU2Vjb25kKSB7XG4gICAgICAgIHRpbWUgPSBmcmFtZXNQZXJTZWNvbmQgPT09IDAgPyAwIDogTWF0aC5mbG9vcih0aW1lICogZnJhbWVzUGVyU2Vjb25kKSAvIGZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWU7XG4gICAgICB2YXIgdmVsb2NpdHk7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgdGV4dDtcbiAgICAgIHZhciB0ZXh0SW5kZXg7XG4gICAgICB2YXIgdGV4dFRvdGFsO1xuICAgICAgdmFyIHNlbGVjdG9yVmFsdWU7XG4gICAgICB2YXIgaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgdmFyIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XG4gICAgICB2YXIgcGFyZW50O1xuICAgICAgdmFyIHJhbmRTZWVkID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDAwMCk7XG4gICAgICB2YXIgZ2xvYmFsRGF0YSA9IGVsZW0uZ2xvYmFsRGF0YTtcblxuICAgICAgZnVuY3Rpb24gZXhlY3V0ZUV4cHJlc3Npb24oX3ZhbHVlKSB7XG4gICAgICAgIC8vIGdsb2JhbERhdGEucHVzaEV4cHJlc3Npb24oKTtcbiAgICAgICAgdmFsdWUgPSBfdmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPT09IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkICYmIHRoaXMucHJvcFR5cGUgIT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgdGV4dEluZGV4ID0gdGhpcy50ZXh0SW5kZXg7XG4gICAgICAgICAgdGV4dFRvdGFsID0gdGhpcy50ZXh0VG90YWw7XG4gICAgICAgICAgc2VsZWN0b3JWYWx1ZSA9IHRoaXMuc2VsZWN0b3JWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpc0xheWVyKSB7XG4gICAgICAgICAgdGV4dCA9IGVsZW0ubGF5ZXJJbnRlcmZhY2UudGV4dDtcbiAgICAgICAgICB0aGlzTGF5ZXIgPSBlbGVtLmxheWVySW50ZXJmYWNlO1xuICAgICAgICAgIHRoaXNDb21wID0gZWxlbS5jb21wLmNvbXBJbnRlcmZhY2U7XG4gICAgICAgICAgdG9Xb3JsZCA9IHRoaXNMYXllci50b1dvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tV29ybGQgPSB0aGlzTGF5ZXIuZnJvbVdvcmxkLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBmcm9tQ29tcCA9IHRoaXNMYXllci5mcm9tQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgdG9Db21wID0gdGhpc0xheWVyLnRvQ29tcC5iaW5kKHRoaXNMYXllcik7XG4gICAgICAgICAgbWFzayA9IHRoaXNMYXllci5tYXNrID8gdGhpc0xheWVyLm1hc2suYmluZCh0aGlzTGF5ZXIpIDogbnVsbDtcbiAgICAgICAgICBmcm9tQ29tcFRvU3VyZmFjZSA9IGZyb21Db21wO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKCdBREJFIFRyYW5zZm9ybSBHcm91cCcpO1xuICAgICAgICAgICRibV90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBhbmNob3JQb2ludCA9IHRyYW5zZm9ybS5hbmNob3JQb2ludDtcbiAgICAgICAgICAgIC8qIHBvc2l0aW9uID0gdHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgcm90YXRpb24gPSB0cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbVR5cGUgPT09IDQgJiYgIWNvbnRlbnQpIHtcbiAgICAgICAgICBjb250ZW50ID0gdGhpc0xheWVyKCdBREJFIFJvb3QgVmVjdG9ycyBHcm91cCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlZmZlY3QpIHtcbiAgICAgICAgICBlZmZlY3QgPSB0aGlzTGF5ZXIoNCk7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xuXG4gICAgICAgIGlmIChoYXNQYXJlbnQgJiYgIXBhcmVudCkge1xuICAgICAgICAgIHBhcmVudCA9IGVsZW0uaGllcmFyY2h5WzBdLmxheWVySW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuXG4gICAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcbiAgICAgICAgICBzZWVkUmFuZG9tKHJhbmRTZWVkICsgdGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmVlZHNWZWxvY2l0eSkge1xuICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlBdFRpbWUodGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBleHByZXNzaW9uX2Z1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPSBlbGVtLmdsb2JhbERhdGEuZnJhbWVJZDsgLy8gVE9ETzogQ2hlY2sgaWYgaXQncyBwb3NzaWJsZSB0byByZXR1cm4gb24gU2hhcGVJbnRlcmZhY2UgdGhlIC52IHZhbHVlXG4gICAgICAgIC8vIENoYW5nZWQgdGhpcyB0byBhIHRlcm5hcnkgb3BlcmF0aW9uIGJlY2F1c2UgUm9sbHVwIGZhaWxlZCBjb21waWxpbmcgaXQgY29ycmVjdGx5XG5cbiAgICAgICAgc2NvcGVkX2JtX3J0ID0gc2NvcGVkX2JtX3J0LnByb3BUeXBlID09PSBwcm9wVHlwZXMuU0hBUEUgPyBzY29wZWRfYm1fcnQudiA6IHNjb3BlZF9ibV9ydDtcbiAgICAgICAgcmV0dXJuIHNjb3BlZF9ibV9ydDtcbiAgICAgIH0gLy8gQnVuZGxlcnMgd2lsbCBzZWUgdGhlc2UgYXMgZGVhZCBjb2RlIGFuZCB1bmxlc3Mgd2UgcmVmZXJlbmNlIHRoZW1cblxuXG4gICAgICBleGVjdXRlRXhwcmVzc2lvbi5fX3ByZXZlbnREZWFkQ29kZVJlbW92YWwgPSBbJGJtX3RyYW5zZm9ybSwgYW5jaG9yUG9pbnQsIHRpbWUsIHZlbG9jaXR5LCBpblBvaW50LCBvdXRQb2ludCwgd2lkdGgsIGhlaWdodCwgbmFtZSwgbG9vcF9pbiwgbG9vcF9vdXQsIHNtb290aCwgdG9Db21wLCBmcm9tQ29tcFRvU3VyZmFjZSwgdG9Xb3JsZCwgZnJvbVdvcmxkLCBtYXNrLCBwb3NpdGlvbiwgcm90YXRpb24sIHNjYWxlLCB0aGlzQ29tcCwgbnVtS2V5cywgYWN0aXZlLCB3aWdnbGUsIGxvb3BJbkR1cmF0aW9uLCBsb29wT3V0RHVyYXRpb24sIGNvbXAsIGxvb2tBdCwgZWFzZU91dCwgZWFzZUluLCBlYXNlLCBuZWFyZXN0S2V5LCBrZXksIHRleHQsIHRleHRJbmRleCwgdGV4dFRvdGFsLCBzZWxlY3RvclZhbHVlLCBmcmFtZXNUb1RpbWUsIHRpbWVUb0ZyYW1lcywgc291cmNlUmVjdEF0VGltZSwgc3Vic3RyaW5nLCBzdWJzdHIsIHBvc3Rlcml6ZVRpbWUsIGluZGV4LCBnbG9iYWxEYXRhXTtcbiAgICAgIHJldHVybiBleGVjdXRlRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICBvYi5pbml0aWF0ZUV4cHJlc3Npb24gPSBpbml0aWF0ZUV4cHJlc3Npb247XG4gICAgb2IuX19wcmV2ZW50RGVhZENvZGVSZW1vdmFsID0gW3dpbmRvdywgZG9jdW1lbnQsIFhNTEh0dHBSZXF1ZXN0LCBmZXRjaCwgZnJhbWVzLCAkYm1fbmVnLCBhZGQsICRibV9zdW0sICRibV9zdWIsICRibV9tdWwsICRibV9kaXYsICRibV9tb2QsIGNsYW1wLCByYWRpYW5zX3RvX2RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMsIGRlZ3JlZXNfdG9fcmFkaWFucywgbm9ybWFsaXplLCByZ2JUb0hzbCwgaHNsVG9SZ2IsIGxpbmVhciwgcmFuZG9tLCBjcmVhdGVQYXRoLCBfbG90dGllR2xvYmFsXTtcbiAgICBvYi5yZXNldEZyYW1lID0gcmVzZXRGcmFtZTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuaW5pdEV4cHJlc3Npb25zID0gaW5pdEV4cHJlc3Npb25zO1xuICAgIG9iLnJlc2V0RnJhbWUgPSBFeHByZXNzaW9uTWFuYWdlci5yZXNldEZyYW1lO1xuXG4gICAgZnVuY3Rpb24gaW5pdEV4cHJlc3Npb25zKGFuaW1hdGlvbikge1xuICAgICAgdmFyIHN0YWNrQ291bnQgPSAwO1xuICAgICAgdmFyIHJlZ2lzdGVycyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBwdXNoRXhwcmVzc2lvbigpIHtcbiAgICAgICAgc3RhY2tDb3VudCArPSAxO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwb3BFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50IC09IDE7XG5cbiAgICAgICAgaWYgKHN0YWNrQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZWxlYXNlSW5zdGFuY2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVnaXN0ZXJFeHByZXNzaW9uUHJvcGVydHkoZXhwcmVzc2lvbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJzLmluZGV4T2YoZXhwcmVzc2lvbikgPT09IC0xKSB7XG4gICAgICAgICAgcmVnaXN0ZXJzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVsZWFzZUluc3RhbmNlcygpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSByZWdpc3RlcnMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHJlZ2lzdGVyc1tpXS5yZWxlYXNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlcnMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZShhbmltYXRpb24ucmVuZGVyZXIpO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGFuaW1hdGlvbi5yZW5kZXJlcik7XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbiA9IHB1c2hFeHByZXNzaW9uO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucG9wRXhwcmVzc2lvbiA9IHBvcEV4cHJlc3Npb247XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5yZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eSA9IHJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5O1xuICAgIH1cblxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBNYXNrTWFuYWdlckludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXNrSW50ZXJmYWNlKG1hc2ssIGRhdGEpIHtcbiAgICAgIHRoaXMuX21hc2sgPSBtYXNrO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hc2tJbnRlcmZhY2UucHJvdG90eXBlLCAnbWFza1BhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX21hc2sucHJvcC5rKSB7XG4gICAgICAgICAgdGhpcy5fbWFzay5wcm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXNrSW50ZXJmYWNlLnByb3RvdHlwZSwgJ21hc2tPcGFjaXR5Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXNrLm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5vcC52ICogMTAwO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIE1hc2tNYW5hZ2VyID0gZnVuY3Rpb24gTWFza01hbmFnZXIobWFza01hbmFnZXIpIHtcbiAgICAgIHZhciBfbWFza3NJbnRlcmZhY2VzID0gY3JlYXRlU2l6ZWRBcnJheShtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGgpO1xuXG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBfbWFza3NJbnRlcmZhY2VzW2ldID0gbmV3IE1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIudmlld0RhdGFbaV0sIG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXNrRnVuY3Rpb24gPSBmdW5jdGlvbiBtYXNrRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpID0gMDtcblxuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0ubm0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFza3NJbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIG1hc2tGdW5jdGlvbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hc2tNYW5hZ2VyO1xuICB9KCk7XG5cbiAgdmFyIEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWUgPSB7XG4gICAgICBwdjogMCxcbiAgICAgIHY6IDAsXG4gICAgICBtdWx0OiAxXG4gICAgfTtcbiAgICB2YXIgZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZSA9IHtcbiAgICAgIHB2OiBbMCwgMCwgMF0sXG4gICAgICB2OiBbMCwgMCwgMF0sXG4gICAgICBtdWx0OiAxXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgJ3ZlbG9jaXR5Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydHkuZ2V0VmVsb2NpdHlBdFRpbWUocHJvcGVydHkuY29tcC5jdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5udW1LZXlzID0gcHJvcGVydHkua2V5ZnJhbWVzID8gcHJvcGVydHkua2V5ZnJhbWVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghZXhwcmVzc2lvblZhbHVlLm51bUtleXMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9ICcnO1xuXG4gICAgICAgIGlmICgncycgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDFdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0ucztcbiAgICAgICAgfSBlbHNlIGlmICgnZScgaW4gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdKSB7XG4gICAgICAgICAgdmFsdWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5zO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyBuZXcgTnVtYmVyKHZhbHVlKSA6IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICB2YWx1ZVByb3AudGltZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS50IC8gcHJvcGVydHkuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB2YWx1ZVByb3AudmFsdWUgPSB0eXBlID09PSAndW5pZGltZW5zaW9uYWwnID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlUHJvcDtcbiAgICAgIH07XG5cbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZUF0VGltZSA9IHByb3BlcnR5LmdldFZhbHVlQXRUaW1lO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnNwZWVkQXRUaW1lID0gcHJvcGVydHkuZ2V0U3BlZWRBdFRpbWU7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmVsb2NpdHlBdFRpbWUgPSBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHkucHJvcGVydHlHcm91cDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5IHx8ICEoJ3B2JyBpbiBwcm9wZXJ0eSkpIHtcbiAgICAgICAgcHJvcGVydHkgPSBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG11bHQgPSAxIC8gcHJvcGVydHkubXVsdDtcbiAgICAgIHZhciB2YWwgPSBwcm9wZXJ0eS5wdiAqIG11bHQ7XG4gICAgICB2YXIgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICBjb21wbGV0ZVByb3BlcnR5KGV4cHJlc3Npb25WYWx1ZSwgcHJvcGVydHksICd1bmlkaW1lbnNpb25hbCcpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5LmspIHtcbiAgICAgICAgICBwcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsID0gcHJvcGVydHkudiAqIG11bHQ7XG5cbiAgICAgICAgaWYgKGV4cHJlc3Npb25WYWx1ZS52YWx1ZSAhPT0gdmFsKSB7XG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlID0gbmV3IE51bWJlcih2YWwpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gdmFsO1xuICAgICAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpIHtcbiAgICAgIGlmICghcHJvcGVydHkgfHwgISgncHYnIGluIHByb3BlcnR5KSkge1xuICAgICAgICBwcm9wZXJ0eSA9IGRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XG4gICAgICB2YXIgbGVuID0gcHJvcGVydHkuZGF0YSAmJiBwcm9wZXJ0eS5kYXRhLmwgfHwgcHJvcGVydHkucHYubGVuZ3RoO1xuICAgICAgdmFyIGV4cHJlc3Npb25WYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgdmFyIGFyclZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSBhcnJWYWx1ZTtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ211bHRpZGltZW5zaW9uYWwnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XG4gICAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJWYWx1ZVtpXSA9IHByb3BlcnR5LnZbaV0gKiBtdWx0O1xuICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZVtpXSA9IGFyclZhbHVlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25WYWx1ZTtcbiAgICAgIH07XG4gICAgfSAvLyBUT0RPOiB0cnkgdG8gYXZvaWQgdXNpbmcgdGhpcyBnZXR0ZXJcblxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdEdldHRlcigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0R2V0dGVyO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvcGVydHkucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgICAgcmV0dXJuIFVuaWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzRnVuY3Rpb24obmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgY2FzZSAnU2NhbGUnOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgU2NhbGUnOlxuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnNjYWxlO1xuXG4gICAgICAgICAgY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBaJzpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBYJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhSb3RhdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUm90YXRlIFknOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVJvdGF0aW9uO1xuXG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1Bvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5wb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMCc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54UG9zaXRpb247XG5cbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzEnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVBvc2l0aW9uO1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnpQb3NpdGlvbjtcblxuICAgICAgICAgIGNhc2UgJ2FuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlICdBbmNob3JQb2ludCc6XG4gICAgICAgICAgY2FzZSAnQW5jaG9yIFBvaW50JzpcbiAgICAgICAgICBjYXNlICdBREJFIEFuY2hvclBvaW50JzpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5hbmNob3JQb2ludDtcblxuICAgICAgICAgIGNhc2UgJ29wYWNpdHknOlxuICAgICAgICAgIGNhc2UgJ09wYWNpdHknOlxuICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5vcGFjaXR5O1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncm90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yIHx8IHRyYW5zZm9ybS5yeilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd6Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeiB8fCB0cmFuc2Zvcm0ucilcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd4Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeClcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICd5Um90YXRpb24nLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5yeSlcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdzY2FsZScsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnMpXG4gICAgICB9KTtcblxuICAgICAgdmFyIF9weDtcblxuICAgICAgdmFyIF9weTtcblxuICAgICAgdmFyIF9wejtcblxuICAgICAgdmFyIF90cmFuc2Zvcm1GYWN0b3J5O1xuXG4gICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgX3RyYW5zZm9ybUZhY3RvcnkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3B4ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weCk7XG4gICAgICAgIF9weSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm0ucHopIHtcbiAgICAgICAgICBfcHogPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnB6KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3Bvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgICAgIHJldHVybiBfdHJhbnNmb3JtRmFjdG9yeSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBbX3B4KCksIF9weSgpLCBfcHogPyBfcHooKSA6IDBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHgpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnYW5jaG9yUG9pbnQnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5hKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29wYWNpdHknLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXcnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zaylcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdza2V3QXhpcycsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNhKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29yaWVudGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ub3IpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldE1hdHJpeCh0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcblxuICAgICAgaWYgKHRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcHJvcE1hdHJpeCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgcHJvcE1hdHJpeC5jbG9uZSh0b1dvcmxkTWF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xuICAgICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZFZlYyhhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEyXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzEzXSA9IDA7XG4gICAgICB0b1dvcmxkTWF0LnByb3BzWzE0XSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Xb3JsZChhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5hcHBseVBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkVmVjKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTJdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTNdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTRdID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQb2ludChtYXRyaXgsIGFycikge1xuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeC5hcHBseVRvUG9pbnRBcnJheShhcnJbMF0sIGFyclsxXSwgYXJyWzJdIHx8IDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmVydFBvaW50KG1hdHJpeCwgYXJyKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF0cml4LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZyb21Db21wKGFycikge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgICB0b1dvcmxkTWF0LnJlc2V0KCk7XG5cbiAgICAgIHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcblxuICAgICAgaWYgKHRoaXMuX2VsZW0uaGllcmFyY2h5ICYmIHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b1dvcmxkTWF0LmludmVyc2VQb2ludChhcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhbXBsZUltYWdlKCkge1xuICAgICAgcmV0dXJuIFsxLCAxLCAxLCAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgIGZ1bmN0aW9uIF9yZWdpc3Rlck1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLm1hc2sgPSBuZXcgTWFza01hbmFnZXJJbnRlcmZhY2UobWFza01hbmFnZXIsIGVsZW0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHMpIHtcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmVmZmVjdCA9IGVmZmVjdHM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJzpcbiAgICAgICAgICBjYXNlICdDb250ZW50cyc6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcblxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSAnVHJhbnNmb3JtJzpcbiAgICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgIGNhc2UgJ0FEQkUgVHJhbnNmb3JtIEdyb3VwJzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgY2FzZSAnQURCRSBFZmZlY3QgUGFyYWRlJzpcbiAgICAgICAgICBjYXNlICdlZmZlY3RzJzpcbiAgICAgICAgICBjYXNlICdFZmZlY3RzJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0O1xuXG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IFByb3BlcnRpZXMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi50ZXh0SW50ZXJmYWNlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5nZXRNYXRyaXggPSBnZXRNYXRyaXg7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW52ZXJ0UG9pbnQgPSBpbnZlcnRQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5hcHBseVBvaW50ID0gYXBwbHlQb2ludDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkID0gdG9Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi50b1dvcmxkVmVjID0gdG9Xb3JsZFZlYztcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGQgPSBmcm9tV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbVdvcmxkVmVjID0gZnJvbVdvcmxkVmVjO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvQ29tcCA9IHRvV29ybGQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJvbUNvbXAgPSBmcm9tQ29tcDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zYW1wbGVJbWFnZSA9IHNhbXBsZUltYWdlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVJlY3RBdFRpbWUgPSBlbGVtLnNvdXJjZVJlY3RBdFRpbWUuYmluZChlbGVtKTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fZWxlbSA9IGVsZW07XG4gICAgICB0cmFuc2Zvcm1JbnRlcmZhY2UgPSBUcmFuc2Zvcm1FeHByZXNzaW9uSW50ZXJmYWNlKGVsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3ApO1xuICAgICAgdmFyIGFuY2hvclBvaW50RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnYW5jaG9yUG9pbnQnKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKF90aGlzTGF5ZXJGdW5jdGlvbiwge1xuICAgICAgICBoYXNQYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3JvdGF0aW9uJyksXG4gICAgICAgIHNjYWxlOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3NjYWxlJyksXG4gICAgICAgIHBvc2l0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3Bvc2l0aW9uJyksXG4gICAgICAgIG9wYWNpdHk6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnb3BhY2l0eScpLFxuICAgICAgICBhbmNob3JQb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxuICAgICAgICBhbmNob3JfcG9pbnQ6IGFuY2hvclBvaW50RGVzY3JpcHRvcixcbiAgICAgICAgdHJhbnNmb3JtOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5pc0luUmFuZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zdGFydFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZSA9IGVsZW0uZGF0YS5yZWZJZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBlbGVtLmRhdGEudHkgPT09IDAgPyBlbGVtLmRhdGEuaCA6IDEwMDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS53IDogMTAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmluUG9pbnQgPSBlbGVtLmRhdGEuaXAgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ub3V0UG9pbnQgPSBlbGVtLmRhdGEub3AgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uX25hbWUgPSBlbGVtLmRhdGEubm07XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ucmVnaXN0ZXJNYXNrSW50ZXJmYWNlID0gX3JlZ2lzdGVyTWFza0ludGVyZmFjZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UgPSBfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHByb3BlcnR5R3JvdXBGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoaW50ZXJmYWNlRnVuY3Rpb24sIHBhcmVudFByb3BlcnR5R3JvdXApIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbCA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbDtcblxuICAgICAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50UHJvcGVydHlHcm91cCh2YWwgLSAxKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBQcm9wZXJ0eUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5TmFtZSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0ge1xuICAgICAgICBfbmFtZTogcHJvcGVydHlOYW1lXG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xuXG4gICAgICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKHZhbCAtIDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Byb3BlcnR5R3JvdXA7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7XG4gICAgICBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlOiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UoZWxlbSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgaWYgKGVsZW0uZWZmZWN0c01hbmFnZXIpIHtcbiAgICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGVmZmVjdHNEYXRhW2ldLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWZmZWN0cyA9IGVsZW0uZGF0YS5lZiB8fCBbXTtcblxuICAgICAgICB2YXIgZ3JvdXBJbnRlcmZhY2UgPSBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ251bVByb3BlcnRpZXMnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gZWZmZWN0cy5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLCBlbGVtZW50cywgcHJvcGVydHlHcm91cCwgZWxlbSkge1xuICAgICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2UobmFtZSkge1xuICAgICAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWY7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKG5hbWUgPT09IGVmZmVjdHNbaV0ubm0gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5tbiB8fCBuYW1lID09PSBlZmZlY3RzW2ldLml4KSB7XG4gICAgICAgICAgICBpZiAoZWZmZWN0c1tpXS50eSA9PT0gNSkge1xuICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShncm91cEludGVyZmFjZSwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZGF0YS5lZi5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZGF0YS5lZltpXS50eSA9PT0gNSkge1xuICAgICAgICAgIGVmZmVjdEVsZW1lbnRzLnB1c2goY3JlYXRlR3JvdXBJbnRlcmZhY2UoZGF0YS5lZltpXSwgZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLnByb3BlcnR5R3JvdXAsIGVsZW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBkYXRhLmVmW2ldLnR5LCBlbGVtLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLm1uID09PSAnQURCRSBDb2xvciBDb250cm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdjb2xvcicsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1swXSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdyb3VwSW50ZXJmYWNlLCB7XG4gICAgICAgIG51bVByb3BlcnRpZXM6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm5wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5ubVxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IF9wcm9wZXJ0eUdyb3VwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZ3JvdXBJbnRlcmZhY2UuZW5hYmxlZCA9IGRhdGEuZW4gIT09IDA7XG4gICAgICBncm91cEludGVyZmFjZS5hY3RpdmUgPSBncm91cEludGVyZmFjZS5lbmFibGVkO1xuICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVZhbHVlSW50ZXJmYWNlKGVsZW1lbnQsIHR5cGUsIGVsZW0sIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBleHByZXNzaW9uUHJvcGVydHkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UoZWxlbWVudC5wKTtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAxMCkge1xuICAgICAgICAgIHJldHVybiBlbGVtLmNvbXAuY29tcEludGVyZmFjZShlbGVtZW50LnAudik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblByb3BlcnR5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eSkge1xuICAgICAgICBlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnJywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlUGF0aEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBwcm9wID0gdmlldy5zaDtcblxuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09ICdTaGFwZScgfHwgdmFsID09PSAnc2hhcGUnIHx8IHZhbCA9PT0gJ1BhdGgnIHx8IHZhbCA9PT0gJ3BhdGgnIHx8IHZhbCA9PT0gJ0FEQkUgVmVjdG9yIFNoYXBlJyB8fCB2YWwgPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucGF0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUGF0aCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaGFwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgaXg6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUuaXhcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydHlJbmRleDoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5peFxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IHByb3BlcnR5R3JvdXBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlcywgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVzID8gc2hhcGVzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2ZsJykge1xuICAgICAgICAgIGFyci5wdXNoKGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICAgIGFyci5wdXNoKHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndG0nKSB7XG4gICAgICAgICAgYXJyLnB1c2godHJpbUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAndHInKSB7Ly8gYXJyLnB1c2godHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZWwnKSB7XG4gICAgICAgICAgYXJyLnB1c2goZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgICAgYXJyLnB1c2goc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgYXJyLnB1c2goU2hhcGVQYXRoSW50ZXJmYWNlKHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JjJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JkJykge1xuICAgICAgICAgIGFyci5wdXNoKHJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3JwJykge1xuICAgICAgICAgIGFyci5wdXNoKHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdnZicpIHtcbiAgICAgICAgICBhcnIucHVzaChncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyci5wdXNoKGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGludGVyZmFjZXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGludGVyZmFjZXNbaV0uX25hbWUgPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ubW4gPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0ucHJvcGVydHlJbmRleCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5peCA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5pbmQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2UgPSB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdLCB2aWV3Lml0W3ZpZXcuaXQubGVuZ3RoIC0gMV0sIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLmNpeDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gc2hhcGUubm07XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgVmVjdG9ycyBHcm91cCc6XG4gICAgICAgICAgY2FzZSAnQ29udGVudHMnOlxuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50O1xuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnkgZm9yIG5vdy4gS2VlcGluZyB0aGVtIGhlcmUgaW4gY2FzZSBhIG5ldyBjYXNlIGFwcGVhcnNcbiAgICAgICAgICAvLyBjYXNlICdBREJFIFZlY3RvciBUcmFuc2Zvcm0gR3JvdXAnOlxuICAgICAgICAgIC8vIGNhc2UgMzpcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmZhY2VGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGUubm07XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gaW50ZXJmYWNlRnVuY3Rpb247XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBzaGFwZS5ucDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm5tID0gc2hhcGUubm07XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ0NvbG9yJyB8fCB2YWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29sb3InLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0YXJ0IFBvaW50JyB8fCB2YWwgPT09ICdzdGFydCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdFbmQgUG9pbnQnIHx8IHZhbCA9PT0gJ2VuZCBwb2ludCcpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uZW5kUG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydFBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5zKVxuICAgICAgICB9LFxuICAgICAgICBlbmRQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZSlcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuICdhJztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0IFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5lLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0VuZCBQb2ludCcsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgX2Rhc2hQcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZGFzaE9iLCBfcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5VG9EYXNoT2IoaSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGFzaE9iLCBzaGFwZS5kW2ldLm5tLCB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5kLmRhdGFQcm9wc1tpXS5wKVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUuZCA/IHNoYXBlLmQubGVuZ3RoIDogMDtcbiAgICAgIHZhciBkYXNoT2IgPSB7fTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZFByb3BlcnR5VG9EYXNoT2IoaSk7XG4gICAgICAgIHZpZXcuZC5kYXRhUHJvcHNbaV0ucC5zZXRHcm91cFByb3BlcnR5KF9kYXNoUHJvcGVydHlHcm91cCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0cm9rZSBXaWR0aCcgfHwgdmFsID09PSAnc3Ryb2tlIHdpZHRoJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LncpXG4gICAgICAgIH0sXG4gICAgICAgIGRhc2g6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXNoT2I7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZpZXcuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb2xvcicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lncuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3Ryb2tlIFdpZHRoJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLmUuaXggfHwgdmFsID09PSAnRW5kJyB8fCB2YWwgPT09ICdlbmQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLnMuaXgpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsID09PSBzaGFwZS5vLml4KSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHZpZXcucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdGFydCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcucylcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3Lm8pXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUuYS5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBbmNob3IgUG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmFuY2hvclBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1Bvc2l0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdGF0aW9uJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJvdGF0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NjYWxlJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zayAmJiBzaGFwZS5zay5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTa2V3Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnNhICYmIHNoYXBlLnNhLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcgQXhpcycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tld0F4aXM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0FuY2hvciBQb2ludCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTY2FsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG5cbiAgICAgIGlmICh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spIHtcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNrLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2Euc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2tldyBBbmdsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB9XG5cbiAgICAgIHZpZXcudHJhbnNmb3JtLm9wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5vKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wKVxuICAgICAgICB9LFxuICAgICAgICBhbmNob3JQb2ludDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hKVxuICAgICAgICB9LFxuICAgICAgICBzY2FsZToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zKVxuICAgICAgICB9LFxuICAgICAgICByb3RhdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yKVxuICAgICAgICB9LFxuICAgICAgICBza2V3OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKVxuICAgICAgICB9LFxuICAgICAgICBza2V3QXhpczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zYSlcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi50eSA9ICd0cic7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUucHQuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvaW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaGFwZS5vci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIE91dGVyIFJhZGl1cycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUub3MuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGVyUm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlyICYmIChzaGFwZS5pci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBTdGFyIElubmVyIFJhZGl1cycpKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLmlzICYmIHNoYXBlLmlzLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJvdW5kbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLm9yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLm9zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ091dGVyIFJvdW5kbmVzcycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnB0LnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1BvaW50cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JvdGF0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcblxuICAgICAgaWYgKHNoYXBlLmlyKSB7XG4gICAgICAgIHByb3AuaXIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnSW5uZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgcHJvcC5pcy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSb3VuZG5lc3MnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucHQpXG4gICAgICAgIH0sXG4gICAgICAgIG91dGVyUmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vcilcbiAgICAgICAgfSxcbiAgICAgICAgb3V0ZXJSb3VuZG5lc3M6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLm9zKVxuICAgICAgICB9LFxuICAgICAgICBpbm5lclJhZGl1czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlubmVyUm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5pcylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUucC5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2l6ZScgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSZWN0IFNpemUnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuXG4gICAgICB2YXIgcHJvcCA9IHZpZXcuc2gudHkgPT09ICd0bScgPyB2aWV3LnNoLnByb3AgOiB2aWV3LnNoO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Aucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTaXplJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Auci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucClcbiAgICAgICAgfSxcbiAgICAgICAgcm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yKVxuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5zKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdW5kIENvcm5lcnMgMScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcblxuICAgICAgdmFyIHByb3AgPSB2aWV3O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgcHJvcC5yZC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSYWRpdXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcmFkaXVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yZClcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQ29waWVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb3BpZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPZmZzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG5cbiAgICAgIHZhciBwcm9wID0gdmlldztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3AuYy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdDb3BpZXMnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcHJvcC5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb3BpZXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLmMpXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoc2hhcGVzLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcblxuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZSAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwYXJlbnRHcm91cFdyYXBwZXIoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwO1xuICAgICAgfVxuXG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KF9pbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50R3JvdXBXcmFwcGVyKTtcbiAgICAgIGludGVyZmFjZXMgPSBpdGVyYXRlRWxlbWVudHMoc2hhcGVzLCB2aWV3LCBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IGludGVyZmFjZXMubGVuZ3RoO1xuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0NvbnRlbnRzJztcbiAgICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciBfc291cmNlVGV4dDtcblxuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IERvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlVGV4dDtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnc291cmNlVGV4dCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICB2YXIgc3RyaW5nVmFsdWUgPSBlbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS50O1xuXG4gICAgICAgICAgaWYgKCFfc291cmNlVGV4dCB8fCBzdHJpbmdWYWx1ZSAhPT0gX3NvdXJjZVRleHQudmFsdWUpIHtcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0ID0gbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAvLyBJZiBzdHJpbmdWYWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIGV2YWwgcmV0dXJucyB1bmRlZmluZWQsIHNvIGl0IGhhcyB0byBiZSByZXR1cm5lZCBhcyBhIFN0cmluZyBwcmltaXRpdmVcblxuICAgICAgICAgICAgX3NvdXJjZVRleHQudmFsdWUgPSBzdHJpbmdWYWx1ZSB8fCBuZXcgU3RyaW5nKHN0cmluZ1ZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9zb3VyY2VUZXh0LCAnc3R5bGUnLCB7XG4gICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmZjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIF9zb3VyY2VUZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuICB2YXIgRm9vdGFnZUludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0bGluZUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICB2YXIgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcblxuICAgICAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgY3VycmVudFByb3BlcnR5TmFtZSA9ICcnO1xuICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBlbGVtLmdldEZvb3RhZ2VEYXRhKCk7XG4gICAgICAgIHJldHVybiBzZWFyY2hQcm9wZXJ0eTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc2VhcmNoUHJvcGVydHkodmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eVt2YWx1ZV0pIHtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gdmFsdWU7XG4gICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5W3ZhbHVlXTtcblxuICAgICAgICAgIGlmIChfdHlwZW9mKGN1cnJlbnRQcm9wZXJ0eSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRQcm9wZXJ0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVJbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFByb3BlcnR5TmFtZSk7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5TmFtZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cihwcm9wZXJ0eU5hbWVJbmRleCArIGN1cnJlbnRQcm9wZXJ0eU5hbWUubGVuZ3RoKSwgMTApO1xuICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eVtpbmRleF07XG5cbiAgICAgICAgICBpZiAoX3R5cGVvZihjdXJyZW50UHJvcGVydHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbml0O1xuICAgIH07XG5cbiAgICB2YXIgZGF0YUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdPdXRsaW5lJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnT3V0bGluZSc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlID0gb3V0bGluZUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ0RhdGEnKSB7XG4gICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdEYXRhJztcbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlID0gZGF0YUludGVyZmFjZUZhY3RvcnkoZWxlbSk7XG4gICAgICByZXR1cm4gX2ludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgaW50ZXJmYWNlcyA9IHtcbiAgICBsYXllcjogTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGVmZmVjdHM6IEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIGNvbXA6IENvbXBFeHByZXNzaW9uSW50ZXJmYWNlLFxuICAgIHNoYXBlOiBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgdGV4dDogVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgZm9vdGFnZTogRm9vdGFnZUludGVyZmFjZVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEludGVyZmFjZSh0eXBlKSB7XG4gICAgcmV0dXJuIGludGVyZmFjZXNbdHlwZV0gfHwgbnVsbDtcbiAgfVxuXG4gIHZhciBleHByZXNzaW9uSGVscGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKSB7XG4gICAgICBpZiAoZGF0YS54KSB7XG4gICAgICAgIHByb3AuayA9IHRydWU7XG4gICAgICAgIHByb3AueCA9IHRydWU7XG4gICAgICAgIHByb3AuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgICAgICBwcm9wLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKHByb3AuaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sIGRhdGEsIHByb3ApLmJpbmQocHJvcCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZhbHVlQXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggOiAwO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUgPSBmcmFtZU51bTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3BlZWRBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIHZhciBkZWx0YSA9IC0wLjAxO1xuICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XG4gICAgICB2YXIgdjIgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZyYW1lTnVtICsgZGVsdGEpO1xuICAgICAgdmFyIHNwZWVkID0gMDtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzcGVlZCArPSBNYXRoLnBvdyh2MltpXSAtIHYxW2ldLCAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNwZWVkID0gTWF0aC5zcXJ0KHNwZWVkKSAqIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwZWVkID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNwZWVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBpZiAodGhpcy52ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IC0wLjAwMTsgLy8gZnJhbWVOdW0gKz0gdGhpcy5lbGVtLmRhdGEuc3Q7XG5cbiAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xuICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcbiAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgaWYgKHYxLmxlbmd0aCkge1xuICAgICAgICB2ZWxvY2l0eSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB2MS5sZW5ndGgpO1xuICAgICAgICB2YXIgaTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAvLyByZW1vdmluZyBmcmFtZVJhdGVcbiAgICAgICAgICAvLyBpZiBuZWVkZWQsIGRvbid0IGFkZCBpdCBoZXJlXG4gICAgICAgICAgLy8gdmVsb2NpdHlbaV0gPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGUqKCh2MltpXSAtIHYxW2ldKS9kZWx0YSk7XG4gICAgICAgICAgdmVsb2NpdHlbaV0gPSAodjJbaV0gLSB2MVtpXSkgLyBkZWx0YTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmVsb2NpdHkgPSAodjIgLSB2MSkgLyBkZWx0YTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZlbG9jaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY1ZhbHVlQXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0R3JvdXBQcm9wZXJ0eShwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB0aGlzLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hFeHByZXNzaW9uczogc2VhcmNoRXhwcmVzc2lvbnMsXG4gICAgICBnZXRTcGVlZEF0VGltZTogZ2V0U3BlZWRBdFRpbWUsXG4gICAgICBnZXRWZWxvY2l0eUF0VGltZTogZ2V0VmVsb2NpdHlBdFRpbWUsXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZ2V0VmFsdWVBdFRpbWUsXG4gICAgICBnZXRTdGF0aWNWYWx1ZUF0VGltZTogZ2V0U3RhdGljVmFsdWVBdFRpbWUsXG4gICAgICBzZXRHcm91cFByb3BlcnR5OiBzZXRHcm91cFByb3BlcnR5XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xuICAgICAgaWYgKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICcnO1xuICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xuICAgICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xuICAgICAgdmFyIGxhc3RLZXlGcmFtZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0udDtcblxuICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8PSBsYXN0S2V5RnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjeWNsZUR1cmF0aW9uO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWU7XG5cbiAgICAgIGlmICghZHVyYXRpb25GbGFnKSB7XG4gICAgICAgIGlmICghZHVyYXRpb24gfHwgZHVyYXRpb24gPiBrZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxIC0gZHVyYXRpb25dLnQ7XG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBsYXN0S2V5RnJhbWUgLSBmaXJzdEtleUZyYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLCBsYXN0S2V5RnJhbWUgLSB0aGlzLmVsZW0uZGF0YS5pcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlICogZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmlyc3RLZXlGcmFtZSA9IGxhc3RLZXlGcmFtZSAtIGN5Y2xlRHVyYXRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbjtcbiAgICAgIHZhciByZXQ7XG5cbiAgICAgIGlmICh0eXBlID09PSAncGluZ3BvbmcnKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cyArIGN1cnJlbnRbaV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHMgKyBjdXJyZW50O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY29udGludWUnKSB7XG4gICAgICAgIHZhciBsYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBuZXh0TGFzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgobGFzdEtleUZyYW1lIC0gMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkobGFzdFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gbGFzdFZhbHVlW2ldICsgKGxhc3RWYWx1ZVtpXSAtIG5leHRMYXN0VmFsdWVbaV0pICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlKSAvIDAuMDAwNTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGFzdFZhbHVlICsgKGxhc3RWYWx1ZSAtIG5leHRMYXN0VmFsdWUpICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gMC4wMDEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgZHVyYXRpb25GbGFnKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzWzBdLnQ7XG5cbiAgICAgIGlmIChjdXJyZW50RnJhbWUgPj0gZmlyc3RLZXlGcmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5Y2xlRHVyYXRpb247XG4gICAgICB2YXIgbGFzdEtleUZyYW1lO1xuXG4gICAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2R1cmF0aW9uXS50O1xuICAgICAgICBjeWNsZUR1cmF0aW9uID0gbGFzdEtleUZyYW1lIC0gZmlyc3RLZXlGcmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghZHVyYXRpb24pIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5tYXgoMCwgdGhpcy5lbGVtLmRhdGEub3AgLSBmaXJzdEtleUZyYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnModGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lICsgY3ljbGVEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpdGVyYXRpb25zICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKCgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGVuZFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGxhc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XG4gICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKSArIDE7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gY3VycmVudFtpXSAtIChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgLSAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgbmV4dEZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChmaXJzdEtleUZyYW1lICsgMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcblxuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoZmlyc3RWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGZpcnN0VmFsdWVbaV0gKyAoZmlyc3RWYWx1ZVtpXSAtIG5leHRGaXJzdFZhbHVlW2ldKSAqIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIDAuMDAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlyc3RWYWx1ZSArIChmaXJzdFZhbHVlIC0gbmV4dEZpcnN0VmFsdWUpICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gMC4wMDE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc21vb3RoKHdpZHRoLCBzYW1wbGVzKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cblxuICAgICAgd2lkdGggPSAod2lkdGggfHwgMC40KSAqIDAuNTtcbiAgICAgIHNhbXBsZXMgPSBNYXRoLmZsb29yKHNhbXBsZXMgfHwgNSk7XG5cbiAgICAgIGlmIChzYW1wbGVzIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIGluaXRGcmFtZSA9IGN1cnJlbnRUaW1lIC0gd2lkdGg7XG4gICAgICB2YXIgZW5kRnJhbWUgPSBjdXJyZW50VGltZSArIHdpZHRoO1xuICAgICAgdmFyIHNhbXBsZUZyZXF1ZW5jeSA9IHNhbXBsZXMgPiAxID8gKGVuZEZyYW1lIC0gaW5pdEZyYW1lKSAvIChzYW1wbGVzIC0gMSkgOiAxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdGhpcy5wdi5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2FtcGxlVmFsdWU7XG5cbiAgICAgIHdoaWxlIChpIDwgc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoaW5pdEZyYW1lICsgaSAqIHNhbXBsZUZyZXF1ZW5jeSk7XG5cbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMucHYubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHZhbHVlW2pdICs9IHNhbXBsZVZhbHVlW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSArPSBzYW1wbGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgdmFsdWVbal0gLz0gc2FtcGxlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgLz0gc2FtcGxlcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lKHRpbWUpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhbnNmb3JtQ2FjaGluZ0F0VGltZSkge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lID0ge1xuICAgICAgICAgIHY6IG5ldyBNYXRyaXgoKVxuICAgICAgICB9O1xuICAgICAgfSAvLy8gL1xuXG5cbiAgICAgIHZhciBtYXRyaXggPSB0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lLnY7XG4gICAgICBtYXRyaXguY2xvbmVGcm9tUHJvcHModGhpcy5wcmUucHJvcHMpO1xuXG4gICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0gKiB0aGlzLmEubXVsdCwgLWFuY2hvclsxXSAqIHRoaXMuYS5tdWx0LCBhbmNob3JbMl0gKiB0aGlzLmEubXVsdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IHRoaXMucy5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNjYWxlKHNjYWxlWzBdICogdGhpcy5zLm11bHQsIHNjYWxlWzFdICogdGhpcy5zLm11bHQsIHNjYWxlWzJdICogdGhpcy5zLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zayAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAzKSB7XG4gICAgICAgIHZhciBza2V3ID0gdGhpcy5zay5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHNrZXdBeGlzID0gdGhpcy5zYS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgbWF0cml4LnNrZXdGcm9tQXhpcygtc2tldyAqIHRoaXMuc2subXVsdCwgc2tld0F4aXMgKiB0aGlzLnNhLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIHRoaXMuci5tdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgIHZhciByb3RhdGlvblogPSB0aGlzLnJ6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcm90YXRpb25ZID0gdGhpcy5yeS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uWCA9IHRoaXMucnguZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3IuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKC1yb3RhdGlvblogKiB0aGlzLnJ6Lm11bHQpLnJvdGF0ZVkocm90YXRpb25ZICogdGhpcy5yeS5tdWx0KS5yb3RhdGVYKHJvdGF0aW9uWCAqIHRoaXMucngubXVsdCkucm90YXRlWigtb3JpZW50YXRpb25bMl0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVkob3JpZW50YXRpb25bMV0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVgob3JpZW50YXRpb25bMF0gKiB0aGlzLm9yLm11bHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xuICAgICAgICB2YXIgcG9zaXRpb25YID0gdGhpcy5weC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHBvc2l0aW9uWSA9IHRoaXMucHkuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5wLnopIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb25aID0gdGhpcy5wei5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAtcG9zaXRpb25aICogdGhpcy5wei5tdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWCAqIHRoaXMucHgubXVsdCwgcG9zaXRpb25ZICogdGhpcy5weS5tdWx0LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdICogdGhpcy5wLm11bHQsIHBvc2l0aW9uWzFdICogdGhpcy5wLm11bHQsIC1wb3NpdGlvblsyXSAqIHRoaXMucC5tdWx0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdHJpeDsgLy8vIC9cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnYuY2xvbmUobmV3IE1hdHJpeCgpKTtcbiAgICB9XG5cbiAgICB2YXIgZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHk7XG5cbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcHJvcCA9IGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XG5cbiAgICAgIGlmIChwcm9wLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcblxuICAgIHZhciBwcm9wZXJ0eUdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcblxuICAgIFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIG11bHQsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eUdldFByb3AoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKTsgLy8gcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgLy8gcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIC8vIHByb3AubG9vcEluID0gbG9vcEluO1xuXG4gICAgICBpZiAocHJvcC5rZikge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfVxuXG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIHByb3AubG9vcEluID0gbG9vcEluO1xuICAgICAgcHJvcC5zbW9vdGggPSBzbW9vdGg7XG4gICAgICBwcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0VmVsb2NpdHlBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIHByb3AuZ2V0U3BlZWRBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRTcGVlZEF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgcHJvcC5udW1LZXlzID0gZGF0YS5hID09PSAxID8gZGF0YS5rLmxlbmd0aCA6IDA7XG4gICAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xuICAgICAgdmFyIHZhbHVlID0gMDtcblxuICAgICAgaWYgKHR5cGUgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gZGF0YS5rWzBdLnMubGVuZ3RoIDogZGF0YS5rLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIHByb3AuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgIGxhc3RGcmFtZTogaW5pdGlhbERlZmF1bHRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKTtcblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBjb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0U2hhcGVWYWx1ZUF0VGltZShmcmFtZU51bSkge1xuICAgICAgLy8gRm9yIG5vdyB0aGlzIGNhY2hpbmcgb2JqZWN0IGlzIGNyZWF0ZWQgb25seSB3aGVuIG5lZWRlZCBpbnN0ZWFkIG9mIGNyZWF0aW5nIGl0IHdoZW4gdGhlIHNoYXBlIGlzIGluaXRpYWxpemVkLlxuICAgICAgaWYgKCF0aGlzLl9jYWNoaW5nQXRUaW1lKSB7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgICAgc2hhcGVWYWx1ZTogc2hhcGVQb29sLmNsb25lKHRoaXMucHYpLFxuICAgICAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgICAgICBsYXN0VGltZTogaW5pdGlhbERlZmF1bHRGcmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBmcmFtZU51bSAtPSB0aGlzLm9mZnNldFRpbWU7XG5cbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA9IGZyYW1lTnVtO1xuICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZSwgdGhpcy5fY2FjaGluZ0F0VGltZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpO1xuICAgIHZhciBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24oKTtcblxuICAgIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKSB7fVxuXG4gICAgU2hhcGVFeHByZXNzaW9ucy5wcm90b3R5cGUgPSB7XG4gICAgICB2ZXJ0aWNlczogZnVuY3Rpb24gdmVydGljZXMocHJvcCwgdGltZSkge1xuICAgICAgICBpZiAodGhpcy5rKSB7XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNoYXBlUGF0aCA9IHRoaXMudjtcblxuICAgICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUGF0aFtwcm9wXTtcbiAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlUGF0aC52O1xuICAgICAgICB2YXIgYXJyID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChwcm9wID09PSAnaScgfHwgcHJvcCA9PT0gJ28nKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0gLSBwb2ludHNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdIC0gcG9pbnRzW2ldWzFdXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyW2ldID0gW3ZlcnRpY2VzW2ldWzBdLCB2ZXJ0aWNlc1tpXVsxXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICBwb2ludHM6IGZ1bmN0aW9uIHBvaW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCd2JywgdGltZSk7XG4gICAgICB9LFxuICAgICAgaW5UYW5nZW50czogZnVuY3Rpb24gaW5UYW5nZW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XG4gICAgICB9LFxuICAgICAgb3V0VGFuZ2VudHM6IGZ1bmN0aW9uIG91dFRhbmdlbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ28nLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBpc0Nsb3NlZDogZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYuYztcbiAgICAgIH0sXG4gICAgICBwb2ludE9uUGF0aDogZnVuY3Rpb24gcG9pbnRPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuXG4gICAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzaGFwZVBhdGggPSB0aGlzLmdldFZhbHVlQXRUaW1lKHRpbWUsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50c0xlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3NlZ21lbnRzTGVuZ3RoID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSB0aGlzLl9zZWdtZW50c0xlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgICB2YXIgbGVuZ3RoUG9zID0gc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGhzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdGVkTGVuZ3RoICsgbGVuZ3Roc1tpXS5hZGRlZExlbmd0aCA+IGxlbmd0aFBvcykge1xuICAgICAgICAgICAgdmFyIGluaXRJbmRleCA9IGk7XG4gICAgICAgICAgICB2YXIgZW5kSW5kZXggPSBzaGFwZVBhdGguYyAmJiBpID09PSBsZW4gLSAxID8gMCA6IGkgKyAxO1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRQZXJjID0gKGxlbmd0aFBvcyAtIGFjY3VtdWxhdGVkTGVuZ3RoKSAvIGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgICBwdCA9IGJlei5nZXRQb2ludEluU2VnbWVudChzaGFwZVBhdGgudltpbml0SW5kZXhdLCBzaGFwZVBhdGgudltlbmRJbmRleF0sIHNoYXBlUGF0aC5vW2luaXRJbmRleF0sIHNoYXBlUGF0aC5pW2VuZEluZGV4XSwgc2VnbWVudFBlcmMsIGxlbmd0aHNbaV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sIHNoYXBlUGF0aC52WzBdWzFdXSA6IFtzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwdDtcbiAgICAgIH0sXG4gICAgICB2ZWN0b3JPblBhdGg6IGZ1bmN0aW9uIHZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCB2ZWN0b3JUeXBlKSB7XG4gICAgICAgIC8vIHBlcmMgZG9lc24ndCB1c2UgdHJpcGxlIGVxdWFsaXR5IGJlY2F1c2UgaXQgY2FuIGJlIGEgTnVtYmVyIG9iamVjdCBhcyB3ZWxsIGFzIGEgcHJpbWl0aXZlLlxuICAgICAgICBpZiAocGVyYyA9PSAxKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gdGhpcy52LmM7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyYyA9PSAwKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICBwZXJjID0gMC45OTk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHQxID0gdGhpcy5wb2ludE9uUGF0aChwZXJjLCB0aW1lKTtcbiAgICAgICAgdmFyIHB0MiA9IHRoaXMucG9pbnRPblBhdGgocGVyYyArIDAuMDAxLCB0aW1lKTtcbiAgICAgICAgdmFyIHhMZW5ndGggPSBwdDJbMF0gLSBwdDFbMF07XG4gICAgICAgIHZhciB5TGVuZ3RoID0gcHQyWzFdIC0gcHQxWzFdO1xuICAgICAgICB2YXIgbWFnbml0dWRlID0gTWF0aC5zcXJ0KE1hdGgucG93KHhMZW5ndGgsIDIpICsgTWF0aC5wb3coeUxlbmd0aCwgMikpO1xuXG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXRWZWN0b3IgPSB2ZWN0b3JUeXBlID09PSAndGFuZ2VudCcgPyBbeExlbmd0aCAvIG1hZ25pdHVkZSwgeUxlbmd0aCAvIG1hZ25pdHVkZV0gOiBbLXlMZW5ndGggLyBtYWduaXR1ZGUsIHhMZW5ndGggLyBtYWduaXR1ZGVdO1xuICAgICAgICByZXR1cm4gdW5pdFZlY3RvcjtcbiAgICAgIH0sXG4gICAgICB0YW5nZW50T25QYXRoOiBmdW5jdGlvbiB0YW5nZW50T25QYXRoKHBlcmMsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICd0YW5nZW50Jyk7XG4gICAgICB9LFxuICAgICAgbm9ybWFsT25QYXRoOiBmdW5jdGlvbiBub3JtYWxPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWN0b3JPblBhdGgocGVyYywgdGltZSwgJ25vcm1hbCcpO1xuICAgICAgfSxcbiAgICAgIHNldEdyb3VwUHJvcGVydHk6IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHksXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWVcbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbU2hhcGVFeHByZXNzaW9uc10sIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uKTtcbiAgICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZ2V0U2hhcGVWYWx1ZUF0VGltZTtcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbi5wcm90b3R5cGUuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgIHZhciBwcm9wZXJ0eUdldFNoYXBlUHJvcCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcDtcblxuICAgIFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhLCB0eXBlLCBhcnIsIHRyaW1zKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpO1xuICAgICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcbiAgICAgIHByb3AubG9jayA9IGZhbHNlO1xuXG4gICAgICBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLnB0LCBwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLmtzLCBwcm9wKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUkMSgpIHtcbiAgICBhZGRQcm9wZXJ0eURlY29yYXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5kLngpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykodGhpcy5lbGVtLCB0aGlzLmRhdGEuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVmFsdWUgPSBmdW5jdGlvbiAoY3VycmVudFZhbHVlLCB0ZXh0KSB7XG4gICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24odGV4dCk7XG5cbiAgICAgIGlmIChjdXJyZW50VmFsdWUudCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5jb3B5RGF0YShuZXdEYXRhLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICBuZXdEYXRhLnQgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBuZXdEYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaXNLZXlmcmFtZWQgPSB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xuICAgICAgdmFyIGhhc0V4cHJlc3Npb25zID0gdGhpcy5zZWFyY2hFeHByZXNzaW9ucygpO1xuICAgICAgdGhpcy5rZiA9IGlzS2V5ZnJhbWVkIHx8IGhhc0V4cHJlc3Npb25zO1xuICAgICAgcmV0dXJuIHRoaXMua2Y7XG4gICAgfTtcblxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgYWRkRGVjb3JhdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTVkdDb21wb3NhYmxlRWZmZWN0KCkge31cblxuICBTVkdDb21wb3NhYmxlRWZmZWN0LnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVNZXJnZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU1lcmdlTm9kZShyZXN1bHRJZCwgaW5zKSB7XG4gICAgICB2YXIgZmVNZXJnZSA9IGNyZWF0ZU5TKCdmZU1lcmdlJyk7XG4gICAgICBmZU1lcmdlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgcmVzdWx0SWQpO1xuICAgICAgdmFyIGZlTWVyZ2VOb2RlO1xuICAgICAgdmFyIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcbiAgICAgICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsIGluc1tpXSk7XG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xuICAgICAgICBmZU1lcmdlLmFwcGVuZENoaWxkKGZlTWVyZ2VOb2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZlTWVyZ2U7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaW5lYXJGaWx0ZXJWYWx1ZSA9ICcwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwIDAgMCc7XG5cbiAgZnVuY3Rpb24gU1ZHVGludEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBsaW5lYXJGaWx0ZXJWYWx1ZSArICcgMSAwJyk7XG4gICAgdGhpcy5saW5lYXJGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfdGludF8xJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ190aW50XzInKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtzb3VyY2UsIGlkICsgJ190aW50XzEnLCBpZCArICdfdGludF8yJ10pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR1RpbnRGaWx0ZXIpO1xuXG4gIFNWR1RpbnRGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3JCbGFjayA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3JXaGl0ZSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLnYgLyAxMDA7XG4gICAgICB0aGlzLmxpbmVhckZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGxpbmVhckZpbHRlclZhbHVlICsgJyAnICsgb3BhY2l0eSArICcgMCcpO1xuICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBjb2xvcldoaXRlWzBdIC0gY29sb3JCbGFja1swXSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMF0gKyAnICcgKyAoY29sb3JXaGl0ZVsxXSAtIGNvbG9yQmxhY2tbMV0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1sxXSArICcgJyArIChjb2xvcldoaXRlWzJdIC0gY29sb3JCbGFja1syXSkgKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzJdICsgJyAwIDAgMCAxIDAnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRmlsbEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gIH1cblxuICBTVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcbiAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcbiAgICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAgMCAwIDAgJyArIGNvbG9yWzBdICsgJyAwIDAgMCAwICcgKyBjb2xvclsxXSArICcgMCAwIDAgMCAnICsgY29sb3JbMl0gKyAnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZUVmZmVjdChmaWwsIGZpbHRlck1hbmFnZXIsIGVsZW0pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgfVxuXG4gIFNWR1N0cm9rZUVmZmVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbUNoaWxkcmVuID0gdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZHJlbiB8fCB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGdyb3VwUGF0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnYgPT09IDEpIHtcbiAgICAgIGxlbiA9IHRoaXMuZWxlbS5tYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52IC0gMTtcbiAgICAgIGxlbiA9IGkgKyAxO1xuICAgIH1cblxuICAgIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJyk7XG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaG9mZnNldCcsIDEpO1xuXG4gICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBhdGggPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgZ3JvdXBQYXRoLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKHtcbiAgICAgICAgcDogcGF0aCxcbiAgICAgICAgbTogaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAzKSB7XG4gICAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICB2YXIgaWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICBnLnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgaWQgKyAnKScpO1xuXG4gICAgICB3aGlsZSAoZWxlbUNoaWxkcmVuWzBdKSB7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcbiAgICAgIHRoaXMubWFza2VyID0gbWFzaztcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMSB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICAgIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xuXG4gICAgICAgIHdoaWxlIChlbGVtQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5yZW1vdmVDaGlsZChlbGVtQ2hpbGRyZW5bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBQYXRoKTtcbiAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XG4gICAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZicpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0aE1hc2tlciA9IGdyb3VwUGF0aDtcbiAgfTtcblxuICBTVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGg7XG4gICAgdmFyIG1hc2s7XG4gICAgdmFyIHBhdGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhzW2ldLm0gIT09IC0xKSB7XG4gICAgICAgIG1hc2sgPSB0aGlzLmVsZW0ubWFza01hbmFnZXIudmlld0RhdGFbdGhpcy5wYXRoc1tpXS5tXTtcbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aHNbaV0ucDtcblxuICAgICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZCcsIG1hc2subGFzdFBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLl9tZGYgfHwgbWFzay5wcm9wLl9tZGYpIHtcbiAgICAgICAgICB2YXIgZGFzaGFycmF5VmFsdWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMCB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52ICE9PSAxMDApIHtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5taW4odGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAudikgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1heCh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzAgMCAwICcgKyBsICogcyArICcgJztcbiAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbCAqIChlIC0gcyk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IDEgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gTWF0aC5mbG9vcihsaW5lTGVuZ3RoIC8gc2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHVuaXRzOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDEgKyAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlICs9ICcwICcgKyBsICogMTAgKyAnIDAgMCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzEgJyArIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyICogdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudiAqIDAuMDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgdGhpcy5wYXRoTWFza2VyLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIpO1xuICAgIH1cblxuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmKSB7XG4gICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdUcml0b25lRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcbiAgICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XG4gICAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xuICAgIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XG4gICAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xuICAgIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcbiAgICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xuICAgIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcbiAgICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XG4gICAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gIH1cblxuICBTVkdUcml0b25lRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yMSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICB2YXIgY29sb3IyID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBjb2xvcjMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xuICAgICAgdmFyIHRhYmxlUiA9IGNvbG9yM1swXSArICcgJyArIGNvbG9yMlswXSArICcgJyArIGNvbG9yMVswXTtcbiAgICAgIHZhciB0YWJsZUcgPSBjb2xvcjNbMV0gKyAnICcgKyBjb2xvcjJbMV0gKyAnICcgKyBjb2xvcjFbMV07XG4gICAgICB2YXIgdGFibGVCID0gY29sb3IzWzJdICsgJyAnICsgY29sb3IyWzJdICsgJyAnICsgY29sb3IxWzJdO1xuICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZVIpO1xuICAgICAgdGhpcy5mZUZ1bmNHLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUcpO1xuICAgICAgdGhpcy5mZUZ1bmNCLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTsgLy8gUmVkXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMTBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNSID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY1InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEdyZWVuXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1sxN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0cgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gQmx1ZVxuXG5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMjRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuayB8fCBlZmZlY3RFbGVtZW50c1syN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNCID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9IC8vIEFscGhhXG5cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMxXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0EgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQScsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH0gLy8gUkdCXG5cblxuICAgIGlmICh0aGlzLmZlRnVuY1IgfHwgdGhpcy5mZUZ1bmNHIHx8IHRoaXMuZmVGdW5jQiB8fCB0aGlzLmZlRnVuY0EpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s0XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuayB8fCBlZmZlY3RFbGVtZW50c1s3XS5wLnYgIT09IDEpIHtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIgPSBjcmVhdGVOUygnZmVDb21wb25lbnRUcmFuc2ZlcicpO1xuICAgICAgZmVDb21wb25lbnRUcmFuc2Zlci5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jUicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNHQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgICAgdGhpcy5mZUZ1bmNCQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cbiAgfVxuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuY3JlYXRlRmVGdW5jID0gZnVuY3Rpb24gKHR5cGUsIGZlQ29tcG9uZW50VHJhbnNmZXIpIHtcbiAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlModHlwZSk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcbiAgICByZXR1cm4gZmVGdW5jO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuZ2V0VGFibGVWYWx1ZSA9IGZ1bmN0aW9uIChpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XG4gICAgdmFyIGNudCA9IDA7XG4gICAgdmFyIHNlZ21lbnRzID0gMjU2O1xuICAgIHZhciBwZXJjO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlKTtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXgoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XG4gICAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLCB7XG4gICAgICBsZW5ndGg6IHNlZ21lbnRzXG4gICAgfSk7XG4gICAgdmFyIGNvbG9yVmFsdWU7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIG91dHB1dERlbHRhID0gb3V0cHV0V2hpdGUgLSBvdXRwdXRCbGFjaztcbiAgICB2YXIgaW5wdXREZWx0YSA9IGlucHV0V2hpdGUgLSBpbnB1dEJsYWNrO1xuXG4gICAgd2hpbGUgKGNudCA8PSAyNTYpIHtcbiAgICAgIHBlcmMgPSBjbnQgLyAyNTY7XG5cbiAgICAgIGlmIChwZXJjIDw9IG1pbikge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRXaGl0ZSA6IG91dHB1dEJsYWNrO1xuICAgICAgfSBlbHNlIGlmIChwZXJjID49IG1heCkge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRCbGFjayA6IG91dHB1dFdoaXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JWYWx1ZSA9IG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKTtcbiAgICAgIH1cblxuICAgICAgdGFibGVbcG9zXSA9IGNvbG9yVmFsdWU7XG4gICAgICBwb3MgKz0gMTtcbiAgICAgIGNudCArPSAyNTYgLyAoc2VnbWVudHMgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGUuam9pbignICcpO1xuICB9O1xuXG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciB2YWw7XG4gICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG5cbiAgICAgIGlmICh0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpIHtcbiAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzNdLnAudiwgZWZmZWN0RWxlbWVudHNbNF0ucC52LCBlZmZlY3RFbGVtZW50c1s1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzZdLnAudiwgZWZmZWN0RWxlbWVudHNbN10ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNSQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jUiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxNF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTBdLnAudiwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiwgZWZmZWN0RWxlbWVudHNbMTJdLnAudiwgZWZmZWN0RWxlbWVudHNbMTNdLnAudiwgZWZmZWN0RWxlbWVudHNbMTRdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jRyAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTddLnAudiwgZWZmZWN0RWxlbWVudHNbMThdLnAudiwgZWZmZWN0RWxlbWVudHNbMTldLnAudiwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiwgZWZmZWN0RWxlbWVudHNbMjFdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQiAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMjRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMjRdLnAudiwgZWZmZWN0RWxlbWVudHNbMjVdLnAudiwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiwgZWZmZWN0RWxlbWVudHNbMjddLnAudiwgZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZmVGdW5jQSAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMzFdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMzFdLnAudiwgZWZmZWN0RWxlbWVudHNbMzJdLnAudiwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiwgZWZmZWN0RWxlbWVudHNbMzRdLnAudiwgZWZmZWN0RWxlbWVudHNbMzVdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jQS5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHRHJvcFNoYWRvd0VmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkLCBzb3VyY2UpIHtcbiAgICB2YXIgZ2xvYmFsRmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuY29udGFpbmVyLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmZpbHRlclNpemU7XG4gICAgdmFyIGZpbHRlclNpemUgPSBmaWx0ZXJNYW5hZ2VyLmRhdGEuZnMgfHwgZ2xvYmFsRmlsdGVyU2l6ZTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgZmlsdGVyU2l6ZS54IHx8IGdsb2JhbEZpbHRlclNpemUueCk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsIGZpbHRlclNpemUueSB8fCBnbG9iYWxGaWx0ZXJTaXplLnkpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgZmlsdGVyU2l6ZS53aWR0aCB8fCBnbG9iYWxGaWx0ZXJTaXplLndpZHRoKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBmaWx0ZXJTaXplLmhlaWdodCB8fCBnbG9iYWxGaWx0ZXJTaXplLmhlaWdodCk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVHYXVzc2lhbkJsdXIgPSBjcmVhdGVOUygnZmVHYXVzc2lhbkJsdXInKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUFscGhhJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMScpO1xuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgJzAnKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB2YXIgZmVPZmZzZXQgPSBjcmVhdGVOUygnZmVPZmZzZXQnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgJzI1Jyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsICcwJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdpbicsIGlkICsgJ19kcm9wX3NoYWRvd18xJyk7XG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMicpO1xuICAgIHRoaXMuZmVPZmZzZXQgPSBmZU9mZnNldDtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVPZmZzZXQpO1xuICAgIHZhciBmZUZsb29kID0gY3JlYXRlTlMoJ2ZlRmxvb2QnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCAnIzAwZmYwMCcpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1vcGFjaXR5JywgJzEnKTtcbiAgICBmZUZsb29kLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICB0aGlzLmZlRmxvb2QgPSBmZUZsb29kO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUZsb29kKTtcbiAgICB2YXIgZmVDb21wb3NpdGUgPSBjcmVhdGVOUygnZmVDb21wb3NpdGUnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzMnKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luMicsIGlkICsgJ19kcm9wX3NoYWRvd18yJyk7XG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdvcGVyYXRvcicsICdpbicpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX2Ryb3Bfc2hhZG93XzQnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb3NpdGUpO1xuICAgIHZhciBmZU1lcmdlID0gdGhpcy5jcmVhdGVNZXJnZU5vZGUoaWQsIFtpZCArICdfZHJvcF9zaGFkb3dfNCcsIHNvdXJjZV0pO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU1lcmdlKTsgLy9cbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR0Ryb3BTaGFkb3dFZmZlY3QpO1xuXG4gIFNWR0Ryb3BTaGFkb3dFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAvIDQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCByZ2JUb0hleChNYXRoLnJvdW5kKGNvbFswXSAqIDI1NSksIE1hdGgucm91bmQoY29sWzFdICogMjU1KSwgTWF0aC5yb3VuZChjb2xbMl0gKiAyNTUpKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKSB7XG4gICAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52IC8gMjU1KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAtIDkwKSAqIGRlZ1RvUmFkcztcbiAgICAgICAgdmFyIHggPSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHkgPSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgeCk7XG4gICAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xuXG4gIGZ1bmN0aW9uIFNWR01hdHRlM0VmZmVjdChmaWx0ZXJFbGVtLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtKSB7XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdGhpcy5maWx0ZXJFbGVtID0gZmlsdGVyRWxlbTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIGVsZW0ubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICBlbGVtLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtLmxheWVyRWxlbWVudCk7XG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS50cmFuc2Zvcm1lZEVsZW1lbnQpO1xuICAgIGVsZW0uYmFzZUVsZW1lbnQgPSBlbGVtLm1hdHRlRWxlbWVudDtcbiAgfVxuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuZmluZFN5bWJvbCA9IGZ1bmN0aW9uIChtYXNrKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBfc3ZnTWF0dGVTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoX3N2Z01hdHRlU3ltYm9sc1tpXSA9PT0gbWFzaykge1xuICAgICAgICByZXR1cm4gX3N2Z01hdHRlU3ltYm9sc1tpXTtcbiAgICAgIH1cblxuICAgICAgaSArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Tm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZDtcblxuICAgIGlmIChpIDw9IGxlbiAtIDIpIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICB9XG5cbiAgICB2YXIgdXNlRWxlbSA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcblxuICAgIGlmIChuZXh0Q2hpbGQpIHtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHVzZUVsZW0sIG5leHRDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgfVxuICB9O1xuXG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuc2V0RWxlbWVudEFzTWFzayA9IGZ1bmN0aW9uIChlbGVtLCBtYXNrKSB7XG4gICAgaWYgKCF0aGlzLmZpbmRTeW1ib2wobWFzaykpIHtcbiAgICAgIHZhciBzeW1ib2xJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIG1hc2subGF5ZXJJZCk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcblxuICAgICAgX3N2Z01hdHRlU3ltYm9scy5wdXNoKG1hc2spO1xuXG4gICAgICB2YXIgZGVmcyA9IGVsZW0uZ2xvYmFsRGF0YS5kZWZzO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChtYXNrZXIpO1xuICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcbiAgICAgIHN5bWJvbC5zZXRBdHRyaWJ1dGUoJ2lkJywgc3ltYm9sSWQpO1xuICAgICAgdGhpcy5yZXBsYWNlSW5QYXJlbnQobWFzaywgc3ltYm9sSWQpO1xuICAgICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc3ltYm9sKTtcbiAgICAgIHZhciB1c2VFbGVtID0gY3JlYXRlTlMoJ3VzZScpO1xuICAgICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XG4gICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XG4gICAgICBtYXNrLmRhdGEuaGQgPSBmYWxzZTtcbiAgICAgIG1hc2suc2hvdygpO1xuICAgIH1cblxuICAgIGVsZW0uc2V0TWF0dGUobWFzay5sYXllcklkKTtcbiAgfTtcblxuICBTVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluZCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHM7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKGVsZW1lbnRzW2ldICYmIGVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50QXNNYXNrKHRoaXMuZWxlbSwgZWxlbWVudHNbaV0pO1xuICAgICAgfVxuXG4gICAgICBpICs9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gIH07XG5cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdHYXVzc2lhbkJsdXJFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIC8vIE91dHNldCB0aGUgZmlsdGVyIHJlZ2lvbiBieSAxMDAlIG9uIGFsbCBzaWRlcyB0byBhY2NvbW1vZGF0ZSBibHVyIGV4cGFuc2lvbi5cbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd4JywgJy0xMDAlJyk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzMwMCUnKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMzAwJScpO1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlR2F1c3NpYW5CbHVyKTtcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XG4gIH1cblxuICBTVkdHYXVzc2lhbkJsdXJFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICAvLyBFbXBpcmljYWwgdmFsdWUsIG1hdGNoaW5nIEFFJ3MgYmx1ciBhcHBlYXJhbmNlLlxuICAgICAgdmFyIGtCbHVycmluZXNzVG9TaWdtYSA9IDAuMztcbiAgICAgIHZhciBzaWdtYSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgKiBrQmx1cnJpbmVzc1RvU2lnbWE7IC8vIERpbWVuc2lvbnMgbWFwcGluZzpcbiAgICAgIC8vXG4gICAgICAvLyAgIDEgLT4gaG9yaXpvbnRhbCAmIHZlcnRpY2FsXG4gICAgICAvLyAgIDIgLT4gaG9yaXpvbnRhbCBvbmx5XG4gICAgICAvLyAgIDMgLT4gdmVydGljYWwgb25seVxuICAgICAgLy9cblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIHNpZ21hWCA9IGRpbWVuc2lvbnMgPT0gMyA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdmFyIHNpZ21hWSA9IGRpbWVuc2lvbnMgPT0gMiA/IDAgOiBzaWdtYTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcblxuICAgICAgdGhpcy5mZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHNpZ21hWCArICcgJyArIHNpZ21hWSk7IC8vIFJlcGVhdCBlZGdlcyBtYXBwaW5nOlxuICAgICAgLy9cbiAgICAgIC8vICAgMCAtPiBvZmYgLT4gZHVwbGljYXRlXG4gICAgICAvLyAgIDEgLT4gb24gIC0+IHdyYXBcblxuICAgICAgdmFyIGVkZ2VNb2RlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiA9PSAxID8gJ3dyYXAnIDogJ2R1cGxpY2F0ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG5cbiAgICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdlZGdlTW9kZScsIGVkZ2VNb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWZmZWN0KCkge31cblxuICBUcmFuc2Zvcm1FZmZlY3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWZmZWN0c01hbmFnZXIpIHtcbiAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gZWZmZWN0c01hbmFnZXI7XG4gICAgdGhpcy50eXBlID0gZWZmZWN0VHlwZXMuVFJBTlNGT1JNX0VGRkVDVDtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAtMTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLl9vcE1kZiA9IGZhbHNlO1xuICB9O1xuXG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VGcmFtZSkge1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG5cbiAgICBpZiAoZm9yY2VGcmFtZSB8fCB0aGlzLmVmZmVjdHNNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG4gICAgICB2YXIgYW5jaG9yID0gZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgdmFyIHBvc2l0aW9uID0gZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIGlzVW5pZm9ybVNjYWxlID0gZWZmZWN0RWxlbWVudHNbMl0ucC52ID09PSAxO1xuICAgICAgdmFyIHNjYWxlSGVpZ2h0ID0gZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgdmFyIHNjYWxlV2lkdGggPSBpc1VuaWZvcm1TY2FsZSA/IHNjYWxlSGVpZ2h0IDogZWZmZWN0RWxlbWVudHNbNF0ucC52O1xuICAgICAgdmFyIHNrZXcgPSBlZmZlY3RFbGVtZW50c1s1XS5wLnY7XG4gICAgICB2YXIgc2tld0F4aXMgPSBlZmZlY3RFbGVtZW50c1s2XS5wLnY7XG4gICAgICB2YXIgcm90YXRpb24gPSBlZmZlY3RFbGVtZW50c1s3XS5wLnY7XG4gICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0sIC1hbmNob3JbMV0sIGFuY2hvclsyXSk7XG4gICAgICB0aGlzLm1hdHJpeC5zY2FsZShzY2FsZVdpZHRoICogMC4wMSwgc2NhbGVIZWlnaHQgKiAwLjAxLCAxKTtcbiAgICAgIHRoaXMubWF0cml4LnJvdGF0ZSgtcm90YXRpb24gKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogZGVnVG9SYWRzLCAoc2tld0F4aXMgKyA5MCkgKiBkZWdUb1JhZHMpO1xuICAgICAgdGhpcy5tYXRyaXgudHJhbnNsYXRlKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgMCk7XG4gICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSBlZmZlY3RFbGVtZW50c1s4XS5wLnYpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZWZmZWN0RWxlbWVudHNbOF0ucC52O1xuICAgICAgICB0aGlzLl9vcE1kZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR1RyYW5zZm9ybUVmZmVjdChfLCBmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGZpbHRlck1hbmFnZXIpO1xuICB9XG5cbiAgZXh0ZW5kUHJvdG90eXBlKFtUcmFuc2Zvcm1FZmZlY3RdLCBTVkdUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIGZ1bmN0aW9uIENWVHJhbnNmb3JtRWZmZWN0KGVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGVmZmVjdHNNYW5hZ2VyKTtcbiAgfVxuXG4gIGV4dGVuZFByb3RvdHlwZShbVHJhbnNmb3JtRWZmZWN0XSwgQ1ZUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIHJlZ2lzdGVyUmVuZGVyZXIoJ2NhbnZhcycsIENhbnZhc1JlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignaHRtbCcsIEh5YnJpZFJlbmRlcmVyKTtcbiAgcmVnaXN0ZXJSZW5kZXJlcignc3ZnJywgU1ZHUmVuZGVyZXIpOyAvLyBSZWdpc3RlcmluZyBzaGFwZSBtb2RpZmllcnNcblxuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd0bScsIFRyaW1Nb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3BiJywgUHVja2VyQW5kQmxvYXRNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JwJywgUmVwZWF0ZXJNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JkJywgUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd6eicsIFppZ1phZ01vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcignb3AnLCBPZmZzZXRQYXRoTW9kaWZpZXIpOyAvLyBSZWdpc3RlcmluZyBleHByZXNzaW9uIHBsdWdpblxuXG4gIHNldEV4cHJlc3Npb25zUGx1Z2luKEV4cHJlc3Npb25zKTtcbiAgc2V0RXhwcmVzc2lvbkludGVyZmFjZXMoZ2V0SW50ZXJmYWNlKTtcbiAgaW5pdGlhbGl6ZSQxKCk7XG4gIGluaXRpYWxpemUoKTsgLy8gUmVnaXN0ZXJpbmcgc3ZnIGVmZmVjdHNcblxuICByZWdpc3RlckVmZmVjdCQxKDIwLCBTVkdUaW50RmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyMSwgU1ZHRmlsbEZpbHRlciwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjIsIFNWR1N0cm9rZUVmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDIzLCBTVkdUcml0b25lRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNCwgU1ZHUHJvTGV2ZWxzRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyNSwgU1ZHRHJvcFNoYWRvd0VmZmVjdCwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjgsIFNWR01hdHRlM0VmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCQxKDI5LCBTVkdHYXVzc2lhbkJsdXJFZmZlY3QsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDM1LCBTVkdUcmFuc2Zvcm1FZmZlY3QsIGZhbHNlKTtcbiAgcmVnaXN0ZXJFZmZlY3QoMzUsIENWVHJhbnNmb3JtRWZmZWN0KTtcblxuICByZXR1cm4gbG90dGllO1xuXG59KSk7XG4iXSwibmFtZXMiOlsibmF2aWdhdG9yIiwiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImxvdHRpZSIsInN2Z05TIiwibG9jYXRpb25IcmVmIiwiX3VzZVdlYldvcmtlciIsImluaXRpYWxEZWZhdWx0RnJhbWUiLCJzZXRXZWJXb3JrZXIiLCJmbGFnIiwiZ2V0V2ViV29ya2VyIiwic2V0TG9jYXRpb25IcmVmIiwidmFsdWUiLCJnZXRMb2NhdGlvbkhyZWYiLCJjcmVhdGVUYWciLCJ0eXBlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZXh0ZW5kUHJvdG90eXBlIiwic291cmNlcyIsImRlc3RpbmF0aW9uIiwiaSIsImxlbiIsImxlbmd0aCIsInNvdXJjZVByb3RvdHlwZSIsInByb3RvdHlwZSIsImF0dHIiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJnZXREZXNjcmlwdG9yIiwib2JqZWN0IiwicHJvcCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImNyZWF0ZVByb3h5RnVuY3Rpb24iLCJQcm94eUZ1bmN0aW9uIiwiYXVkaW9Db250cm9sbGVyRmFjdG9yeSIsIkF1ZGlvQ29udHJvbGxlciIsImF1ZGlvRmFjdG9yeSIsImF1ZGlvcyIsIl92b2x1bWUiLCJfaXNNdXRlZCIsImFkZEF1ZGlvIiwiYXVkaW8iLCJwdXNoIiwicGF1c2UiLCJyZXN1bWUiLCJzZXRSYXRlIiwicmF0ZVZhbHVlIiwiY3JlYXRlQXVkaW8iLCJhc3NldFBhdGgiLCJ3aW5kb3ciLCJIb3dsIiwic3JjIiwiaXNQbGF5aW5nIiwicGxheSIsInNlZWsiLCJwbGF5aW5nIiwicmF0ZSIsInNldFZvbHVtZSIsInNldEF1ZGlvRmFjdG9yeSIsIl91cGRhdGVWb2x1bWUiLCJtdXRlIiwidW5tdXRlIiwiZ2V0Vm9sdW1lIiwidm9sdW1lIiwiY3JlYXRlVHlwZWRBcnJheSIsImNyZWF0ZVJlZ3VsYXJBcnJheSIsImFyciIsImNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5IiwiRmxvYXQzMkFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiY3JlYXRlU2l6ZWRBcnJheSIsIkFycmF5IiwiYXBwbHkiLCJfdHlwZW9mJDYiLCJvYmoiLCJTeW1ib2wiLCJpdGVyYXRvciIsIl90eXBlb2YiLCJjb25zdHJ1Y3RvciIsInN1YmZyYW1lRW5hYmxlZCIsImV4cHJlc3Npb25zUGx1Z2luIiwiZXhwcmVzc2lvbnNJbnRlcmZhY2VzIiwiaWRQcmVmaXgkMSIsImlzU2FmYXJpIiwidGVzdCIsInVzZXJBZ2VudCIsIl9zaG91bGRSb3VuZFZhbHVlcyIsImJtUG93IiwiTWF0aCIsInBvdyIsImJtU3FydCIsInNxcnQiLCJibUZsb29yIiwiZmxvb3IiLCJibU1heCIsIm1heCIsImJtTWluIiwibWluIiwiQk1NYXRoIiwicHJvcGVydHlOYW1lcyIsIlByb2plY3RJbnRlcmZhY2UkMSIsInJhbmRvbSIsImFicyIsInZhbCIsInRPZlZhbCIsImFic0FyciIsImRlZmF1bHRDdXJ2ZVNlZ21lbnRzIiwiZGVnVG9SYWRzIiwiUEkiLCJyb3VuZENvcm5lciIsInJvdW5kVmFsdWVzIiwiYm1SbmQiLCJyb3VuZCIsInN0eWxlRGl2IiwiZWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiZGlzcGxheSIsInRyYW5zZm9ybU9yaWdpbiIsIndlYmtpdFRyYW5zZm9ybU9yaWdpbiIsImJhY2tmYWNlVmlzaWJpbGl0eSIsIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsInRyYW5zZm9ybVN0eWxlIiwid2Via2l0VHJhbnNmb3JtU3R5bGUiLCJtb3pUcmFuc2Zvcm1TdHlsZSIsIkJNRW50ZXJGcmFtZUV2ZW50IiwiY3VycmVudFRpbWUiLCJ0b3RhbFRpbWUiLCJmcmFtZU11bHRpcGxpZXIiLCJkaXJlY3Rpb24iLCJCTUNvbXBsZXRlRXZlbnQiLCJCTUNvbXBsZXRlTG9vcEV2ZW50IiwidG90YWxMb29wcyIsImN1cnJlbnRMb29wIiwiQk1TZWdtZW50U3RhcnRFdmVudCIsImZpcnN0RnJhbWUiLCJ0b3RhbEZyYW1lcyIsIkJNRGVzdHJveUV2ZW50IiwidGFyZ2V0IiwiQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQiLCJuYXRpdmVFcnJvciIsIkJNQ29uZmlnRXJyb3JFdmVudCIsIkJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCIsImNyZWF0ZUVsZW1lbnRJRCIsIl9jb3VudCIsImNyZWF0ZUlEIiwiSFNWdG9SR0IiLCJoIiwicyIsInYiLCJyIiwiZyIsImIiLCJmIiwicCIsInEiLCJ0IiwiUkdCdG9IU1YiLCJkIiwiYWRkU2F0dXJhdGlvblRvUkdCIiwiY29sb3IiLCJvZmZzZXQiLCJoc3YiLCJhZGRCcmlnaHRuZXNzVG9SR0IiLCJhZGRIdWVUb1JHQiIsInJnYlRvSGV4IiwiY29sb3JNYXAiLCJoZXgiLCJ0b1N0cmluZyIsInNldFN1YmZyYW1lRW5hYmxlZCIsImdldFN1YmZyYW1lRW5hYmxlZCIsInNldEV4cHJlc3Npb25zUGx1Z2luIiwiZ2V0RXhwcmVzc2lvbnNQbHVnaW4iLCJzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyIsImdldEV4cHJlc3Npb25JbnRlcmZhY2VzIiwic2V0RGVmYXVsdEN1cnZlU2VnbWVudHMiLCJnZXREZWZhdWx0Q3VydmVTZWdtZW50cyIsInNldElkUHJlZml4IiwiZ2V0SWRQcmVmaXgiLCJjcmVhdGVOUyIsImNyZWF0ZUVsZW1lbnROUyIsIl90eXBlb2YkNSIsImRhdGFNYW5hZ2VyIiwiX2NvdW50ZXJJZCIsInByb2Nlc3NlcyIsIndvcmtlckZuIiwid29ya2VySW5zdGFuY2UiLCJ3b3JrZXJQcm94eSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwicGF0aCIsImRhdGEiLCJfd29ya2VyU2VsZiIsImNyZWF0ZVdvcmtlciIsImZuIiwiV29ya2VyIiwiQmxvYiIsImJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzZXR1cFdvcmtlciIsIndvcmtlclN0YXJ0IiwiZSIsImRhdGFGdW5jdGlvbk1hbmFnZXIiLCJjb21wbGV0ZUxheWVycyIsImxheWVycyIsImNvbXBzIiwibGF5ZXJEYXRhIiwiaiIsImpMZW4iLCJrIiwia0xlbiIsImNvbXBsZXRlZCIsImhhc01hc2siLCJtYXNrUHJvcHMiLCJtYXNrc1Byb3BlcnRpZXMiLCJwdCIsImNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMiLCJ0eSIsImZpbmRDb21wTGF5ZXJzIiwicmVmSWQiLCJjb21wbGV0ZVNoYXBlcyIsInNoYXBlcyIsImNvbXBsZXRlVGV4dCIsImNvbXBsZXRlQ2hhcnMiLCJjaGFycyIsImFzc2V0cyIsImZpbmRDb21wIiwiaWQiLCJjb21wIiwiX191c2VkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwia3MiLCJpdCIsIm8iLCJjaGVja1ZlcnNpb24iLCJtaW5pbXVtIiwiYW5pbVZlcnNpb25TdHJpbmciLCJhbmltVmVyc2lvbiIsInNwbGl0IiwiY2hlY2tUZXh0IiwibWluaW11bVZlcnNpb24iLCJ1cGRhdGVUZXh0TGF5ZXIiLCJ0ZXh0TGF5ZXIiLCJkb2N1bWVudERhdGEiLCJpdGVyYXRlTGF5ZXJzIiwiYW5pbWF0aW9uRGF0YSIsImNoZWNrQ2hhcnMiLCJjaGFyRGF0YSIsImlwIiwib3AiLCJzdCIsInNyIiwiYSIsInNrIiwic2EiLCJjaGVja1BhdGhQcm9wZXJ0aWVzIiwicGF0aERhdGEiLCJjaGVja0NvbG9ycyIsIml0ZXJhdGVTaGFwZXMiLCJjIiwiY2hlY2tTaGFwZXMiLCJjb21wbGV0ZUNsb3NpbmdTaGFwZXMiLCJjbG9zZWQiLCJjbCIsImNvbXBsZXRlRGF0YSIsIl9fY29tcGxldGUiLCJtb2R1bGVPYiIsImFzc2V0TG9hZGVyIiwiZm9ybWF0UmVzcG9uc2UiLCJ4aHIiLCJjb250ZW50VHlwZUhlYWRlciIsImdldFJlc3BvbnNlSGVhZGVyIiwicmVzcG9uc2VUeXBlIiwiaW5kZXhPZiIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwibG9hZEFzc2V0IiwiZnVsbFBhdGgiLCJjYWxsYmFjayIsImVycm9yQ2FsbGJhY2siLCJYTUxIdHRwUmVxdWVzdCIsImVyciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJvcGVuIiwiam9pbiIsImVycm9yIiwic2VuZCIsImxvYWQiLCJwYXlsb2FkIiwiYW5pbWF0aW9uIiwiZXZlbnQiLCJwcm9jZXNzIiwib25Db21wbGV0ZSIsIm9uRXJyb3IiLCJjcmVhdGVQcm9jZXNzIiwibG9hZEFuaW1hdGlvbiIsInByb2Nlc3NJZCIsImxvY2F0aW9uIiwib3JpZ2luIiwicGF0aG5hbWUiLCJsb2FkRGF0YSIsImNvbXBsZXRlQW5pbWF0aW9uIiwiYW5pbSIsIkltYWdlUHJlbG9hZGVyIiwicHJveHlJbWFnZSIsImNhbnZhcyIsIndpZHRoIiwiaGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiaW1hZ2VMb2FkZWQiLCJsb2FkZWRBc3NldHMiLCJ0b3RhbEltYWdlcyIsImxvYWRlZEZvb3RhZ2VzQ291bnQiLCJ0b3RhbEZvb3RhZ2VzIiwiaW1hZ2VzTG9hZGVkQ2IiLCJmb290YWdlTG9hZGVkIiwiZ2V0QXNzZXRzUGF0aCIsImFzc2V0RGF0YSIsImFzc2V0c1BhdGgiLCJvcmlnaW5hbFBhdGgiLCJpbWFnZVBhdGgiLCJ1IiwidGVzdEltYWdlTG9hZGVkIiwiaW1nIiwiaW50ZXJ2YWxJZCIsInNldEludGVydmFsIiwiYm94IiwiZ2V0QkJveCIsIl9pbWFnZUxvYWRlZCIsImNsZWFySW50ZXJ2YWwiLCJiaW5kIiwiY3JlYXRlSW1hZ2VEYXRhIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9iIiwic2V0QXR0cmlidXRlTlMiLCJfZWxlbWVudEhlbHBlciIsImFwcGVuZCIsImFwcGVuZENoaWxkIiwiY3JlYXRlSW1nRGF0YSIsImNyb3NzT3JpZ2luIiwiY3JlYXRlRm9vdGFnZURhdGEiLCJmb290YWdlRGF0YSIsIl9mb290YWdlTG9hZGVkIiwibG9hZEFzc2V0cyIsImNiIiwiaW1hZ2VzIiwiX2NyZWF0ZUltYWdlRGF0YSIsInNldFBhdGgiLCJzZXRBc3NldHNQYXRoIiwiZ2V0QXNzZXQiLCJkZXN0cm95IiwibG9hZGVkSW1hZ2VzIiwibG9hZGVkRm9vdGFnZXMiLCJzZXRDYWNoZVR5cGUiLCJlbGVtZW50SGVscGVyIiwiSW1hZ2VQcmVsb2FkZXJGYWN0b3J5IiwiQmFzZUV2ZW50IiwidHJpZ2dlckV2ZW50IiwiZXZlbnROYW1lIiwiYXJncyIsIl9jYnMiLCJjYWxsYmFja3MiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3BsaWNlIiwibWFya2VyUGFyc2VyIiwicGFyc2VQYXlsb2FkTGluZXMiLCJsaW5lcyIsImtleXMiLCJsaW5lIiwia2V5c0NvdW50IiwidHJpbSIsIkVycm9yIiwiX21hcmtlcnMiLCJtYXJrZXJzIiwiX21hcmtlciIsIm1hcmtlckRhdGEiLCJ0aW1lIiwidG0iLCJkdXJhdGlvbiIsImRyIiwiY20iLCJfIiwiX18iLCJuYW1lIiwiUHJvamVjdEludGVyZmFjZSIsInJlZ2lzdGVyQ29tcG9zaXRpb24iLCJjb21wb3NpdGlvbnMiLCJfdGhpc1Byb2plY3RGdW5jdGlvbiIsIm5tIiwicHJlcGFyZUZyYW1lIiwieHQiLCJjdXJyZW50RnJhbWUiLCJjb21wSW50ZXJmYWNlIiwicmVuZGVyZXJzIiwicmVnaXN0ZXJSZW5kZXJlciIsImtleSIsImdldFJlbmRlcmVyIiwiZ2V0UmVnaXN0ZXJlZFJlbmRlcmVyIiwiX3R5cGVvZiQ0IiwiQW5pbWF0aW9uSXRlbSIsImlzTG9hZGVkIiwiY3VycmVudFJhd0ZyYW1lIiwiZnJhbWVSYXRlIiwiZnJhbWVNdWx0IiwicGxheVNwZWVkIiwicGxheURpcmVjdGlvbiIsInBsYXlDb3VudCIsImlzUGF1c2VkIiwiYXV0b3BsYXkiLCJsb29wIiwicmVuZGVyZXIiLCJhbmltYXRpb25JRCIsInRpbWVDb21wbGV0ZWQiLCJzZWdtZW50UG9zIiwiaXNTdWJmcmFtZUVuYWJsZWQiLCJzZWdtZW50cyIsIl9pZGxlIiwiX2NvbXBsZXRlZExvb3AiLCJwcm9qZWN0SW50ZXJmYWNlIiwiaW1hZ2VQcmVsb2FkZXIiLCJhdWRpb0NvbnRyb2xsZXIiLCJjb25maWdBbmltYXRpb24iLCJvblNldHVwRXJyb3IiLCJvblNlZ21lbnRDb21wbGV0ZSIsImRyYXduRnJhbWVFdmVudCIsInNldFBhcmFtcyIsInBhcmFtcyIsIndyYXBwZXIiLCJjb250YWluZXIiLCJhbmltVHlwZSIsIlJlbmRlcmVyQ2xhc3MiLCJyZW5kZXJlclNldHRpbmdzIiwiZ2xvYmFsRGF0YSIsImRlZnMiLCJzZXRQcm9qZWN0SW50ZXJmYWNlIiwidW5kZWZpbmVkIiwicGFyc2VJbnQiLCJhdXRvbG9hZFNlZ21lbnRzIiwiaW5pdGlhbFNlZ21lbnQiLCJzZXR1cEFuaW1hdGlvbiIsImxhc3RJbmRleE9mIiwic3Vic3RyIiwiZmlsZU5hbWUiLCJ0cmlnZ2VyIiwic2V0RGF0YSIsIndyYXBwZXJBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsImdldE5hbWVkSXRlbSIsInByZXJlbmRlciIsImluY2x1ZGVMYXllcnMiLCJuZXdMYXllcnMiLCJmb250cyIsImZvbnRNYW5hZ2VyIiwiYWRkQ2hhcnMiLCJhZGRGb250cyIsImluaXRFeHByZXNzaW9ucyIsImxvYWROZXh0U2VnbWVudCIsInNlZ21lbnQiLCJzaGlmdCIsInNlZ21lbnRQYXRoIiwibG9hZFNlZ21lbnRzIiwiaW1hZ2VzTG9hZGVkIiwiY2hlY2tMb2FkZWQiLCJwcmVsb2FkSW1hZ2VzIiwiYW5pbURhdGEiLCJmciIsInNlYXJjaEV4dHJhQ29tcG9zaXRpb25zIiwidXBkYUZyYW1lTW9kaWZpZXIiLCJ3YWl0Rm9yRm9udHNMb2FkZWQiLCJ0cmlnZ2VyQ29uZmlnRXJyb3IiLCJzZXRUaW1lb3V0IiwicmVuZGVyZXJUeXBlIiwiaW5pdEl0ZW1zIiwiZ290b0ZyYW1lIiwicmVzaXplIiwiX3dpZHRoIiwiX2hlaWdodCIsInVwZGF0ZUNvbnRhaW5lclNpemUiLCJzZXRTdWJmcmFtZSIsInJlbmRlckZyYW1lIiwicmVzZXRGcmFtZSIsInRyaWdnZXJSZW5kZXJGcmFtZUVycm9yIiwidG9nZ2xlUGF1c2UiLCJzdG9wIiwic2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUiLCJnZXRNYXJrZXJEYXRhIiwibWFya2VyTmFtZSIsIm1hcmtlciIsImdvVG9BbmRTdG9wIiwiaXNGcmFtZSIsIm51bVZhbHVlIiwiTnVtYmVyIiwiaXNOYU4iLCJmcmFtZU1vZGlmaWVyIiwiZ29Ub0FuZFBsYXkiLCJwbGF5U2VnbWVudHMiLCJhZHZhbmNlVGltZSIsIm5leHRWYWx1ZSIsIl9pc0NvbXBsZXRlIiwiY2hlY2tTZWdtZW50cyIsImFkanVzdFNlZ21lbnQiLCJzZXRTcGVlZCIsInNldERpcmVjdGlvbiIsInNldFNlZ21lbnQiLCJpbml0IiwiZW5kIiwicGVuZGluZ0ZyYW1lIiwiZm9yY2VGbGFnIiwicmVzZXRTZWdtZW50cyIsIm9uRW50ZXJGcmFtZSIsIm9uTG9vcENvbXBsZXRlIiwib25TZWdtZW50U3RhcnQiLCJvbkRlc3Ryb3kiLCJzZXRMb29wIiwiaXNMb29waW5nIiwiZ2V0UGF0aCIsImdldEFzc2V0RGF0YSIsImhpZGUiLCJzaG93IiwiZ2V0RHVyYXRpb24iLCJ1cGRhdGVEb2N1bWVudERhdGEiLCJpbmRleCIsImdldEVsZW1lbnRCeVBhdGgiLCJhbmltYXRpb25NYW5hZ2VyIiwicmVnaXN0ZXJlZEFuaW1hdGlvbnMiLCJpbml0VGltZSIsInBsYXlpbmdBbmltYXRpb25zTnVtIiwiX3N0b3BwZWQiLCJfaXNGcm96ZW4iLCJyZW1vdmVFbGVtZW50IiwiZXYiLCJhbmltSXRlbSIsInN1YnRyYWN0UGxheWluZ0NvdW50IiwicmVnaXN0ZXJBbmltYXRpb24iLCJlbGVtIiwiZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMiLCJsZW5BbmltcyIsImFuaW1hdGlvbnMiLCJhZGRQbGF5aW5nQ291bnQiLCJhY3RpdmF0ZSIsIm5vd1RpbWUiLCJlbGFwc2VkVGltZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImZpcnN0Iiwic2VhcmNoQW5pbWF0aW9ucyIsInN0YW5kYWxvbmUiLCJhbmltRWxlbWVudHMiLCJjb25jYXQiLCJzbGljZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzZXRBdHRyaWJ1dGUiLCJib2R5IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJpbm5lclRleHQiLCJkaXYiLCJmcmVlemUiLCJ1bmZyZWV6ZSIsIkJlemllckZhY3RvcnkiLCJnZXRCZXppZXJFYXNpbmciLCJiZXppZXJzIiwic3RyIiwicmVwbGFjZSIsImJlekVhc2luZyIsIkJlemllckVhc2luZyIsIk5FV1RPTl9JVEVSQVRJT05TIiwiTkVXVE9OX01JTl9TTE9QRSIsIlNVQkRJVklTSU9OX1BSRUNJU0lPTiIsIlNVQkRJVklTSU9OX01BWF9JVEVSQVRJT05TIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImZsb2F0MzJBcnJheVN1cHBvcnRlZCIsIkEiLCJhQTEiLCJhQTIiLCJCIiwiQyIsImNhbGNCZXppZXIiLCJhVCIsImdldFNsb3BlIiwiYmluYXJ5U3ViZGl2aWRlIiwiYVgiLCJhQSIsImFCIiwibVgxIiwibVgyIiwiY3VycmVudFgiLCJjdXJyZW50VCIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsInBvaW50cyIsIl9wIiwiX21TYW1wbGVWYWx1ZXMiLCJfcHJlY29tcHV0ZWQiLCJnZXQiLCJ4IiwibVkxIiwibVkyIiwiX3ByZWNvbXB1dGUiLCJfZ2V0VEZvclgiLCJfY2FsY1NhbXBsZVZhbHVlcyIsIm1TYW1wbGVWYWx1ZXMiLCJpbnRlcnZhbFN0YXJ0IiwiY3VycmVudFNhbXBsZSIsImxhc3RTYW1wbGUiLCJkaXN0IiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwicG9vbGluZyIsIl9kb3VibGUiLCJwb29sRmFjdG9yeSIsImluaXRpYWxMZW5ndGgiLCJfY3JlYXRlIiwiX3JlbGVhc2UiLCJfbGVuZ3RoIiwiX21heExlbmd0aCIsInBvb2wiLCJuZXdFbGVtZW50IiwicmVsZWFzZSIsImJlemllckxlbmd0aFBvb2wiLCJjcmVhdGUiLCJhZGRlZExlbmd0aCIsInBlcmNlbnRzIiwibGVuZ3RocyIsInNlZ21lbnRzTGVuZ3RoUG9vbCIsInRvdGFsTGVuZ3RoIiwiYmV6RnVuY3Rpb24iLCJtYXRoIiwicG9pbnRPbkxpbmUyRCIsIngxIiwieTEiLCJ4MiIsInkyIiwieDMiLCJ5MyIsImRldDEiLCJwb2ludE9uTGluZTNEIiwiejEiLCJ6MiIsInozIiwiZGlzdDEiLCJkaXN0MiIsImRpc3QzIiwiZGlmZkRpc3QiLCJnZXRCZXppZXJMZW5ndGgiLCJwdDEiLCJwdDIiLCJwdDMiLCJwdDQiLCJjdXJ2ZVNlZ21lbnRzIiwicHRDb29yZCIsInBlcmMiLCJwdERpc3RhbmNlIiwicG9pbnQiLCJsYXN0UG9pbnQiLCJsZW5ndGhEYXRhIiwiZ2V0U2VnbWVudHNMZW5ndGgiLCJzaGFwZURhdGEiLCJzZWdtZW50c0xlbmd0aCIsInBhdGhWIiwicGF0aE8iLCJwYXRoSSIsIkJlemllckRhdGEiLCJzZWdtZW50TGVuZ3RoIiwiUG9pbnREYXRhIiwicGFydGlhbCIsInBhcnRpYWxMZW5ndGgiLCJidWlsZEJlemllckRhdGEiLCJzdG9yZWREYXRhIiwiYmV6aWVyTmFtZSIsImJlemllckRhdGEiLCJnZXREaXN0YW5jZVBlcmMiLCJpbml0UG9zIiwibGVuZ3RoUG9zIiwibFBlcmMiLCJkaXIiLCJnZXRQb2ludEluU2VnbWVudCIsInBlcmNlbnQiLCJ0MSIsInUxIiwicHRYIiwicHRZIiwiYmV6aWVyU2VnbWVudFBvaW50cyIsImdldE5ld1NlZ21lbnQiLCJzdGFydFBlcmMiLCJlbmRQZXJjIiwidDAiLCJ1MCIsInUwdTB1MCIsInQwdTB1MF8zIiwidDB0MHUwXzMiLCJ0MHQwdDAiLCJ1MHUwdTEiLCJ0MHUwdTFfMyIsInQwdDB1MV8zIiwidDB0MHQxIiwidTB1MXUxIiwidDB1MXUxXzMiLCJ0MHQxdTFfMyIsInQwdDF0MSIsInUxdTF1MSIsInQxdTF1MV8zIiwidDF0MXUxXzMiLCJ0MXQxdDEiLCJiZXoiLCJpbml0RnJhbWUiLCJtYXRoQWJzIiwiaW50ZXJwb2xhdGVWYWx1ZSIsImZyYW1lTnVtIiwiY2FjaGluZyIsIm9mZnNldFRpbWUiLCJuZXdWYWx1ZSIsInByb3BUeXBlIiwicHYiLCJpdGVyYXRpb25JbmRleCIsImxhc3RJbmRleCIsImtleWZyYW1lcyIsImtleURhdGEiLCJuZXh0S2V5RGF0YSIsImtleWZyYW1lTWV0YWRhdGEiLCJrZXlmcmFtZXNNZXRhZGF0YSIsImZuYyIsIm5leHRLZXlUaW1lIiwia2V5VGltZSIsImVuZFZhbHVlIiwidG8iLCJ0aSIsImluZCIsIl9fZm5jdCIsInkiLCJuIiwiZGlzdGFuY2VJbkxpbmUiLCJzZWdtZW50UGVyYyIsImxhc3RGcmFtZSIsIl9sYXN0S2V5ZnJhbWVJbmRleCIsIl9sYXN0QWRkZWRMZW5ndGgiLCJfbGFzdFBvaW50Iiwib3V0WCIsIm91dFkiLCJpblgiLCJpblkiLCJrZXlWYWx1ZSIsInNoIiwicXVhdFN0YXJ0IiwiY3JlYXRlUXVhdGVybmlvbiIsInF1YXRFbmQiLCJxdWF0ZXJuaW9uVG9FdWxlciIsInNsZXJwIiwib3V0IiwiYXgiLCJheSIsImF6IiwiYXciLCJieCIsImJ5IiwiYnoiLCJidyIsIm9tZWdhIiwiY29zb20iLCJzaW5vbSIsInNjYWxlMCIsInNjYWxlMSIsImFjb3MiLCJzaW4iLCJxdWF0IiwicXgiLCJxeSIsInF6IiwicXciLCJoZWFkaW5nIiwiYXRhbjIiLCJhdHRpdHVkZSIsImFzaW4iLCJiYW5rIiwidmFsdWVzIiwiYzEiLCJjb3MiLCJjMiIsImMzIiwiczEiLCJzMiIsInMzIiwidyIsInoiLCJnZXRWYWx1ZUF0Q3VycmVudFRpbWUiLCJyZW5kZXJlZEZyYW1lIiwiZW5kVGltZSIsIl9jYWNoaW5nIiwicmVuZGVyUmVzdWx0Iiwic2V0VlZhbHVlIiwibXVsdGlwbGllZFZhbHVlIiwibXVsdCIsIl9tZGYiLCJwcm9jZXNzRWZmZWN0c1NlcXVlbmNlIiwiZnJhbWVJZCIsImVmZmVjdHNTZXF1ZW5jZSIsImxvY2siLCJfaXNGaXJzdEZyYW1lIiwiZmluYWxWYWx1ZSIsImtmIiwiYWRkRWZmZWN0IiwiZWZmZWN0RnVuY3Rpb24iLCJhZGREeW5hbWljUHJvcGVydHkiLCJWYWx1ZVByb3BlcnR5IiwidmVsIiwiZ2V0VmFsdWUiLCJNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkiLCJLZXlmcmFtZWRWYWx1ZVByb3BlcnR5IiwiS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5IiwiYXJyTGVuIiwiUHJvcGVydHlGYWN0b3J5IiwiZ2V0UHJvcCIsInNpZCIsInNsb3RNYW5hZ2VyIiwiRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyIiwiZHluYW1pY1Byb3BlcnRpZXMiLCJfaXNBbmltYXRlZCIsIml0ZXJhdGVEeW5hbWljUHJvcGVydGllcyIsImluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIiLCJwb2ludFBvb2wiLCJTaGFwZVBhdGgiLCJzZXRQYXRoRGF0YSIsInNldExlbmd0aCIsImRvdWJsZUFycmF5TGVuZ3RoIiwic2V0WFlBdCIsInBvcyIsInNldFRyaXBsZUF0IiwidlgiLCJ2WSIsIm9YIiwib1kiLCJpWCIsImlZIiwicmV2ZXJzZSIsIm5ld1BhdGgiLCJ2ZXJ0aWNlcyIsIm91dFBvaW50cyIsImluUG9pbnRzIiwiY250Iiwic2hhcGVQb29sIiwic2hhcGVQYXRoIiwiY2xvbmUiLCJzaGFwZSIsImNsb25lZCIsIlNoYXBlQ29sbGVjdGlvbiIsImFkZFNoYXBlIiwicmVsZWFzZVNoYXBlcyIsInNoYXBlQ29sbGVjdGlvblBvb2wiLCJuZXdTaGFwZUNvbGxlY3Rpb24iLCJzaGFwZUNvbGxlY3Rpb24iLCJTaGFwZVByb3BlcnR5RmFjdG9yeSIsImludGVycG9sYXRlU2hhcGUiLCJwcmV2aW91c1ZhbHVlIiwia2V5UHJvcFMiLCJrZXlQcm9wRSIsImlzSG9sZCIsInZlcnRleFZhbHVlIiwiaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lIiwicmVzZXRTaGFwZSIsInBhdGhzIiwibG9jYWxTaGFwZUNvbGxlY3Rpb24iLCJzaGFwZXNFcXVhbCIsInNoYXBlMSIsInNoYXBlMiIsIlNoYXBlUHJvcGVydHkiLCJyZXNldCIsIktleWZyYW1lZFNoYXBlUHJvcGVydHkiLCJFbGxTaGFwZVByb3BlcnR5IiwiY1BvaW50IiwiRWxsU2hhcGVQcm9wZXJ0eUZhY3RvcnkiLCJjb252ZXJ0RWxsVG9QYXRoIiwicDAiLCJwMSIsInMwIiwiX2N3IiwiX3YiLCJTdGFyU2hhcGVQcm9wZXJ0eSIsIlN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeSIsInN5IiwiaXIiLCJpcyIsImNvbnZlcnRUb1BhdGgiLCJjb252ZXJ0U3RhclRvUGF0aCIsImNvbnZlcnRQb2x5Z29uVG9QYXRoIiwib3IiLCJvcyIsIm51bVB0cyIsImFuZ2xlIiwibG9uZ0ZsYWciLCJsb25nUmFkIiwic2hvcnRSYWQiLCJsb25nUm91bmQiLCJzaG9ydFJvdW5kIiwibG9uZ1BlcmltU2VnbWVudCIsInNob3J0UGVyaW1TZWdtZW50IiwicmFkIiwicm91bmRuZXNzIiwicGVyaW1TZWdtZW50IiwiY3VycmVudEFuZyIsIm94Iiwib3kiLCJSZWN0U2hhcGVQcm9wZXJ0eSIsIlJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeSIsImNvbnZlcnRSZWN0VG9QYXRoIiwidjAiLCJ2MSIsImdldFNoYXBlUHJvcCIsImRhdGFQcm9wIiwiZ2V0Q29uc3RydWN0b3JGdW5jdGlvbiIsImdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb24iLCJNYXRyaXgiLCJfY29zIiwiX3NpbiIsIl90YW4iLCJ0YW4iLCJfcm5kIiwicHJvcHMiLCJyb3RhdGUiLCJtQ29zIiwibVNpbiIsIl90Iiwicm90YXRlWCIsInJvdGF0ZVkiLCJyb3RhdGVaIiwic2hlYXIiLCJzeCIsInNrZXciLCJza2V3RnJvbUF4aXMiLCJzY2FsZSIsInN6Iiwic2V0VHJhbnNmb3JtIiwibCIsIm0iLCJ0cmFuc2xhdGUiLCJ0eCIsInR6IiwidHJhbnNmb3JtIiwiYTIiLCJiMiIsImQyIiwiZTIiLCJmMiIsImcyIiwiaDIiLCJpMiIsImoyIiwiazIiLCJsMiIsIm0yIiwibjIiLCJvMiIsInAyIiwiX2lkZW50aXR5Q2FsY3VsYXRlZCIsImExIiwiYjEiLCJkMSIsImUxIiwiZjEiLCJnMSIsImgxIiwiaTEiLCJqMSIsImsxIiwibDEiLCJtMSIsIm4xIiwibzEiLCJtdWx0aXBseSIsIm1hdHJpeCIsIm1hdHJpeFByb3BzIiwiaXNJZGVudGl0eSIsIl9pZGVudGl0eSIsImVxdWFscyIsIm1hdHIiLCJjbG9uZUZyb21Qcm9wcyIsImFwcGx5VG9Qb2ludCIsImFwcGx5VG9YIiwiYXBwbHlUb1kiLCJhcHBseVRvWiIsImdldEludmVyc2VNYXRyaXgiLCJkZXRlcm1pbmFudCIsImludmVyc2VNYXRyaXgiLCJpbnZlcnNlUG9pbnQiLCJhcHBseVRvUG9pbnRBcnJheSIsImludmVyc2VQb2ludHMiLCJwdHMiLCJyZXRQdHMiLCJhcHBseVRvVHJpcGxlUG9pbnRzIiwicDQiLCJwNSIsInAxMiIsInAxMyIsImFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkIiwidG9DU1MiLCJjc3NWYWx1ZSIsInJvdW5kTWF0cml4UHJvcGVydHkiLCJ0bzJkQ1NTIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX3R5cGVvZiQzIiwic2V0TG9jYXRpb24iLCJocmVmIiwic2V0U3ViZnJhbWVSZW5kZXJpbmciLCJzZXRQcmVmaXgiLCJwcmVmaXgiLCJzZXRRdWFsaXR5IiwiaW5Ccm93c2VyIiwiaW5zdGFsbFBsdWdpbiIsInBsdWdpbiIsImdldEZhY3RvcnkiLCJ1c2VXZWJXb3JrZXIiLCJzZXRJRFByZWZpeCIsIl9fZ2V0RmFjdG9yeSIsInZlcnNpb24iLCJjaGVja1JlYWR5IiwicmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwiLCJnZXRRdWVyeVZhcmlhYmxlIiwidmFyaWFibGUiLCJ2YXJzIiwicXVlcnlTdHJpbmciLCJwYWlyIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic2NyaXB0cyIsIm15U2NyaXB0IiwiYm9keW1vdmluIiwiU2hhcGVNb2RpZmllcnMiLCJtb2RpZmllcnMiLCJyZWdpc3Rlck1vZGlmaWVyIiwiZ2V0TW9kaWZpZXIiLCJTaGFwZU1vZGlmaWVyIiwiaW5pdE1vZGlmaWVyUHJvcGVydGllcyIsImFkZFNoYXBlVG9Nb2RpZmllciIsInNldEFzQW5pbWF0ZWQiLCJwcm9jZXNzS2V5cyIsIlRyaW1Nb2RpZmllciIsInNWYWx1ZSIsImVWYWx1ZSIsInBhdGhzRGF0YSIsImNhbGN1bGF0ZVNoYXBlRWRnZXMiLCJzaGFwZUxlbmd0aCIsInRvdGFsTW9kaWZpZXJMZW5ndGgiLCJzaGFwZVNlZ21lbnRzIiwic2VnbWVudE9iIiwic2hhcGVTIiwic2hhcGVFIiwicmVsZWFzZVBhdGhzRGF0YSIsInByb2Nlc3NTaGFwZXMiLCJfcyIsInNoYXBlUGF0aHMiLCJ0b3RhbFNoYXBlTGVuZ3RoIiwiZWRnZXMiLCJuZXdTaGFwZXNEYXRhIiwiYWRkU2hhcGVzIiwibGFzdFNoYXBlSW5Db2xsZWN0aW9uIiwibGFzdFNoYXBlIiwicG9wIiwiYWRkUGF0aHMiLCJuZXdQYXRocyIsImFkZFNlZ21lbnQiLCJuZXdTaGFwZSIsImFkZFNlZ21lbnRGcm9tQXJyYXkiLCJzaGFwZVNlZ21lbnQiLCJjdXJyZW50TGVuZ3RoRGF0YSIsInNlZ21lbnRDb3VudCIsIlB1Y2tlckFuZEJsb2F0TW9kaWZpZXIiLCJhbW91bnQiLCJwcm9jZXNzUGF0aCIsImNlbnRlclBvaW50IiwicGF0aExlbmd0aCIsImNsb25lZFBhdGgiLCJUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkiLCJkZWZhdWx0VmVjdG9yIiwiYXBwbHlUb01hdHJpeCIsIm1hdCIsInJ6IiwicnkiLCJyeCIsInB4IiwicHkiLCJweiIsImZvcmNlUmVuZGVyIiwiX2lzRGlydHkiLCJwcmVjYWxjdWxhdGVNYXRyaXgiLCJwcmUiLCJhcHBsaWVkVHJhbnNmb3JtYXRpb25zIiwiYXV0b09yaWVudGVkIiwidjIiLCJnZXRWYWx1ZUF0VGltZSIsImF1dG9PcmllbnQiLCJfYWRkRHluYW1pY1Byb3BlcnR5IiwiVHJhbnNmb3JtUHJvcGVydHkiLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eSIsIlJlcGVhdGVyTW9kaWZpZXIiLCJ0ciIsInNvIiwiZW8iLCJwTWF0cml4Iiwick1hdHJpeCIsInNNYXRyaXgiLCJ0TWF0cml4IiwiYXBwbHlUcmFuc2Zvcm1zIiwiaW52Iiwic2NhbGVYIiwic2NhbGVZIiwiZWxlbXNEYXRhIiwiX2N1cnJlbnRDb3BpZXMiLCJfZWxlbWVudHMiLCJfZ3JvdXBzIiwidW5zaGlmdCIsInJlc2V0RWxlbWVudHMiLCJlbGVtZW50cyIsIl9wcm9jZXNzZWQiLCJjbG9uZUVsZW1lbnRzIiwibmV3RWxlbWVudHMiLCJjaGFuZ2VHcm91cFJlbmRlciIsInJlbmRlckZsYWciLCJfcmVuZGVyIiwiaXRlbXMiLCJpdGVtc1RyYW5zZm9ybSIsImNvbnQiLCJoYXNSZWxvYWRlZCIsImNvcGllcyIsImNlaWwiLCJncm91cCIsIml4IiwicmVsb2FkU2hhcGVzIiwiZWxlbXMiLCJ0cmFuc2Zvcm1EYXRhIiwib2Zmc2V0TW9kdWxvIiwicm91bmRPZmZzZXQiLCJwUHJvcHMiLCJyUHJvcHMiLCJzUHJvcHMiLCJpdGVyYXRpb24iLCJtUHJvcHMiLCJSb3VuZENvcm5lcnNNb2RpZmllciIsInJkIiwiY3VycmVudFYiLCJjdXJyZW50SSIsImN1cnJlbnRPIiwiY2xvc2VyViIsImRpc3RhbmNlIiwibmV3UG9zUGVyYyIsImZsb2F0RXF1YWwiLCJmbG9hdFplcm8iLCJsZXJwIiwibGVycFBvaW50IiwicXVhZFJvb3RzIiwic2luZ2xlUm9vdCIsImRlbHRhIiwicG9seW5vbWlhbENvZWZmaWNpZW50cyIsInAzIiwic2luZ2xlUG9pbnQiLCJQb2x5bm9taWFsQmV6aWVyIiwibGluZWFyaXplIiwicG9pbnRFcXVhbCIsImNvZWZmeCIsImNvZWZmeSIsImRlcml2YXRpdmUiLCJ0YW5nZW50QW5nbGUiLCJub3JtYWxBbmdsZSIsImluZmxlY3Rpb25Qb2ludHMiLCJkZW5vbSIsInRjdXNwIiwic3F1YXJlIiwicm9vdCIsImZpbHRlciIsInAxMCIsInAxMSIsInAyMCIsInAyMSIsImV4dHJlbWEiLCJib3VuZHMiLCJib3VuZGluZ0JveCIsInJpZ2h0IiwiYm90dG9tIiwiY3giLCJjeSIsImludGVyc2VjdERhdGEiLCJ0MiIsInNwbGl0RGF0YSIsImJveEludGVyc2VjdCIsImludGVyc2VjdHNJbXBsIiwiZGVwdGgiLCJ0b2xlcmFuY2UiLCJpbnRlcnNlY3Rpb25zIiwibWF4UmVjdXJzaW9uIiwiZDFzIiwiZDJzIiwib3RoZXIiLCJuZXh0SW5kZXgiLCJzaGFwZVNlZ21lbnRJbnZlcnRlZCIsImNyb3NzUHJvZHVjdCIsImxpbmVJbnRlcnNlY3Rpb24iLCJzdGFydDEiLCJlbmQxIiwic3RhcnQyIiwiZW5kMiIsInYzIiwidjQiLCJwb2xhck9mZnNldCIsInBvaW50RGlzdGFuY2UiLCJoeXBvdCIsIlppZ1phZ01vZGlmaWVyIiwiYW1wbGl0dWRlIiwiZnJlcXVlbmN5IiwicG9pbnRzVHlwZSIsInNldFBvaW50Iiwib3V0cHV0QmV6aWVyIiwib3V0QW1wbGl0dWRlIiwiaW5BbXBsaXR1ZGUiLCJhbmdPIiwiYW5nSSIsImdldFBlcnBlbmRpY3VsYXJWZWN0b3IiLCJ2ZWN0b3IiLCJyb3QiLCJyb3RhdGVkVmVjdG9yIiwiZ2V0UHJvamVjdGluZ0FuZ2xlIiwiY3VyIiwicHJldkluZGV4IiwicHJldlBvaW50IiwibmV4dFBvaW50IiwicFZlY3RvciIsInppZ1phZ0Nvcm5lciIsInBvaW50VHlwZSIsInByZXZEaXN0IiwibmV4dERpc3QiLCJ6aWdaYWdTZWdtZW50IiwiY291bnQiLCJsaW5lYXJPZmZzZXQiLCJvZmZzZXRTZWdtZW50IiwicDFhIiwicDFiIiwicDJiIiwicDJhIiwiam9pbkxpbmVzIiwic2VnMSIsInNlZzIiLCJsaW5lSm9pbiIsIm1pdGVyTGltaXQiLCJhbmdsZU91dCIsImFuZ2xlSW4iLCJjZW50ZXIiLCJyYWRpdXMiLCJpbnRlcnNlY3Rpb24iLCJnZXRJbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3QiLCJwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24iLCJvdXRhIiwib3V0YiIsInBydW5lSW50ZXJzZWN0aW9ucyIsIm9mZnNldFNlZ21lbnRTcGxpdCIsImZsZXgiLCJtaWQiLCJPZmZzZXRQYXRoTW9kaWZpZXIiLCJtbCIsImxqIiwiaW5wdXRCZXppZXIiLCJtdWx0aVNlZ21lbnRzIiwibGFzdFNlZyIsIm11bHRpU2VnbWVudCIsImdldEZvbnRQcm9wZXJ0aWVzIiwiZm9udERhdGEiLCJzdHlsZXMiLCJmU3R5bGUiLCJmV2VpZ2h0Iiwic3R5bGVOYW1lIiwidG9Mb3dlckNhc2UiLCJ3ZWlnaHQiLCJGb250TWFuYWdlciIsIm1heFdhaXRpbmdUaW1lIiwiZW1wdHlDaGFyIiwic2l6ZSIsImNvbWJpbmVkQ2hhcmFjdGVycyIsIkJMQUNLX0ZMQUdfQ09ERV9QT0lOVCIsIkNBTkNFTF9UQUdfQ09ERV9QT0lOVCIsIkFfVEFHX0NPREVfUE9JTlQiLCJaX1RBR19DT0RFX1BPSU5UIiwiVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQiLCJaRVJPX1dJRFRIX0pPSU5FUl9DT0RFX1BPSU5UIiwiUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCIsIlJFR0lPTkFMX0NIQVJBQ1RFUl9aX0NPREVfUE9JTlQiLCJzdXJyb2dhdGVNb2RpZmllcnMiLCJ0cmltRm9udE9wdGlvbnMiLCJmb250IiwiZmFtaWx5QXJyYXkiLCJlbmFibGVkRmFtaWxpZXMiLCJzZXRVcE5vZGUiLCJmYW1pbHkiLCJwYXJlbnROb2RlIiwiZm9udEZhbWlseSIsIm5vZGUiLCJmb250U2l6ZSIsImZvbnRWYXJpYW50IiwiZm9udFN0eWxlIiwiZm9udFdlaWdodCIsImxldHRlclNwYWNpbmciLCJvZmZzZXRXaWR0aCIsInBhcmVudCIsImNoZWNrTG9hZGVkRm9udHMiLCJsb2FkZWRDb3VudCIsImxvYWRlZCIsImZPcmlnaW4iLCJtb25vQ2FzZSIsInNhbnNDYXNlIiwicmVtb3ZlQ2hpbGQiLCJEYXRlIiwibm93IiwiY2hlY2tMb2FkZWRGb250c0JpbmRlZCIsInNldElzTG9hZGVkQmluZGVkIiwiY3JlYXRlSGVscGVyIiwiZGVmIiwiZW5naW5lIiwiaGVscGVyIiwiZm9udFByb3BzIiwidEhlbHBlciIsImZGYW1pbHkiLCJ0ZXh0Q29udGVudCIsImZDbGFzcyIsInRDYW52YXNIZWxwZXIiLCJPZmZzY3JlZW5DYW52YXMiLCJtZWFzdXJlIiwidGV4dCIsImdldENvbXB1dGVkVGV4dExlbmd0aCIsIm1lYXN1cmVUZXh0IiwibGlzdCIsImZvckVhY2giLCJjYWNoZSIsImZvbnRBcnIiLCJfcGVuZGluZ0ZvbnRzIiwic2hvdWxkTG9hZEZvbnQiLCJsb2FkZWRTZWxlY3RvciIsImZQYXRoIiwicXVlcnlTZWxlY3RvckFsbCIsInJlbCIsInNjIiwiZm91bmQiLCJjaCIsImdldENoYXJEYXRhIiwiX2NoYXIiLCJjaGFyQ29kZUF0IiwiY29uc29sZSIsIndhcm4iLCJfd2FybmVkIiwiX2NoYXIyIiwiZm9udE5hbWUiLCJnZXRGb250QnlOYW1lIiwiZG91YmxlU2l6ZSIsInNpbmdsZVNpemUiLCJmTmFtZSIsImdldENvZGVQb2ludCIsInN0cmluZyIsImNvZGVQb2ludCIsInNlY29uZCIsImlzTW9kaWZpZXIiLCJmaXJzdENoYXJDb2RlIiwic2Vjb25kQ2hhckNvZGUiLCJzdW0iLCJpc1plcm9XaWR0aEpvaW5lciIsImNoYXJDb2RlIiwiaXNWYXJpYXRpb25TZWxlY3RvciIsImlzUmVnaW9uYWxDb2RlIiwiaXNGbGFnRW1vamkiLCJpc0NvbWJpbmVkQ2hhcmFjdGVyIiwiX2NoYXIzIiwiaXNSZWdpb25hbEZsYWciLCJzZXRJc0xvYWRlZCIsIkZvbnQiLCJ0eXBla2l0TG9hZGVkIiwiZm9udFByb3RvdHlwZSIsIlNsb3RNYW5hZ2VyIiwic2xvdHMiLCJhc3NpZ24iLCJzbG90RmFjdG9yeSIsIlJlbmRlcmFibGVFbGVtZW50IiwiaW5pdFJlbmRlcmFibGUiLCJpc0luUmFuZ2UiLCJoaWRkZW4iLCJpc1RyYW5zcGFyZW50IiwicmVuZGVyYWJsZUNvbXBvbmVudHMiLCJhZGRSZW5kZXJhYmxlQ29tcG9uZW50IiwiY29tcG9uZW50IiwicmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudCIsInByZXBhcmVSZW5kZXJhYmxlRnJhbWUiLCJudW0iLCJjaGVja0xheWVyTGltaXRzIiwiY2hlY2tUcmFuc3BhcmVuY3kiLCJmaW5hbFRyYW5zZm9ybSIsIm1Qcm9wIiwicmVuZGVyQ29uZmlnIiwiaGlkZU9uVHJhbnNwYXJlbnQiLCJyZW5kZXJSZW5kZXJhYmxlIiwic291cmNlUmVjdEF0VGltZSIsImdldExheWVyU2l6ZSIsInRleHREYXRhIiwiZ2V0QmxlbmRNb2RlIiwiYmxlbmRNb2RlRW51bXMiLCJtb2RlIiwiU2xpZGVyRWZmZWN0IiwiQW5nbGVFZmZlY3QiLCJDb2xvckVmZmVjdCIsIlBvaW50RWZmZWN0IiwiTGF5ZXJJbmRleEVmZmVjdCIsIk1hc2tJbmRleEVmZmVjdCIsIkNoZWNrYm94RWZmZWN0IiwiTm9WYWx1ZUVmZmVjdCIsIkVmZmVjdHNNYW5hZ2VyIiwiZWZmZWN0cyIsImVmIiwiZWZmZWN0RWxlbWVudHMiLCJlZmZlY3RJdGVtIiwiR3JvdXBFZmZlY3QiLCJlZmYiLCJCYXNlRWxlbWVudCIsImNoZWNrTWFza3MiLCJMYXllckV4cHJlc3Npb25JbnRlcmZhY2UiLCJFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZSIsIlNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSIsIlRleHRFeHByZXNzaW9uSW50ZXJmYWNlIiwiQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UiLCJsYXllckludGVyZmFjZSIsIm1hc2tNYW5hZ2VyIiwicmVnaXN0ZXJNYXNrSW50ZXJmYWNlIiwiZWZmZWN0c0ludGVyZmFjZSIsImNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UiLCJyZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UiLCJzaGFwZUludGVyZmFjZSIsInNoYXBlc0RhdGEiLCJpdGVtc0RhdGEiLCJjb250ZW50IiwidGV4dEludGVyZmFjZSIsInNldEJsZW5kTW9kZSIsImJsZW5kTW9kZVZhbHVlIiwiYm0iLCJiYXNlRWxlbWVudCIsImxheWVyRWxlbWVudCIsImluaXRCYXNlRGF0YSIsImxheWVySWQiLCJlZmZlY3RzTWFuYWdlciIsImdldFR5cGUiLCJGcmFtZUVsZW1lbnQiLCJwcmVwYXJlUHJvcGVydGllcyIsImlzVmlzaWJsZSIsIl9pc1BhcmVudCIsIkZvb3RhZ2VFbGVtZW50IiwiaW1hZ2VMb2FkZXIiLCJnZXRCYXNlRWxlbWVudCIsIkZvb3RhZ2VJbnRlcmZhY2UiLCJnZXRGb290YWdlRGF0YSIsIkF1ZGlvRWxlbWVudCIsIl9pc1BsYXlpbmciLCJfY2FuUGxheSIsIl9jdXJyZW50VGltZSIsIl92b2x1bWVNdWx0aXBsaWVyIiwiX3ByZXZpb3VzVm9sdW1lIiwiX3BsYWNlaG9sZGVyIiwibHYiLCJhdSIsInRpbWVSZW1hcHBlZCIsInRvdGFsVm9sdW1lIiwidm9sdW1lVmFsdWUiLCJCYXNlUmVuZGVyZXIiLCJjaGVja0xheWVycyIsImJ1aWxkSXRlbSIsImNoZWNrUGVuZGluZ0VsZW1lbnRzIiwiY3JlYXRlSXRlbSIsImxheWVyIiwiY3JlYXRlSW1hZ2UiLCJjcmVhdGVDb21wIiwiY3JlYXRlU29saWQiLCJjcmVhdGVOdWxsIiwiY3JlYXRlU2hhcGUiLCJjcmVhdGVUZXh0IiwiY3JlYXRlQ2FtZXJhIiwiY3JlYXRlRm9vdGFnZSIsImJ1aWxkQWxsSXRlbXMiLCJwSW50ZXJmYWNlIiwicHJvZ3Jlc3NpdmVMb2FkIiwiYnVpbGRFbGVtZW50UGFyZW50aW5nIiwicGFyZW50TmFtZSIsImhpZXJhcmNoeSIsImFkZFBlbmRpbmdFbGVtZW50Iiwic2V0QXNQYXJlbnQiLCJzZXRIaWVyYXJjaHkiLCJwZW5kaW5nRWxlbWVudHMiLCJnZXRFbGVtZW50QnlJZCIsInBhdGhWYWx1ZSIsInNldHVwR2xvYmFsRGF0YSIsImZvbnRzQ29udGFpbmVyIiwiYW5pbWF0aW9uSXRlbSIsImNvbXBTaXplIiwiZWZmZWN0VHlwZXMiLCJUUkFOU0ZPUk1fRUZGRUNUIiwiVHJhbnNmb3JtRWxlbWVudCIsImluaXRUcmFuc2Zvcm0iLCJfbWF0TWRmIiwiX2xvY2FsTWF0TWRmIiwiX29wTWRmIiwibG9jYWxNYXQiLCJsb2NhbE9wYWNpdHkiLCJhbyIsInJlbmRlclRyYW5zZm9ybSIsImZpbmFsTWF0IiwicmVuZGVyTG9jYWxUcmFuc2Zvcm0iLCJsb2NhbFRyYW5zZm9ybXMiLCJsbWF0IiwibG9jYWxPcCIsIm9wYWNpdHkiLCJzZWFyY2hFZmZlY3RUcmFuc2Zvcm1zIiwicmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyIiwidHJhbnNmb3JtRWZmZWN0cyIsImdldEVmZmVjdHMiLCJnbG9iYWxUb0xvY2FsIiwidHJhbnNmb3JtcyIsInB0TmV3IiwibUhlbHBlciIsIk1hc2tFbGVtZW50IiwibWFza0VsZW1lbnQiLCJ2aWV3RGF0YSIsInNvbGlkUGF0aCIsInByb3BlcnRpZXMiLCJjdXJyZW50TWFza3MiLCJyZWN0IiwiZXhwYW5zb3IiLCJmZU1vcnBoIiwibWFza1R5cGUiLCJtYXNrUmVmIiwibGFzdFBhdGgiLCJmaWx0ZXJJRCIsImV4cGFuIiwibGFzdE9wZXJhdG9yIiwiZmlsdGVySWQiLCJsYXN0UmFkaXVzIiwibWFzayIsImNyZWF0ZUxheWVyU29saWRQYXRoIiwiaW52UmVjdCIsImRyYXdQYXRoIiwibWFza2VkRWxlbWVudCIsImdldE1hc2tQcm9wZXJ0eSIsImlzRmlyc3RGcmFtZSIsImdldE1hc2tlbGVtZW50IiwicGF0aE5vZGVzIiwicGF0aFN0cmluZyIsInBhdGhTaGFwZVZhbHVlIiwiZmlsdGVyc0ZhY3RvcnkiLCJjcmVhdGVGaWx0ZXIiLCJjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyIiwiZmlsSWQiLCJza2lwQ29vcmRpbmF0ZXMiLCJmaWwiLCJmZUNvbG9yTWF0cml4IiwiZmVhdHVyZVN1cHBvcnQiLCJzdmdMdW1hSGlkZGVuIiwib2Zmc2NyZWVuQ2FudmFzIiwicmVnaXN0ZXJlZEVmZmVjdHMkMSIsImlkUHJlZml4IiwiU1ZHRWZmZWN0cyIsInNvdXJjZSIsImZpbHRlcnMiLCJmaWx0ZXJNYW5hZ2VyIiwiRWZmZWN0IiwiZWZmZWN0IiwiY291bnRzQXNFZmZlY3QiLCJyZWdpc3RlckVmZmVjdCQxIiwiU1ZHQmFzZUVsZW1lbnQiLCJpbml0UmVuZGVyZXJFbGVtZW50IiwiY3JlYXRlQ29udGFpbmVyRWxlbWVudHMiLCJtYXR0ZUVsZW1lbnQiLCJ0cmFuc2Zvcm1lZEVsZW1lbnQiLCJfc2l6ZUNoYW5nZWQiLCJsYXllckVsZW1lbnRQYXJlbnQiLCJ0ZCIsIm1hdHRlTWFza3MiLCJnZyIsInR0IiwibG4iLCJoZCIsImNwIiwiY2xpcElkIiwiY3BHcm91cCIsInJlbmRlckVsZW1lbnQiLCJkZXN0cm95QmFzZUVsZW1lbnQiLCJjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cyIsImdldE1hdHRlIiwibWF0dGVUeXBlIiwidXNlRWxlbWVudCIsIm1hc2tlciIsIm1hc2tHcm91cCIsIm1hc2tHcm91cGVyIiwiZmVDVHIiLCJmZUZ1bmMiLCJhbHBoYVJlY3QiLCJzZXRNYXR0ZSIsIkhpZXJhcmNoeUVsZW1lbnQiLCJpbml0SGllcmFyY2h5IiwiY2hlY2tQYXJlbnRpbmciLCJSZW5kZXJhYmxlRE9NRWxlbWVudCIsIl9wcm90b3R5cGUiLCJpbml0RWxlbWVudCIsImNyZWF0ZUNvbnRlbnQiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJpbm5lckVsZW0iLCJJSW1hZ2VFbGVtZW50Iiwic291cmNlUmVjdCIsInByIiwiaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiUHJvY2Vzc2VkRWxlbWVudCIsIklTaGFwZUVsZW1lbnQiLCJhZGRTaGFwZVRvTW9kaWZpZXJzIiwic2hhcGVNb2RpZmllcnMiLCJpc1NoYXBlSW5BbmltYXRlZE1vZGlmaWVycyIsImlzQW5pbWF0ZWRXaXRoU2hhcGUiLCJyZW5kZXJNb2RpZmllcnMiLCJzaG91bGRCcmVha1Byb2Nlc3MiLCJzZWFyY2hQcm9jZXNzZWRFbGVtZW50IiwicHJvY2Vzc2VkRWxlbWVudHMiLCJhZGRQcm9jZXNzZWRFbGVtZW50IiwibGluZUNhcEVudW0iLCJsaW5lSm9pbkVudW0iLCJTVkdTaGFwZURhdGEiLCJ0cmFuc2Zvcm1lcnMiLCJsZXZlbCIsImNhY2hlcyIsImxTdHIiLCJsdmwiLCJTVkdTdHlsZURhdGEiLCJwRWxlbSIsIm1zRWxlbSIsIkRhc2hQcm9wZXJ0eSIsImRhdGFQcm9wcyIsImRhc2hTdHIiLCJkYXNoQXJyYXkiLCJkYXNob2Zmc2V0IiwiU1ZHU3Ryb2tlU3R5bGVEYXRhIiwic3R5bGVPYiIsIlNWR0ZpbGxTdHlsZURhdGEiLCJTVkdOb1N0eWxlRGF0YSIsIkdyYWRpZW50UHJvcGVydHkiLCJjTGVuZ3RoIiwiX2NtZGYiLCJfb21kZiIsIl9jb2xsYXBzYWJsZSIsImNoZWNrQ29sbGFwc2FibGUiLCJfaGFzT3BhY2l0eSIsImNvbXBhcmVQb2ludHMiLCJkaWZmIiwiU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIiwiaW5pdEdyYWRpZW50RGF0YSIsInN0b3BzIiwic2V0R3JhZGllbnREYXRhIiwic2V0R3JhZGllbnRPcGFjaXR5IiwicGF0aEVsZW1lbnQiLCJncmFkaWVudElkIiwiZ2ZpbGwiLCJnZiIsImNzdCIsIm9wYWNpdHlJZCIsIm1hc2tJZCIsIm9wRmlsbCIsImxjIiwib2YiLCJtcyIsIm9zdCIsIlNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhIiwiU2hhcGVHcm91cERhdGEiLCJwcmV2Vmlld0RhdGEiLCJnciIsIlNWR1RyYW5zZm9ybURhdGEiLCJidWlsZFNoYXBlU3RyaW5nIiwiX28iLCJfaSIsInNoYXBlU3RyaW5nIiwiU1ZHRWxlbWVudHNSZW5kZXJlciIsIl9pZGVudGl0eU1hdHJpeCIsIl9tYXRyaXhIZWxwZXIiLCJjcmVhdGVSZW5kZXJGdW5jdGlvbiIsInJlbmRlckZpbGwiLCJyZW5kZXJHcmFkaWVudCIsInJlbmRlckdyYWRpZW50U3Ryb2tlIiwicmVuZGVyU3Ryb2tlIiwicmVuZGVyUGF0aCIsInJlbmRlckNvbnRlbnRUcmFuc2Zvcm0iLCJyZW5kZXJOb29wIiwic3R5bGVEYXRhIiwiaXRlbURhdGEiLCJwYXRoU3RyaW5nVHJhbnNmb3JtZWQiLCJyZWRyYXciLCJsTGVuIiwiaXRlcmF0aW9ucyIsInN0eWxlRWxlbSIsImhhc09wYWNpdHkiLCJhdHRyMSIsImF0dHIyIiwiY1ZhbHVlcyIsIm9WYWx1ZXMiLCJhbmciLCJTVkdTaGFwZUVsZW1lbnQiLCJzdHlsZXNMaXN0IiwiYW5pbWF0ZWRDb250ZW50cyIsImluaXRTZWNvbmRhcnlFbGVtZW50IiwiaWRlbnRpdHlNYXRyaXgiLCJidWlsZEV4cHJlc3Npb25JbnRlcmZhY2UiLCJzZWFyY2hTaGFwZXMiLCJmaWx0ZXJVbmlxdWVTaGFwZXMiLCJ0ZW1wU2hhcGVzIiwiYXJlQW5pbWF0ZWQiLCJzZXRTaGFwZXNBc0FuaW1hdGVkIiwiY3JlYXRlU3R5bGVFbGVtZW50IiwiZWxlbWVudERhdGEiLCJHcmFkaWVudENvbnN0cnVjdG9yIiwiYWRkVG9BbmltYXRlZENvbnRlbnRzIiwiY3JlYXRlR3JvdXBFbGVtZW50IiwiY3JlYXRlVHJhbnNmb3JtRWxlbWVudCIsInRyYW5zZm9ybVByb3BlcnR5IiwiY3JlYXRlU2hhcGVFbGVtZW50Iiwib3duVHJhbnNmb3JtZXJzIiwic2hhcGVQcm9wZXJ0eSIsInNldEVsZW1lbnRTdHlsZXMiLCJyZW5kZXIiLCJvd25TdHlsZXMiLCJvd25Nb2RpZmllcnMiLCJjdXJyZW50VHJhbnNmb3JtIiwibW9kaWZpZXIiLCJwcm9jZXNzZWRQb3MiLCJyZW5kZXJTaGFwZSIsImFuaW1hdGVkQ29udGVudCIsIkxldHRlclByb3BzIiwic3ciLCJmYyIsInVwZGF0ZSIsInVwZGF0ZWQiLCJUZXh0UHJvcGVydHkiLCJfZnJhbWVJZCIsImtleXNJbmRleCIsImNhblJlc2l6ZSIsIm1pbmltdW1Gb250U2l6ZSIsImN1cnJlbnREYXRhIiwiYXNjZW50IiwiYm94V2lkdGgiLCJkZWZhdWx0Qm94V2lkdGgiLCJqdXN0aWZ5T2Zmc2V0IiwibGgiLCJsaW5lV2lkdGhzIiwibHMiLCJwcyIsImZpbGxDb2xvckFuaW0iLCJzdHJva2VDb2xvckFuaW0iLCJzdHJva2VXaWR0aEFuaW0iLCJ5T2Zmc2V0IiwiZmluYWxTaXplIiwiZmluYWxUZXh0IiwiZmluYWxMaW5lSGVpZ2h0IiwiY29weURhdGEiLCJzZWFyY2hQcm9wZXJ0eSIsImNvbXBsZXRlVGV4dERhdGEiLCJzZXRDdXJyZW50RGF0YSIsInNlYXJjaEtleWZyYW1lcyIsImdldEtleWZyYW1lVmFsdWUiLCJfZmluYWxWYWx1ZSIsImN1cnJlbnRWYWx1ZSIsImN1cnJlbnRJbmRleCIsInRleHRLZXlzIiwiYnVpbGRGaW5hbFRleHQiLCJjaGFyYWN0ZXJzQXJyYXkiLCJzaG91bGRDb21iaW5lIiwic2hvdWxkQ29tYmluZU5leHQiLCJjdXJyZW50Q2hhcnMiLCJjaGFyQXQiLCJsZXR0ZXJzIiwibmV3TGluZUZsYWciLCJhbmNob3JHcm91cGluZyIsImN1cnJlbnRTaXplIiwiY3VycmVudFBvcyIsImN1cnJlbnRMaW5lIiwibGluZVdpZHRoIiwibWF4TGluZVdpZHRoIiwidHJhY2tpbmdPZmZzZXQiLCJib3hIZWlnaHQiLCJjdXJyZW50SGVpZ2h0IiwibGFzdFNwYWNlSW5kZXgiLCJ1bmNvbGxhcHNlZFNwYWNlcyIsImN1cnJlbnRDaGFyIiwiYW4iLCJhZGQiLCJhbkluZGV4ZXMiLCJhbmltYXRvckp1c3RpZnlPZmZzZXQiLCJleHRyYSIsImFuaW1hdG9ycyIsImFuaW1hdG9yRGF0YSIsImxldHRlckRhdGEiLCJiYXNlZCIsImluZGV4ZXMiLCJmaCIsImZzIiwiZmIiLCJybiIsInRvdGFsQ2hhcnMiLCJjdXJyZW50SW5kIiwibmV3SW5kIiwibmV3RGF0YSIsImREYXRhIiwicmVjYWxjdWxhdGUiLCJjYW5SZXNpemVGb250IiwiX2NhblJlc2l6ZSIsInNldE1pbmltdW1Gb250U2l6ZSIsIl9mb250VmFsdWUiLCJUZXh0U2VsZWN0b3JQcm9wIiwiVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkiLCJfY3VycmVudFRleHRMZW5ndGgiLCJmaW5hbFMiLCJmaW5hbEUiLCJ4ZSIsIm5lIiwic20iLCJnZXRNdWx0IiwidGV4dFByb3BlcnR5IiwiZWFzZXIiLCJ0b3QiLCJzbW9vdGhuZXNzIiwidGhyZXNob2xkIiwibmV3Q2hhcnNGbGFnIiwiZGl2aXNvciIsImdldFRleHRTZWxlY3RvclByb3AiLCJUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkiLCJhbmltYXRvclByb3BzIiwiZGVmYXVsdERhdGEiLCJ0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcyIsIlRleHRBbmltYXRvclByb3BlcnR5IiwicmVuZGVyVHlwZSIsIl9oYXNNYXNrZWRQYXRoIiwiX3RleHREYXRhIiwiX3JlbmRlclR5cGUiLCJfZWxlbSIsIl9hbmltYXRvcnNEYXRhIiwiX3BhdGhEYXRhIiwiX21vcmVPcHRpb25zIiwiYWxpZ25tZW50IiwicmVuZGVyZWRMZXR0ZXJzIiwibGV0dGVyc0NoYW5nZWRGbGFnIiwic2VhcmNoUHJvcGVydGllcyIsImdldE1lYXN1cmVzIiwibWF0cml4SGVscGVyIiwicmVuZGVyZWRMZXR0ZXJzQ291bnQiLCJ4UG9zIiwieVBvcyIsInBhdGhJbmZvIiwiY3VycmVudExlbmd0aCIsImN1cnJlbnRQb2ludCIsInBvaW50SW5kIiwic2VnbWVudEluZCIsInRhbkFuZ2xlIiwidExlbmd0aCIsInBpIiwieU9mZiIsImZpcnN0TGluZSIsImFuaW1hdG9yU2VsZWN0b3IiLCJsZXR0ZXJWYWx1ZSIsIm9mZmYiLCJ4UGF0aFBvcyIsInlQYXRoUG9zIiwiaW5pdFBhdGhQb3MiLCJpbml0U2VnbWVudEluZCIsImluaXRQb2ludEluZCIsImVsZW1PcGFjaXR5IiwibGV0dGVyU3ciLCJsZXR0ZXJTYyIsImxldHRlckZjIiwibGV0dGVyTSIsImxldHRlclAiLCJkZWZhdWx0UHJvcHNBcnJheSIsImxldHRlck8iLCJhbmltYXRvckZpcnN0Q2hhck9mZnNldCIsImp1c3RpZnlPZmZzZXRNdWx0IiwiaXNOZXdMaW5lIiwiYW5pbWF0b3JPZmZzZXQiLCJhdGFuIiwiSVRleHRFbGVtZW50IiwidGV4dEFuaW1hdG9yIiwiY3JlYXRlUGF0aFNoYXBlIiwic2hhcGVTdHIiLCJfZm9udFNpemUiLCJhcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgiLCJsaW5lTnVtYmVyIiwiYnVpbGRDb2xvciIsImNvbG9yRGF0YSIsImVtcHR5UHJvcCIsInZhbGlkYXRlVGV4dCIsImJ1aWxkTmV3VGV4dCIsImVtcHR5U2hhcGVEYXRhIiwiU1ZHVGV4dExvdHRpZUVsZW1lbnQiLCJ0ZXh0U3BhbnMiLCJzaW5nbGVTaGFwZSIsInRleHRDb250YWluZXIiLCJidWlsZFRleHRDb250ZW50cyIsInRleHRBcnJheSIsInRleHRDb250ZW50cyIsImN1cnJlbnRUZXh0Q29udGVudCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImJ1aWxkU2hhcGVEYXRhIiwic2hhcGVJdGVtIiwidXNlc0dseXBocyIsInRTcGFuIiwidEVsZW1lbnQiLCJqdXN0aWZ5Iiwic3BhbiIsImdseXBoIiwiY2FjaGVkU3BhbnNMZW5ndGgiLCJjaGlsZFNwYW4iLCJnbHlwaEVsZW1lbnQiLCJTVkdDb21wRWxlbWVudCIsIl9kZWJ1ZyIsInRleHRCb3giLCJiYm94IiwicmVuZGVyZWRMZXR0ZXIiLCJ0ZXh0U3BhbiIsIklTb2xpZEVsZW1lbnQiLCJOdWxsRWxlbWVudCIsIlNWR1JlbmRlcmVyQmFzZSIsInN2Z0VsZW1lbnQiLCJ2aWV3Qm94U2l6ZSIsInZpZXdCb3hPbmx5IiwiY29udGVudFZpc2liaWxpdHkiLCJjbGFzc05hbWUiLCJmb2N1c2FibGUiLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIiwiZGVzdHJveWVkIiwiZmluZEluZGV4QnlJbmQiLCJhcHBlbmRFbGVtZW50SW5Qb3MiLCJlbGVtZW50SW5kZXgiLCJ0cCIsIm1hdHRlTWFzayIsIm5leHRFbGVtZW50IiwiaW5zZXJ0QmVmb3JlIiwiSUNvbXBFbGVtZW50Iiwic2V0RWxlbWVudHMiLCJnZXRFbGVtZW50cyIsImRlc3Ryb3lFbGVtZW50cyIsInN1cHBvcnRzM2QiLCJTVkdSZW5kZXJlciIsImNvbmZpZyIsImFyaWFMYWJlbCIsInRpdGxlIiwidGl0bGVFbGVtZW50IiwidGl0bGVJZCIsImRlc2NyaXB0aW9uIiwiZGVzY0VsZW1lbnQiLCJkZXNjSWQiLCJmaWx0ZXJTaXplIiwicnVuRXhwcmVzc2lvbnMiLCJTaGFwZVRyYW5zZm9ybU1hbmFnZXIiLCJzZXF1ZW5jZXMiLCJzZXF1ZW5jZUxpc3QiLCJ0cmFuc2Zvcm1fa2V5X2NvdW50IiwiYWRkVHJhbnNmb3JtU2VxdWVuY2UiLCJzZXF1ZW5jZSIsInByb2Nlc3NTZXF1ZW5jZSIsInByb2Nlc3NTZXF1ZW5jZXMiLCJnZXROZXdLZXkiLCJsdW1hTG9hZGVyIiwibHVtYUJ1ZmZlciIsImx1bWFCdWZmZXJDdHgiLCJzdmciLCJjcmVhdGVMdW1hU3ZnRmlsdGVyIiwiX3N2ZyIsImxvYWRMdW1hIiwiZ2V0THVtYSIsImNyZWF0ZUNhbnZhcyIsImxvYWRMdW1hQ2FudmFzIiwiZ2V0THVtYUNhbnZhcyIsInJlZ2lzdGVyZWRFZmZlY3RzIiwiQ1ZFZmZlY3RzIiwicmVnaXN0ZXJFZmZlY3QiLCJDVk1hc2tFbGVtZW50IiwiaGFzTWFza3MiLCJjYW52YXNDb250ZXh0IiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwiYmV6aWVyQ3VydmVUbyIsInNhdmUiLCJjbGlwIiwiQ1ZCYXNlRWxlbWVudCIsIm9wZXJhdGlvbnNNYXAiLCJjcmVhdGVFbGVtZW50cyIsImJ1ZmZlcnMiLCJidWZmZXJDYW52YXMiLCJidWZmZXJDYW52YXMyIiwiX2lzUHJveHkiLCJ0cmFuc2Zvcm1DYW52YXMiLCJibGVuZE1vZGUiLCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24iLCJoaWRlRWxlbWVudCIsInNob3dFbGVtZW50IiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJwcmVwYXJlTGF5ZXIiLCJidWZmZXIiLCJidWZmZXJDdHgiLCJkcmF3SW1hZ2UiLCJnZXRUcmFuc2Zvcm0iLCJleGl0TGF5ZXIiLCJmb3JjZVJlYWxTdGFjayIsImN0eFRyYW5zZm9ybSIsImN0eE9wYWNpdHkiLCJyZXN0b3JlIiwiQ1ZTaGFwZURhdGEiLCJ0cmFuc2Zvcm1zTWFuYWdlciIsInN0eWxlZFNoYXBlcyIsInN0eWxlZFNoYXBlIiwidHJOb2RlcyIsIkNWU2hhcGVFbGVtZW50IiwidHJhbnNmb3JtSGVscGVyIiwiZGFzaFJlc2V0dGVyIiwicHJlVHJhbnNmb3JtcyIsImNvIiwid2kiLCJkYSIsImFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0IiwicmVtb3ZlVHJhbnNmb3JtRnJvbVN0eWxlTGlzdCIsImNsb3NlU3R5bGVzIiwic2hvdWxkUmVuZGVyIiwib3duVHJhbnNmb3JtcyIsIl9zaG91bGRSZW5kZXIiLCJyZW5kZXJTaGFwZVRyYW5zZm9ybSIsInBhcmVudFRyYW5zZm9ybSIsImdyb3VwVHJhbnNmb3JtIiwiZHJhd0xheWVyIiwibm9kZXMiLCJjdXJyZW50U3R5bGUiLCJjb09wIiwiY3VycmVudEdsb2JhbEFscGhhIiwiY3R4U3Ryb2tlU3R5bGUiLCJncmQiLCJjdHhMaW5lV2lkdGgiLCJjdHhMaW5lQ2FwIiwiY3R4TGluZUpvaW4iLCJjdHhNaXRlckxpbWl0IiwiY3R4RmlsbFN0eWxlIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImNsb3NlUGF0aCIsImN0eFN0cm9rZSIsImN0eEZpbGwiLCJpc01haW4iLCJyZW5kZXJHcmFkaWVudEZpbGwiLCJyZW5kZXJTdHlsZWRTaGFwZSIsInNoYXBlTm9kZXMiLCJncm91cFRyYW5zZm9ybU1hdCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJhZGRDb2xvclN0b3AiLCJDVlRleHRFbGVtZW50Iiwic3Ryb2tlIiwiZmlsbCIsImN1cnJlbnRSZW5kZXIiLCJzV2lkdGgiLCJmVmFsdWUiLCJoYXNGaWxsIiwiaGFzU3Ryb2tlIiwiY29tbWFuZHMiLCJwYXRoQXJyIiwiY29tbWFuZHNDb3VudGVyIiwibGFzdEZpbGwiLCJsYXN0U3Ryb2tlIiwibGFzdFN0cm9rZVciLCJDVkltYWdlRWxlbWVudCIsImltZ1ciLCJpbWdIIiwiaW1nUmVsIiwiY2FudmFzUmVsIiwid2lkdGhDcm9wIiwiaGVpZ2h0Q3JvcCIsInBhciIsIkNWU29saWRFbGVtZW50IiwiY3R4RmlsbFJlY3QiLCJDYW52YXNSZW5kZXJlckJhc2UiLCJnbG9iYWxBbHBoYSIsInN0cm9rZVN0eWxlIiwibGluZUNhcCIsInJ1bGUiLCJjb250ZXh0RGF0YSIsImFjdGlvbkZsYWciLCJjb250YWluZXJTdHlsZSIsIm1velRyYW5zZm9ybU9yaWdpbiIsImNvbnRleHQiLCJzZXRDb250ZXh0IiwiaXNEYXNoZWQiLCJlbGVtZW50V2lkdGgiLCJlbGVtZW50SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiZHByIiwiZWxlbWVudFJlbCIsImFuaW1hdGlvblJlbCIsImZpbGxUeXBlIiwiQ2FudmFzQ29udGV4dCIsIkNWQ29udGV4dERhdGEiLCJzdGFjayIsImNBcnJQb3MiLCJjVHIiLCJuYXRpdmVDb250ZXh0IiwidHJhbnNmb3JtTWF0IiwiY3VycmVudE9wYWNpdHkiLCJjdXJyZW50RmlsbFN0eWxlIiwiYXBwbGllZEZpbGxTdHlsZSIsImN1cnJlbnRTdHJva2VTdHlsZSIsImFwcGxpZWRTdHJva2VTdHlsZSIsImN1cnJlbnRMaW5lV2lkdGgiLCJhcHBsaWVkTGluZVdpZHRoIiwiY3VycmVudExpbmVDYXAiLCJhcHBsaWVkTGluZUNhcCIsImN1cnJlbnRMaW5lSm9pbiIsImFwcGxpZWRMaW5lSm9pbiIsImFwcGxpZWRNaXRlckxpbWl0IiwiY3VycmVudE1pdGVyTGltaXQiLCJkdXBsaWNhdGUiLCJuZXdMZW5ndGgiLCJmb3JjZVJlc3RvcmUiLCJjdXJyZW50Q29udGV4dCIsInByZXZTdGFjayIsInNhdmVPbk5hdGl2ZUZsYWciLCJjdXJyZW50U3RhY2siLCJuZXdTdGFjayIsInNldE9wYWNpdHkiLCJ0clByb3BzIiwiQ1ZDb21wRWxlbWVudCIsIkNhbnZhc1JlbmRlcmVyIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkhCYXNlRWxlbWVudCIsImNoZWNrQmxlbmRNb2RlIiwidGciLCJ0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZSIsIm1hdHJpeFZhbHVlIiwid2Via2l0VHJhbnNmb3JtIiwiYWRkRWZmZWN0cyIsIkhTb2xpZEVsZW1lbnQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJIU2hhcGVFbGVtZW50Iiwic2hhcGVzQ29udGFpbmVyIiwiY3VycmVudEJCb3giLCJfcmVuZGVyU2hhcGVGcmFtZSIsInNoYXBlQ29udCIsImdldFRyYW5zZm9ybWVkUG9pbnQiLCJjYWxjdWxhdGVTaGFwZUJvdW5kaW5nQm94IiwiaXRlbSIsInZQb2ludCIsIm9Qb2ludCIsIm5leHRJUG9pbnQiLCJuZXh0VlBvaW50IiwiY2hlY2tCb3VuZHMiLCJnZXRCb3VuZHNPZkN1cnZlIiwic2hhcGVCb3VuZGluZ0JveCIsInhNYXgiLCJ5TWF4IiwidGVtcEJvdW5kaW5nQm94IiwiYjJhYyIsImNhbGN1bGF0ZUYiLCJjYWxjdWxhdGVCb3VuZGluZ0JveCIsImV4cGFuZFN0cm9rZUJvdW5kaW5nQm94Iiwid2lkdGhQcm9wZXJ0eSIsImtmdyIsImN1cnJlbnRCb3hDb250YWlucyIsImNoYW5nZWQiLCJzaGFwZVN0eWxlIiwic2hhcGVUcmFuc2Zvcm0iLCJIVGV4dEVsZW1lbnQiLCJ0ZXh0UGF0aHMiLCJpc01hc2tlZCIsImNvbXBXIiwiY29tcEgiLCJpbm5lckVsZW1TdHlsZSIsInRleHRDb2xvciIsInN0cm9rZVdpZHRoIiwibGluZUhlaWdodCIsInRQYXJlbnQiLCJ0Q29udCIsImNoaWxkcmVuIiwidENvbnRTdHlsZSIsInRDb250VHJhbnNsYXRpb24iLCJ0U3R5bGUiLCJ0U3BhblRyYW5zbGF0aW9uIiwic3ZnU3R5bGUiLCJ0cmFuc2xhdGlvbiIsInRleHRQYXRoIiwibWFyZ2luIiwic3ZnVHJhbnNmb3JtIiwiSENhbWVyYUVsZW1lbnQiLCJwZSIsIl9wcmV2TWF0Iiwic2V0dXAiLCJ0aHJlZURFbGVtZW50cyIsInBlcnNwZWN0aXZlU3R5bGUiLCJwZXJzcGVjdGl2ZUVsZW0iLCJwZXJzcGVjdGl2ZSIsIndlYmtpdFBlcnNwZWN0aXZlIiwibVRyYW5zZiIsImRpZmZWZWN0b3IiLCJtYWciLCJsb29rRGlyIiwibG9va0xlbmd0aE9uWFoiLCJtUm90YXRpb25YIiwibVJvdGF0aW9uWSIsImhhc01hdHJpeENoYW5nZWQiLCJtYXRWYWx1ZSIsIkhJbWFnZUVsZW1lbnQiLCJJbWFnZSIsImltYWdlRWxlbSIsIkh5YnJpZFJlbmRlcmVyQmFzZSIsImNhbWVyYSIsIm5ld0RPTUVsZW1lbnQiLCJkZGQiLCJhZGRUbzNkQ29udGFpbmVyIiwibmV4dERPTUVsZW1lbnQiLCJuZXh0TGF5ZXIiLCJ0bXBET01FbGVtZW50IiwiZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MiLCJzdGFydFBvcyIsImVuZFBvcyIsImNyZWF0ZVRocmVlRENvbnRhaW5lciIsInRocmVlRENvbnRhaW5lckRhdGEiLCJidWlsZDNkQ29udGFpbmVycyIsImxhc3RUaHJlZURDb250YWluZXJEYXRhIiwiY3VycmVudENvbnRhaW5lciIsInJlc2l6ZXJFbGVtIiwib3ZlcmZsb3ciLCJjV2lkdGgiLCJjSGVpZ2h0IiwiZmxvYXRpbmdDb250YWluZXIiLCJIQ29tcEVsZW1lbnQiLCJfY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzIiwiSHlicmlkUmVuZGVyZXIiLCJfdGhpc0xheWVyRnVuY3Rpb24iLCJkZWZpbmVQcm9wZXJ0eSIsInBpeGVsQXNwZWN0IiwiZnJhbWVEdXJhdGlvbiIsImRpc3BsYXlTdGFydFRpbWUiLCJudW1MYXllcnMiLCJfdHlwZW9mJDIiLCJzZWVkUmFuZG9tIiwiY2h1bmtzIiwiZGlnaXRzIiwicm5nbmFtZSIsInN0YXJ0ZGVub20iLCJzaWduaWZpY2FuY2UiLCJub2RlY3J5cHRvIiwic2VlZHJhbmRvbSIsInNlZWQiLCJvcHRpb25zIiwiZW50cm9weSIsInNob3J0c2VlZCIsIm1peGtleSIsImZsYXR0ZW4iLCJ0b3N0cmluZyIsImF1dG9zZWVkIiwiYXJjNCIsIkFSQzQiLCJwcm5nIiwiaW50MzIiLCJxdWljayIsIlMiLCJwYXNzIiwiaXNfbWF0aF9jYWxsIiwic3RhdGUiLCJjb3B5Iiwia2V5bGVuIiwibWUiLCJyZXN1bHQiLCJ0eXAiLCJzdHJpbmdzZWVkIiwic21lYXIiLCJyYW5kb21CeXRlcyIsIlVpbnQ4QXJyYXkiLCJjcnlwdG8iLCJtc0NyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImJyb3dzZXIiLCJwbHVnaW5zIiwic2NyZWVuIiwiaW5pdGlhbGl6ZSQyIiwicHJvcFR5cGVzIiwiU0hBUEUiLCJfdHlwZW9mJDEiLCJFeHByZXNzaW9uTWFuYWdlciIsImZldGNoIiwiZnJhbWVzIiwiX2xvdHRpZUdsb2JhbCIsIiRibV9pc0luc3RhbmNlT2ZBcnJheSIsImlzTnVtZXJhYmxlIiwidE9mViIsIiRibV9uZWciLCJ0T2ZBIiwibGVuQSIsInJldEFyciIsImVhc2VJbkJleiIsImVhc2VPdXRCZXoiLCJlYXNlSW5PdXRCZXoiLCJ0T2ZCIiwibGVuQiIsInN1YiIsIm11bCIsIm1vZCIsIiRibV9zdW0iLCIkYm1fc3ViIiwiJGJtX211bCIsIiRibV9kaXYiLCIkYm1fbW9kIiwiY2xhbXAiLCJtbSIsInJhZGlhbnNUb0RlZ3JlZXMiLCJyYWRpYW5zX3RvX2RlZ3JlZXMiLCJkZWdyZWVzVG9SYWRpYW5zIiwiZGVncmVlc190b19yYWRpYW5zIiwiaGVscGVyTGVuZ3RoQXJyYXkiLCJhcnIxIiwiYXJyMiIsIm5vcm1hbGl6ZSIsInZlYyIsInJnYlRvSHNsIiwiaHVlMnJnYiIsImhzbFRvUmdiIiwibGluZWFyIiwidE1pbiIsInRNYXgiLCJ2YWx1ZTEiLCJ2YWx1ZTIiLCJfdE1pbiIsInJuZCIsInJuZG0iLCJjcmVhdGVQYXRoIiwiaW5UYW5nZW50cyIsIm91dFRhbmdlbnRzIiwiYXJyUGxhY2Vob2xkZXIiLCJpblZlcnRleFBvaW50Iiwib3V0VmVydGV4UG9pbnQiLCJpbml0aWF0ZUV4cHJlc3Npb24iLCJwcm9wZXJ0eSIsIm5vT3AiLCJfdmFsdWUiLCJuZWVkc1ZlbG9jaXR5IiwiX25lZWRzUmFuZG9tIiwiZWxlbVR5cGUiLCIkYm1fdHJhbnNmb3JtIiwidGhpc1Byb3BlcnR5IiwidmFsdWVBdFRpbWUiLCJpblBvaW50Iiwib3V0UG9pbnQiLCJsb29wSW4iLCJsb29wX2luIiwibG9vcE91dCIsImxvb3Bfb3V0Iiwic21vb3RoIiwidG9Xb3JsZCIsImZyb21Xb3JsZCIsImZyb21Db21wIiwidG9Db21wIiwiZnJvbUNvbXBUb1N1cmZhY2UiLCJyb3RhdGlvbiIsImFuY2hvclBvaW50IiwidGhpc0xheWVyIiwidGhpc0NvbXAiLCJ2ZWxvY2l0eUF0VGltZSIsInNjb3BlZF9ibV9ydCIsImV4cHJlc3Npb25fZnVuY3Rpb24iLCJldmFsIiwibnVtS2V5cyIsImFjdGl2ZSIsIndpZ2dsZSIsImZyZXEiLCJhbXAiLCJpV2lnZ2xlIiwibGVuV2lnZ2xlIiwiYWRkZWRBbXBzIiwicGVyaW9kcyIsImxvb3BJbkR1cmF0aW9uIiwibG9vcE91dER1cmF0aW9uIiwiZ2V0VmVsb2NpdHlBdFRpbWUiLCJsb29rQXQiLCJlbGVtMSIsImVsZW0yIiwiZlZlYyIsInBpdGNoIiwieWF3IiwiZWFzZU91dCIsInZhbDEiLCJ2YWwyIiwiYXBwbHlFYXNlIiwiZWFzZUluIiwiZWFzZSIsImlLZXkiLCJsZW5LZXkiLCJuZWFyZXN0S2V5Iiwib2JLZXkiLCJmcmFtZXNUb1RpbWUiLCJmcHMiLCJ0aW1lVG9GcmFtZXMiLCJyYW5kU2VlZCIsInN1YnN0cmluZyIsInBvc3Rlcml6ZVRpbWUiLCJmcmFtZXNQZXJTZWNvbmQiLCJ2ZWxvY2l0eSIsInRleHRJbmRleCIsInRleHRUb3RhbCIsInNlbGVjdG9yVmFsdWUiLCJoYXNQYXJlbnQiLCJleGVjdXRlRXhwcmVzc2lvbiIsImZyYW1lRXhwcmVzc2lvbklkIiwiX19wcmV2ZW50RGVhZENvZGVSZW1vdmFsIiwiRXhwcmVzc2lvbnMiLCJzdGFja0NvdW50IiwicmVnaXN0ZXJzIiwicHVzaEV4cHJlc3Npb24iLCJwb3BFeHByZXNzaW9uIiwicmVsZWFzZUluc3RhbmNlcyIsInJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5IiwiZXhwcmVzc2lvbiIsIk1hc2tNYW5hZ2VySW50ZXJmYWNlIiwiTWFza0ludGVyZmFjZSIsIl9tYXNrIiwiX2RhdGEiLCJNYXNrTWFuYWdlciIsIl9tYXNrc0ludGVyZmFjZXMiLCJtYXNrRnVuY3Rpb24iLCJFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UiLCJkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZSIsImRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWUiLCJjb21wbGV0ZVByb3BlcnR5IiwiZXhwcmVzc2lvblZhbHVlIiwidmFsdWVQcm9wIiwic3BlZWRBdFRpbWUiLCJnZXRTcGVlZEF0VGltZSIsInByb3BlcnR5R3JvdXAiLCJVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlIiwiTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlIiwiYXJyVmFsdWUiLCJkZWZhdWx0R2V0dGVyIiwiVHJhbnNmb3JtRXhwcmVzc2lvbkludGVyZmFjZSIsIl90aGlzRnVuY3Rpb24iLCJ4Um90YXRpb24iLCJ5Um90YXRpb24iLCJ4UG9zaXRpb24iLCJ5UG9zaXRpb24iLCJ6UG9zaXRpb24iLCJfcHgiLCJfcHkiLCJfcHoiLCJfdHJhbnNmb3JtRmFjdG9yeSIsImdldE1hdHJpeCIsInRvV29ybGRNYXQiLCJwcm9wTWF0cml4IiwidG9Xb3JsZFZlYyIsImFwcGx5UG9pbnQiLCJmcm9tV29ybGRWZWMiLCJpbnZlcnRQb2ludCIsInNhbXBsZUltYWdlIiwidHJhbnNmb3JtSW50ZXJmYWNlIiwiX3JlZ2lzdGVyTWFza0ludGVyZmFjZSIsIl9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UiLCJhbmNob3JQb2ludERlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiYW5jaG9yX3BvaW50Iiwic3RhcnRUaW1lIiwiX25hbWUiLCJwcm9wZXJ0eUdyb3VwRmFjdG9yeSIsImludGVyZmFjZUZ1bmN0aW9uIiwicGFyZW50UHJvcGVydHlHcm91cCIsIlByb3BlcnR5SW50ZXJmYWNlIiwicHJvcGVydHlOYW1lIiwiX3Byb3BlcnR5R3JvdXAiLCJlZmZlY3RzRGF0YSIsImNyZWF0ZUdyb3VwSW50ZXJmYWNlIiwiZ3JvdXBJbnRlcmZhY2UiLCJtbiIsImNyZWF0ZVZhbHVlSW50ZXJmYWNlIiwibnVtUHJvcGVydGllcyIsIm5wIiwiZW5hYmxlZCIsImVuIiwiZXhwcmVzc2lvblByb3BlcnR5Iiwic2V0R3JvdXBQcm9wZXJ0eSIsIlNoYXBlUGF0aEludGVyZmFjZSIsInBhdGhJbnRlcmZhY2VGYWN0b3J5IiwidmlldyIsInByb3BlcnR5SW5kZXgiLCJpdGVyYXRlRWxlbWVudHMiLCJncm91cEludGVyZmFjZUZhY3RvcnkiLCJmaWxsSW50ZXJmYWNlRmFjdG9yeSIsInN0cm9rZUludGVyZmFjZUZhY3RvcnkiLCJ0cmltSW50ZXJmYWNlRmFjdG9yeSIsImVsbGlwc2VJbnRlcmZhY2VGYWN0b3J5Iiwic3RhckludGVyZmFjZUZhY3RvcnkiLCJyZWN0SW50ZXJmYWNlRmFjdG9yeSIsInJvdW5kZWRJbnRlcmZhY2VGYWN0b3J5IiwicmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5IiwiZ3JhZGllbnRGaWxsSW50ZXJmYWNlRmFjdG9yeSIsImRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5IiwiY29udGVudHNJbnRlcmZhY2VGYWN0b3J5IiwiaW50ZXJmYWNlcyIsIl9pbnRlcmZhY2VGdW5jdGlvbiIsInRyYW5zZm9ybUludGVyZmFjZUZhY3RvcnkiLCJjaXgiLCJzdGFydFBvaW50IiwiZW5kUG9pbnQiLCJfZGFzaFByb3BlcnR5R3JvdXAiLCJkYXNoT2IiLCJhZGRQcm9wZXJ0eVRvRGFzaE9iIiwiZGFzaCIsInN0YXJ0Iiwic2tld0F4aXMiLCJvdXRlclJhZGl1cyIsIm91dGVyUm91bmRuZXNzIiwiaW5uZXJSYWRpdXMiLCJpbm5lclJvdW5kbmVzcyIsInBhcmVudEdyb3VwV3JhcHBlciIsIl9zb3VyY2VUZXh0Iiwic291cmNlVGV4dCIsInN0cmluZ1ZhbHVlIiwiZmlsbENvbG9yIiwib3V0bGluZUludGVyZmFjZUZhY3RvcnkiLCJjdXJyZW50UHJvcGVydHlOYW1lIiwiY3VycmVudFByb3BlcnR5IiwicHJvcGVydHlOYW1lSW5kZXgiLCJkYXRhSW50ZXJmYWNlRmFjdG9yeSIsIm91dGxpbmVJbnRlcmZhY2UiLCJkYXRhSW50ZXJmYWNlIiwiZm9vdGFnZSIsImdldEludGVyZmFjZSIsImV4cHJlc3Npb25IZWxwZXJzIiwic2VhcmNoRXhwcmVzc2lvbnMiLCJfY2FjaGluZ0F0VGltZSIsInNwZWVkIiwiZ2V0U3RhdGljVmFsdWVBdFRpbWUiLCJhZGRQcm9wZXJ0eURlY29yYXRvciIsImR1cmF0aW9uRmxhZyIsImxhc3RLZXlGcmFtZSIsImN5Y2xlRHVyYXRpb24iLCJmaXJzdEtleUZyYW1lIiwicmV0IiwiaW5pdFYiLCJlbmRWIiwiY3VycmVudCIsInJlcGVhdHMiLCJsYXN0VmFsdWUiLCJuZXh0TGFzdFZhbHVlIiwiZmlyc3RWYWx1ZSIsIm5leHRGaXJzdFZhbHVlIiwic2FtcGxlcyIsImVuZEZyYW1lIiwic2FtcGxlRnJlcXVlbmN5Iiwic2FtcGxlVmFsdWUiLCJnZXRUcmFuc2Zvcm1WYWx1ZUF0VGltZSIsIl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lIiwiYW5jaG9yIiwicm90YXRpb25aIiwicm90YXRpb25ZIiwicm90YXRpb25YIiwib3JpZW50YXRpb24iLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJwb3NpdGlvbloiLCJnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSIsInByb3BlcnR5R2V0UHJvcCIsImdldFNoYXBlVmFsdWVBdFRpbWUiLCJzaGFwZVZhbHVlIiwibGFzdFRpbWUiLCJTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiIsIktleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uIiwiU2hhcGVFeHByZXNzaW9ucyIsImlzQ2xvc2VkIiwicG9pbnRPblBhdGgiLCJfc2VnbWVudHNMZW5ndGgiLCJhY2N1bXVsYXRlZExlbmd0aCIsImluaXRJbmRleCIsImVuZEluZGV4IiwidmVjdG9yT25QYXRoIiwidmVjdG9yVHlwZSIsInhMZW5ndGgiLCJ5TGVuZ3RoIiwibWFnbml0dWRlIiwidW5pdFZlY3RvciIsInRhbmdlbnRPblBhdGgiLCJub3JtYWxPblBhdGgiLCJwcm9wZXJ0eUdldFNoYXBlUHJvcCIsInRyaW1zIiwiaW5pdGlhbGl6ZSQxIiwiYWRkRGVjb3JhdG9yIiwiY2FsY3VsYXRlRXhwcmVzc2lvbiIsImdldEV4cHJlc3Npb25WYWx1ZSIsImlzS2V5ZnJhbWVkIiwiaGFzRXhwcmVzc2lvbnMiLCJpbml0aWFsaXplIiwiU1ZHQ29tcG9zYWJsZUVmZmVjdCIsImNyZWF0ZU1lcmdlTm9kZSIsInJlc3VsdElkIiwiaW5zIiwiZmVNZXJnZSIsImZlTWVyZ2VOb2RlIiwibGluZWFyRmlsdGVyVmFsdWUiLCJTVkdUaW50RmlsdGVyIiwibGluZWFyRmlsdGVyIiwibWF0cml4RmlsdGVyIiwiY29sb3JCbGFjayIsImNvbG9yV2hpdGUiLCJTVkdGaWxsRmlsdGVyIiwiU1ZHU3Ryb2tlRWZmZWN0IiwiaW5pdGlhbGl6ZWQiLCJlbGVtQ2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwiZ3JvdXBQYXRoIiwicmVtb3ZlQXR0cmlidXRlIiwicGF0aE1hc2tlciIsImRhc2hhcnJheVZhbHVlIiwiZ2V0VG90YWxMZW5ndGgiLCJsaW5lTGVuZ3RoIiwidW5pdHMiLCJTVkdUcml0b25lRmlsdGVyIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlRnVuY1IiLCJmZUZ1bmNHIiwiZmVGdW5jQiIsImNvbG9yMSIsImNvbG9yMiIsImNvbG9yMyIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsIlNWR1Byb0xldmVsc0ZpbHRlciIsImNyZWF0ZUZlRnVuYyIsImZlRnVuY0EiLCJmZUZ1bmNSQ29tcG9zZWQiLCJmZUZ1bmNHQ29tcG9zZWQiLCJmZUZ1bmNCQ29tcG9zZWQiLCJnZXRUYWJsZVZhbHVlIiwiaW5wdXRCbGFjayIsImlucHV0V2hpdGUiLCJnYW1tYSIsIm91dHB1dEJsYWNrIiwib3V0cHV0V2hpdGUiLCJ0YWJsZSIsImNvbG9yVmFsdWUiLCJvdXRwdXREZWx0YSIsImlucHV0RGVsdGEiLCJTVkdEcm9wU2hhZG93RWZmZWN0IiwiZ2xvYmFsRmlsdGVyU2l6ZSIsImZlR2F1c3NpYW5CbHVyIiwiZmVPZmZzZXQiLCJmZUZsb29kIiwiZmVDb21wb3NpdGUiLCJjb2wiLCJfc3ZnTWF0dGVTeW1ib2xzIiwiU1ZHTWF0dGUzRWZmZWN0IiwiZmlsdGVyRWxlbSIsImZpbmRTeW1ib2wiLCJyZXBsYWNlSW5QYXJlbnQiLCJzeW1ib2xJZCIsIm5leHRDaGlsZCIsInVzZUVsZW0iLCJzZXRFbGVtZW50QXNNYXNrIiwic3ltYm9sIiwiU1ZHR2F1c3NpYW5CbHVyRWZmZWN0Iiwia0JsdXJyaW5lc3NUb1NpZ21hIiwic2lnbWEiLCJkaW1lbnNpb25zIiwic2lnbWFYIiwic2lnbWFZIiwiZWRnZU1vZGUiLCJUcmFuc2Zvcm1FZmZlY3QiLCJmb3JjZUZyYW1lIiwiaXNVbmlmb3JtU2NhbGUiLCJzY2FsZUhlaWdodCIsInNjYWxlV2lkdGgiLCJTVkdUcmFuc2Zvcm1FZmZlY3QiLCJDVlRyYW5zZm9ybUVmZmVjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/lottie-web/build/player/lottie.js\n");

/***/ })

};
;